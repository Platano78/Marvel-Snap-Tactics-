<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#ED1D24" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#1A1A1A" media="(prefers-color-scheme: dark)">
  <meta name="description" content="Marvel Snap AI Companion & Tracker - Track your collection, log matches, and get tactical advice">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SnapPrime">

  <title>Snapapoulous Prime - Marvel Snap Companion</title>

  <!-- Service Worker Update Handler - runs early to catch SW updates -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'SW_UPDATED') {
          console.log('[App] Service worker updated to:', event.data.version);
          window.location.reload();
        }
      });
    }
  </script>

  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="assets/icons/icon-192.png">
  <link rel="apple-touch-icon" href="assets/icons/icon-192.png">

  <!-- iOS Splash Screens -->
  <!-- iPhone X / XS / 11 Pro (1125x2436) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone XR / 11 (828x1792) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)">
  <!-- iPhone XS Max / 11 Pro Max (1242x2688) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 12 / 12 Pro / 13 / 13 Pro / 14 (1170x2532) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 12/13 Mini (1080x2340) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 360px) and (device-height: 780px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 12 Pro Max / 13 Pro Max / 14 Plus (1284x2778) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 14 Pro (1179x2556) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 14 Pro Max (1290x2796) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone SE 2/3, iPhone 8 (750x1334) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)">
  <!-- iPhone 8 Plus (1242x2208) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3)">

  <!-- Google Identity Services for OAuth -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- QR Code Generation -->
  <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>

  <!-- LZ-String for compression (QR sync) -->
  <script src="https://unpkg.com/lz-string@1.5.0/libs/lz-string.min.js"></script>

  <!-- Tailwind Config -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'marvel-red': '#ED1D24',
            'marvel-blue': '#006EC7',
            'marvel-gold': '#FFC107',
            'marvel-black': '#1A1A1A',
            'marvel-white': '#FFFFFF',
            'series-1': '#6B7280',
            'series-2': '#22C55E',
            'series-3': '#8B5CF6',
            'series-4': '#EAB308',
            'series-5': '#EF4444',
            'spotlight': '#F97316',
          },
          fontFamily: {
            'comic': ['Impact', 'Arial Black', 'sans-serif'],
          },
          boxShadow: {
            'comic': '4px 4px 0px #1A1A1A',
            'comic-sm': '2px 2px 0px #1A1A1A',
          }
        }
      }
    }
  </script>

  <style>
    /* CSS Custom Properties for Accessibility */
    :root {
      --text-muted: #9CA3AF;      /* WCAG AA compliant - 5.4:1 contrast on #1A1A1A */
      --text-placeholder: #9CA3AF; /* WCAG AA compliant - 5.4:1 contrast */
      --text-disabled: #D1D5DB;    /* Higher contrast for disabled states */
    }

    * { -webkit-tap-highlight-color: transparent; }

    /* Custom focus ring for all interactive elements */
    :focus-visible {
      outline: 3px solid #FFC107;
      outline-offset: 2px;
    }
    :focus:not(:focus-visible) {
      outline: none;
    }
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    select:focus-visible {
      outline: 3px solid #FFC107;
      outline-offset: 2px;
      box-shadow: 0 0 0 6px rgba(255, 193, 7, 0.25);
    }

    /* Screen reader only utility class */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1A1A1A;
      color: #FFFFFF;
      min-height: 100vh;
      overflow-x: hidden;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }
    @media (orientation: landscape) {
      .app-container {
        padding-left: max(1rem, env(safe-area-inset-left));
        padding-right: max(1rem, env(safe-area-inset-right));
      }
    }
    /* Safe area support for fixed elements */
    nav.fixed.bottom-0 {
      padding-bottom: env(safe-area-inset-bottom);
    }
    header {
      padding-top: calc(1rem + env(safe-area-inset-top));
    }
    .panel-border { border: 3px solid #1A1A1A; box-shadow: 4px 4px 0px #1A1A1A; }
    .halftone { background-image: radial-gradient(circle, rgba(0,0,0,0.1) 1px, transparent 1px); background-size: 8px 8px; }
    .card-hover { transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; }
    .card-hover:active { transform: scale(0.98); }
    .series-border-1 { border-color: #6B7280; }
    .series-border-2 { border-color: #22C55E; }
    .series-border-3 { border-color: #8B5CF6; }
    .series-border-4 { border-color: #EAB308; }
    .series-border-5 { border-color: #EF4444; }
    .series-border-spotlight { border-color: #F97316; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #2D2D2D; }
    ::-webkit-scrollbar-thumb { background: #ED1D24; border-radius: 4px; }
    .tab-active { position: relative; }
    .tab-active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 3px; background: #ED1D24; }
    input[type="range"] { -webkit-appearance: none; background: #2D2D2D; border-radius: 4px; height: 8px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #ED1D24; border-radius: 50%; cursor: pointer; border: 2px solid #FFC107; }
    @keyframes pulse-snap { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .pulse-snap { animation: pulse-snap 0.5s ease-in-out infinite; }
    @keyframes typing { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
    .typing-dot { animation: typing 1.4s infinite; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    .chat-bubble { border-radius: 1rem; }
    .chat-bubble-user { border-bottom-right-radius: 0.25rem; }
    .chat-bubble-ai { border-bottom-left-radius: 0.25rem; }
    /* Drop Zone Styling */
    .drop-zone {
      border: 3px dashed #006EC7;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      background: rgba(0, 110, 199, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .drop-zone:hover, .drop-zone.drag-over {
      border-color: #ED1D24;
      background: rgba(237, 29, 36, 0.1);
      transform: scale(1.02);
    }
    .drop-zone .drop-icon { font-size: 3rem; display: block; margin-bottom: 1rem; }
    .drop-zone .file-path {
      display: block;
      margin-top: 0.5rem;
      font-size: 0.7rem;
      color: #006EC7;
      font-family: monospace;
      opacity: 0.7;
    }
    /* Modal Overlay */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 1rem;
    }
    .modal {
      background: #2D2D2D;
      border-radius: 12px;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 3px solid #1A1A1A;
      box-shadow: 4px 4px 0px #1A1A1A;
    }
    /* Spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #2D2D2D;
      border-top-color: #ED1D24;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Install banner animation */
    @keyframes slide-up {
      from { transform: translateY(100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .install-banner-enter {
      animation: slide-up 0.3s ease-out;
    }
    /* QR Code Container */
    .qr-container { background: white; padding: 1rem; border-radius: 8px; display: inline-block; }

    /* Phase 5: Sync Section Styles */
    .pc-sync-section { margin: 0; }

    .sync-divider {
      display: flex;
      align-items: center;
      margin: 20px 0;
      color: #9CA3AF;
    }
    .sync-divider::before,
    .sync-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #444;
    }
    .sync-divider span {
      padding: 0 16px;
      font-size: 0.9em;
    }

    /* Linked Folder Styles */
    .linked-folder-section {
      background: rgba(0, 110, 199, 0.1);
      border: 2px solid #006EC7;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .linked-folder-section h4 {
      margin: 0 0 8px 0;
      color: #006EC7;
      font-family: Impact, 'Arial Black', sans-serif;
    }
    .linked-folder-section .description {
      margin: 0 0 12px 0;
      color: #aaa;
      font-size: 0.85em;
    }
    .link-folder-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 1em;
      background: #006EC7;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    .link-folder-btn:hover { background: #0088ee; }
    .linked-status {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .status-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: bold;
    }
    .status-badge.linked {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }
    .unlink-btn {
      background: none;
      border: none;
      color: #9CA3AF;
      cursor: pointer;
      font-size: 0.85em;
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
    }
    .unlink-btn:hover {
      color: #ef4444;
      text-decoration: underline;
    }
    .sync-btn {
      padding: 12px 20px;
      font-size: 1em;
      background: #006EC7;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    .sync-btn:hover { background: #0088ee; }
    .sync-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .last-sync {
      margin: 0;
      font-size: 0.8em;
      color: #9CA3AF;
      text-align: center;
    }
    .not-supported-msg {
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid #FFC107;
      border-radius: 8px;
      padding: 12px;
      font-size: 0.85em;
      color: #ccc;
    }

    /* Drag & Drop JSON Styles */
    .drag-drop-section h4 {
      margin: 0 0 4px 0;
      color: #aaa;
    }
    .drag-drop-section .description {
      margin: 0 0 12px 0;
      color: #9CA3AF;
      font-size: 0.8em;
    }
    .drop-zone-json {
      border: 3px dashed #006EC7;
      border-radius: 12px;
      padding: 30px 20px;
      text-align: center;
      background: rgba(0, 110, 199, 0.05);
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .drop-zone-json:hover,
    .drop-zone-json.drag-over {
      border-color: #FFC107;
      background: rgba(255, 193, 7, 0.1);
    }
    .drop-zone-json code {
      background: #1A1A1A;
      color: #FFC107;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75em;
      word-break: break-all;
      display: block;
      margin-top: 8px;
    }

    /* Card Performance Styles */
    .performance-card {
      display: flex;
      align-items: center;
      padding: 10px 14px;
      border-radius: 8px;
      margin: 4px 0;
      background: rgba(255, 255, 255, 0.05);
    }
    .performance-card.positive { border-left: 4px solid #22c55e; }
    .performance-card.negative { border-left: 4px solid #ef4444; }
    .performance-card .rank {
      width: 36px;
      font-weight: bold;
      color: #FFC107;
      font-size: 0.9em;
    }
    .performance-card .card-name {
      flex: 1;
      font-size: 0.95em;
    }
    .performance-card .net-cubes {
      font-weight: bold;
      font-size: 1em;
    }
    .performance-card.positive .net-cubes { color: #22c55e; }
    .performance-card.negative .net-cubes { color: #ef4444; }

    /* Sync Preview Modal */
    .sync-preview-modal {
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .preview-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 14px;
      margin: 10px 0;
    }
    .import-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    .import-toggle input {
      width: 18px;
      height: 18px;
      accent-color: #ED1D24;
    }
    .preview-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    .preview-stat {
      text-align: center;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
    }
    .preview-stat .value {
      display: block;
      font-size: 1.3em;
      font-weight: bold;
      color: white;
    }
    .preview-stat .label {
      font-size: 0.75em;
      color: #9CA3AF;
    }
    .card-performance-preview {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    .card-stat {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.85em;
    }
    .card-stat.positive { background: rgba(34, 197, 94, 0.15); }
    .card-stat.negative { background: rgba(239, 68, 68, 0.15); }
    .card-stat .cubes { font-weight: bold; }
    .card-stat.positive .cubes { color: #22c55e; }
    .card-stat.negative .cubes { color: #ef4444; }

    /* Performance Summary */
    .performance-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }
    .summary-stat {
      text-align: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
    }
    .summary-stat .label {
      display: block;
      font-size: 0.75em;
      color: #9CA3AF;
      margin-bottom: 4px;
    }
    .summary-stat .value {
      font-size: 1.3em;
      font-weight: bold;
    }
    .summary-stat.positive .value { color: #22c55e; }
    .summary-stat.negative .value { color: #ef4444; }
    .summary-stat.net .value { color: #FFC107; }

    /* Stats Section Styling */
    .stats-section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .stats-section h3 {
      margin: 0 0 12px 0;
      font-size: 1em;
      color: #FFC107;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .stat-card {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
    }
    .stat-card .stat-value {
      display: block;
      font-size: 1.5em;
      font-weight: bold;
      color: white;
    }
    .stat-card .stat-label {
      font-size: 0.75em;
      color: #9CA3AF;
    }
    .stat-card.highlight .stat-value { color: #FFC107; }
    .stat-card.positive .stat-value { color: #22c55e; }
    .stat-card.negative .stat-value { color: #ef4444; }
    .data-source {
      margin-top: 8px;
      font-size: 0.75em;
      color: #9CA3AF;
      text-align: right;
    }
    .import-prompt {
      text-align: center;
      padding: 20px;
      color: #9CA3AF;
    }
    .import-prompt a {
      color: #006EC7;
      text-decoration: underline;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      white-space: pre-line;
      max-width: 90%;
      text-align: center;
    }

    /* Touch target utilities for accessibility */
    .touch-target {
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .touch-target-sm {
      min-width: 36px;
      min-height: 36px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    /* Expand clickable area while keeping visual size small */
    .touch-expand {
      position: relative;
    }
    .touch-expand::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 44px;
      height: 44px;
    }

    /* Low-end device optimizations */
    .low-end-mode *,
    .low-end-mode *::before,
    .low-end-mode *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }

    .low-end-mode .card-hover {
      transform: none !important;
    }

    .low-end-mode .halftone {
      background-image: none;
    }

    .low-end-mode .panel-border {
      box-shadow: none;
      border-width: 2px;
    }

    .low-end-mode .shadow-comic,
    .low-end-mode .shadow-comic-sm {
      box-shadow: none;
    }

    .low-end-mode .pulse-snap {
      animation: none;
    }

    .low-end-mode .typing-dot {
      animation: none;
      opacity: 1;
    }

    .low-end-mode .spinner {
      animation: spin 2s linear infinite;
    }

    /* ==================== ACCESSIBILITY & PERFORMANCE ==================== */
    /* Respect user's reduced motion preference */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
      .pulse-snap {
        animation: none !important;
      }
      .typing-dot {
        animation: none !important;
        opacity: 1 !important;
      }
      .card-hover {
        transition: none !important;
      }
      .spinner {
        animation: spin 2s linear infinite;
      }
    }

    /* Low-power mode styles (applied via JS) */
    .low-power-mode *,
    .low-power-mode *::before,
    .low-power-mode *::after {
      animation-duration: 0ms !important;
      transition-duration: 0ms !important;
    }
    .low-power-mode .card-hover {
      transform: none !important;
    }
    .low-power-mode .halftone {
      background-image: none !important;
    }
    .low-power-mode .panel-border {
      box-shadow: none !important;
    }

    /* CSS Grid fallbacks for older browsers */
    .card-grid {
      display: flex;
      flex-wrap: wrap;
    }
    .card-grid > * {
      flex: 0 0 calc(33.333% - 8px);
      margin: 4px;
    }
    @supports (display: grid) {
      .card-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }
      .card-grid > * {
        flex: none;
        margin: 0;
      }
    }

    /* Swipe-to-delete styles */
    .swipe-item-container {
      position: relative;
      overflow: hidden;
    }
    .swipe-delete-bg {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background: #DC2626;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    .swipe-item {
      position: relative;
      background: #2D2D2D;
      transition: transform 0.2s ease-out;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useRef } = React;

    // ==================== GESTURE HOOKS ====================
    // Pull-to-refresh hook
    const usePullToRefresh = (onRefresh, { threshold = 80 } = {}) => {
      const [pulling, setPulling] = useState(false);
      const [pullDistance, setPullDistance] = useState(0);
      const [refreshing, setRefreshing] = useState(false);
      const startY = useRef(0);
      const containerRef = useRef(null);

      const handleTouchStart = useCallback((e) => {
        if (containerRef.current && containerRef.current.scrollTop === 0) {
          startY.current = e.touches[0].clientY;
        }
      }, []);

      const handleTouchMove = useCallback((e) => {
        if (startY.current === 0) return;
        const currentY = e.touches[0].clientY;
        const distance = Math.max(0, Math.min(currentY - startY.current, 150));

        if (distance > 0) {
          setPullDistance(distance);
          setPulling(distance > threshold);
        }
      }, [threshold]);

      const handleTouchEnd = useCallback(async () => {
        if (pulling && !refreshing) {
          setRefreshing(true);
          try {
            await onRefresh();
          } finally {
            setRefreshing(false);
          }
        }
        setPullDistance(0);
        setPulling(false);
        startY.current = 0;
      }, [pulling, refreshing, onRefresh]);

      return {
        containerRef,
        pullDistance,
        pulling,
        refreshing,
        handlers: {
          onTouchStart: handleTouchStart,
          onTouchMove: handleTouchMove,
          onTouchEnd: handleTouchEnd
        }
      };
    };

    // Swipe-to-delete hook
    const useSwipeToDelete = (onDelete) => {
      const [translateX, setTranslateX] = useState(0);
      const [showDelete, setShowDelete] = useState(false);
      const startX = useRef(0);
      const swiping = useRef(false);

      const handleTouchStart = useCallback((e) => {
        startX.current = e.touches[0].clientX;
        swiping.current = true;
      }, []);

      const handleTouchMove = useCallback((e) => {
        if (!swiping.current) return;
        const diff = e.touches[0].clientX - startX.current;
        if (diff < 0 && diff > -100) {
          setTranslateX(diff);
        }
      }, []);

      const handleTouchEnd = useCallback(() => {
        swiping.current = false;
        if (translateX < -50) {
          setTranslateX(-80);
          setShowDelete(true);
        } else {
          setTranslateX(0);
          setShowDelete(false);
        }
      }, [translateX]);

      const resetSwipe = useCallback(() => {
        setTranslateX(0);
        setShowDelete(false);
      }, []);

      const handleDelete = useCallback(() => {
        onDelete();
        resetSwipe();
      }, [onDelete, resetSwipe]);

      return {
        translateX,
        showDelete,
        resetSwipe,
        handleDelete,
        handlers: {
          onTouchStart: handleTouchStart,
          onTouchMove: handleTouchMove,
          onTouchEnd: handleTouchEnd
        }
      };
    };

    // Pull-to-refresh visual indicator
    const PullToRefreshIndicator = ({ pullDistance, refreshing }) => {
      if (pullDistance === 0 && !refreshing) return null;

      const rotation = Math.min(pullDistance * 3, 360);
      const opacity = Math.min(pullDistance / 80, 1);

      return (
        <div
          className="flex justify-center py-2 transition-all"
          style={{
            height: refreshing ? 50 : Math.min(pullDistance, 80),
            opacity: refreshing ? 1 : opacity
          }}
        >
          <div
            className={`w-8 h-8 border-4 border-marvel-red border-t-transparent rounded-full ${refreshing ? 'animate-spin' : ''}`}
            style={{ transform: refreshing ? 'none' : `rotate(${rotation}deg)` }}
          />
        </div>
      );
    };

    // ==================== CONSTANTS ====================
    const GOOGLE_CLIENT_ID = '770573636629-tddodsck0vtmtqpdh7uj7dtevr07orn2.apps.googleusercontent.com';
    const GEMINI_SCOPES = 'https://www.googleapis.com/auth/generative-language.retriever';

    // ==================== GOOGLE OAUTH 2.0 HELPERS ====================
    let googleTokenClient = null;
    let pendingTokenResolve = null;
    let pendingTokenReject = null;

    // Initialize Google OAuth 2.0 Token Client
    const initGoogleOAuth = (callback) => {
      if (!window.google?.accounts?.oauth2) {
        console.log('Google OAuth2 library not loaded yet');
        return false;
      }

      googleTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GOOGLE_CLIENT_ID,
        scope: GEMINI_SCOPES,
        callback: (response) => {
          if (response.error) {
            console.error('Google OAuth error:', response.error);
            if (pendingTokenReject) {
              pendingTokenReject(new Error(response.error));
              pendingTokenReject = null;
              pendingTokenResolve = null;
            }
            return;
          }

          const expiresAt = Date.now() + (response.expires_in * 1000);
          localStorage.setItem('snap_google_access_token', response.access_token);
          localStorage.setItem('snap_google_token_expiry', expiresAt.toString());

          if (pendingTokenResolve) {
            pendingTokenResolve(response.access_token);
            pendingTokenResolve = null;
            pendingTokenReject = null;
          }

          if (callback) callback(response.access_token);
        },
        error_callback: (error) => {
          console.error('Google token error:', error);
          if (error.type !== 'popup_closed' && pendingTokenReject) {
            pendingTokenReject(new Error(error.message || error.type || 'Unknown error'));
            pendingTokenReject = null;
            pendingTokenResolve = null;
          }
        }
      });

      return true;
    };

    // Check if Google access token is valid
    const isGoogleTokenValid = () => {
      const token = localStorage.getItem('snap_google_access_token');
      const expiry = localStorage.getItem('snap_google_token_expiry');
      if (!token || !expiry) return false;
      return Date.now() < (parseInt(expiry) - 300000); // 5 min buffer
    };

    // Get Google access token (with auto-refresh)
    const getGoogleAccessToken = async () => {
      if (isGoogleTokenValid()) {
        return localStorage.getItem('snap_google_access_token');
      }

      // Need to get a new token
      return new Promise((resolve, reject) => {
        if (!googleTokenClient) {
          if (!initGoogleOAuth()) {
            reject(new Error('Google OAuth not initialized'));
            return;
          }
        }

        pendingTokenResolve = resolve;
        pendingTokenReject = reject;

        // Request new token - may show popup if consent needed
        googleTokenClient.requestAccessToken({ prompt: '' });
      });
    };

    // Request new Google access token (shows popup)
    const requestGoogleAccessToken = () => {
      return new Promise((resolve, reject) => {
        if (!googleTokenClient) {
          if (!initGoogleOAuth()) {
            reject(new Error('Google OAuth not initialized. Please refresh the page.'));
            return;
          }
        }

        pendingTokenResolve = resolve;
        pendingTokenReject = reject;

        googleTokenClient.requestAccessToken({ prompt: 'consent' });
      });
    };

    // Sign out from Google
    const signOutGoogle = () => {
      const token = localStorage.getItem('snap_google_access_token');
      if (token && window.google?.accounts?.oauth2) {
        google.accounts.oauth2.revoke(token, () => {
          console.log('Google token revoked');
        });
      }
      localStorage.removeItem('snap_google_access_token');
      localStorage.removeItem('snap_google_token_expiry');
    };

    // ==================== CARD DATA ====================
    // Series 1 fallback data for offline-first functionality
    const CARD_DATA_FALLBACK = [
      { name: "Abomination", cost: 5, power: 9, series: 1, ability: "No ability." },
      { name: "Ant-Man", cost: 1, power: 1, series: 1, ability: "Ongoing: If your side of this location is full, +3 Power." },
      { name: "America Chavez", cost: 6, power: 9, series: 1, ability: "On Reveal: This always starts in your deck, and is drawn on turn 6." },
      { name: "Angela", cost: 2, power: 0, series: 1, ability: "When you play a card here, +2 Power." },
      { name: "Armor", cost: 2, power: 3, series: 1, ability: "Ongoing: Cards at this location can't be destroyed." },
      { name: "Bishop", cost: 3, power: 1, series: 1, ability: "When you play a card, +1 Power." },
      { name: "Blue Marvel", cost: 5, power: 3, series: 1, ability: "Ongoing: Your other cards have +1 Power." },
      { name: "Cable", cost: 2, power: 2, series: 1, ability: "On Reveal: Draw a card from your opponent's deck." },
      { name: "Captain America", cost: 3, power: 3, series: 1, ability: "Ongoing: Your other cards at this location have +1 Power." },
      { name: "Carnage", cost: 2, power: 2, series: 1, ability: "On Reveal: Destroy your other cards here. +2 Power for each destroyed." },
      { name: "Colossus", cost: 2, power: 3, series: 1, ability: "Ongoing: Can't be destroyed, moved, or have its Power reduced." },
      { name: "Cosmo", cost: 3, power: 3, series: 1, ability: "Ongoing: On Reveal abilities won't happen at this location." },
      { name: "Cyclops", cost: 3, power: 4, series: 1, ability: "No ability." },
      { name: "Deathlok", cost: 3, power: 5, series: 1, ability: "On Reveal: Destroy your other cards at this location." },
      { name: "Elektra", cost: 1, power: 2, series: 1, ability: "On Reveal: Destroy a random enemy 1-Cost card at this location." },
      { name: "Enchantress", cost: 4, power: 5, series: 1, ability: "On Reveal: Remove the abilities from all Ongoing cards at this location." },
      { name: "Forge", cost: 2, power: 1, series: 1, ability: "On Reveal: Give the next card you play +2 Power." },
      { name: "Gamora", cost: 5, power: 7, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +5 Power." },
      { name: "Groot", cost: 3, power: 3, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power." },
      { name: "Hawkeye", cost: 1, power: 1, series: 1, ability: "On Reveal: If you play a card here next turn, +3 Power." },
      { name: "Hulk", cost: 6, power: 12, series: 1, ability: "No ability." },
      { name: "Human Torch", cost: 1, power: 2, series: 1, ability: "When this moves to a location, double its Power." },
      { name: "Iron Fist", cost: 1, power: 2, series: 1, ability: "On Reveal: After you play your next card, move it one location to the left." },
      { name: "Iron Man", cost: 5, power: 0, series: 1, ability: "Ongoing: Your total Power is doubled at this location." },
      { name: "Jessica Jones", cost: 4, power: 4, series: 1, ability: "On Reveal: If you don't play a card here next turn, +4 Power." },
      { name: "Klaw", cost: 5, power: 4, series: 1, ability: "Ongoing: The location to the right has +6 Power." },
      { name: "Korg", cost: 1, power: 1, series: 1, ability: "On Reveal: Shuffle a Rock into your opponent's deck." },
      { name: "Lady Sif", cost: 3, power: 4, series: 1, ability: "On Reveal: Discard the highest-cost card from your hand." },
      { name: "Lizard", cost: 2, power: 5, series: 1, ability: "Ongoing: -3 Power if your opponent has 4 cards here." },
      { name: "Mantis", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, draw a card from their deck." },
      { name: "Medusa", cost: 2, power: 2, series: 1, ability: "On Reveal: If this is at the middle location, +3 Power." },
      { name: "Mister Fantastic", cost: 3, power: 2, series: 1, ability: "Ongoing: Adjacent locations have +2 Power." },
      { name: "Mister Sinister", cost: 2, power: 2, series: 1, ability: "On Reveal: Add a Sinister Clone to this location with the same Power." },
      { name: "Moon Girl", cost: 4, power: 4, series: 1, ability: "On Reveal: Duplicate your hand." },
      { name: "Morph", cost: 3, power: 0, series: 1, ability: "On Reveal: Become a copy of a random card in your opponent's hand." },
      { name: "Multiple Man", cost: 2, power: 3, series: 1, ability: "When this moves, add a copy to the old location." },
      { name: "Namor", cost: 4, power: 5, series: 1, ability: "Ongoing: +5 Power if this is your only card here." },
      { name: "Nightcrawler", cost: 1, power: 2, series: 1, ability: "You can move this once." },
      { name: "Nova", cost: 1, power: 1, series: 1, ability: "When this is destroyed, give your cards +1 Power." },
      { name: "Odin", cost: 6, power: 8, series: 1, ability: "On Reveal: Activate the On Reveal abilities of your other cards at this location." },
      { name: "Onslaught", cost: 6, power: 7, series: 1, ability: "Ongoing: Double your other Ongoing effects at this location." },
      { name: "Punisher", cost: 3, power: 2, series: 1, ability: "Ongoing: +1 Power for each enemy card at this location." },
      { name: "Rocket Raccoon", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +2 Power." },
      { name: "Scarlet Witch", cost: 2, power: 3, series: 1, ability: "On Reveal: Replace this location with a random location." },
      { name: "Sentinel", cost: 2, power: 3, series: 1, ability: "On Reveal: Add another Sentinel to your hand." },
      { name: "Spectrum", cost: 6, power: 5, series: 1, ability: "On Reveal: Give your Ongoing cards +2 Power." },
      { name: "Spider-Woman", cost: 5, power: 7, series: 1, ability: "On Reveal: Afflict all enemy cards here with -1 Power." },
      { name: "Squirrel Girl", cost: 1, power: 1, series: 1, ability: "On Reveal: Add a 1-Power Squirrel to each other location." },
      { name: "Star-Lord", cost: 2, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power." },
      { name: "Strong Guy", cost: 4, power: 4, series: 1, ability: "Ongoing: If your hand is empty, +6 Power." },
      { name: "Sword Master", cost: 3, power: 6, series: 1, ability: "On Reveal: Discard a card from your hand." },
      { name: "The Thing", cost: 4, power: 6, series: 1, ability: "No ability." },
      { name: "White Queen", cost: 4, power: 6, series: 1, ability: "On Reveal: Draw a copy of the highest-Cost card in your opponent's hand." },
      { name: "White Tiger", cost: 5, power: 1, series: 1, ability: "On Reveal: Add a 7-Power Tiger to another location." },
      { name: "Wolfsbane", cost: 3, power: 1, series: 1, ability: "On Reveal: +2 Power for each other card you have here." },
      { name: "Wolverine", cost: 2, power: 2, series: 1, ability: "When this is discarded or destroyed, regenerate it at a random location." },
      { name: "Yondu", cost: 1, power: 2, series: 1, ability: "On Reveal: Remove the top card of your opponent's deck." }
    ];

    // Card data is loaded from external file for better caching
    let CARD_DATA = [...CARD_DATA_FALLBACK];
    let cardDataLoaded = false;

    // Card Data Loader - fetches full card data from JSON file
    const CardDataLoader = {
      cache: null,
      loading: false,
      loadPromise: null,

      async load() {
        // Return cached data if available
        if (this.cache) return this.cache;

        // If already loading, wait for existing promise
        if (this.loading && this.loadPromise) {
          return this.loadPromise;
        }

        this.loading = true;
        this.loadPromise = this._fetchData();

        try {
          const result = await this.loadPromise;
          return result;
        } finally {
          this.loading = false;
        }
      },

      async _fetchData() {
        try {
          // Try to load from external JSON file (service worker will cache this)
          const response = await fetch('./card-data.json');
          if (response.ok) {
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0) {
              this.cache = data;
              CARD_DATA = data;
              cardDataLoaded = true;
              console.log(`[CardDataLoader] Loaded ${data.length} cards from card-data.json`);
              return data;
            }
          }
        } catch (error) {
          console.warn('[CardDataLoader] Failed to load card-data.json:', error);
        }

        // Fallback to embedded Series 1 data
        console.log('[CardDataLoader] Using fallback Series 1 data');
        this.cache = CARD_DATA_FALLBACK;
        CARD_DATA = CARD_DATA_FALLBACK;
        cardDataLoaded = true;
        return CARD_DATA_FALLBACK;
      },

      // Get cards synchronously (returns current data, may be fallback)
      getCards() {
        return CARD_DATA;
      },

      // Check if full data is loaded
      isLoaded() {
        return cardDataLoaded && CARD_DATA.length > CARD_DATA_FALLBACK.length;
      }
    };

    // Start loading card data immediately
    CardDataLoader.load().catch(err => console.warn('[CardDataLoader] Initial load error:', err));

    // ==================== LOW-END DEVICE DETECTION ====================
    // Low-end device detection for performance optimization
    const isLowEndDevice = () => {
      // Check device memory (if available)
      if (navigator.deviceMemory && navigator.deviceMemory < 4) {
        return true;
      }

      // Check hardware concurrency (CPU cores)
      if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) {
        return true;
      }

      // Check connection type
      if (navigator.connection) {
        const { effectiveType, saveData } = navigator.connection;
        if (saveData || effectiveType === '2g' || effectiveType === 'slow-2g') {
          return true;
        }
      }

      return false;
    };

    // Check for user preference override in localStorage
    const getPerformanceModePreference = () => {
      const stored = localStorage.getItem('snap_performance_mode');
      if (stored === 'low') return true;
      if (stored === 'high') return false;
      return null; // Auto-detect
    };

    // Apply low-end mode class if needed
    const applyPerformanceMode = () => {
      const preference = getPerformanceModePreference();
      const shouldUseLowEnd = preference !== null ? preference : isLowEndDevice();

      if (shouldUseLowEnd) {
        document.body.classList.add('low-end-mode');
      } else {
        document.body.classList.remove('low-end-mode');
      }
      return shouldUseLowEnd;
    };

    // Initial application
    applyPerformanceMode();

    // Battery-aware optimizations
    if ('getBattery' in navigator) {
      navigator.getBattery().then(battery => {
        const checkBattery = () => {
          // Only auto-switch if user hasn't set a preference
          if (getPerformanceModePreference() !== null) return;

          if (battery.level < 0.2 && !battery.charging) {
            document.body.classList.add('low-end-mode');
          } else if (battery.level > 0.3 || battery.charging) {
            // Only remove if not inherently low-end
            if (!isLowEndDevice()) {
              document.body.classList.remove('low-end-mode');
            }
          }
        };

        checkBattery();
        battery.addEventListener('levelchange', checkBattery);
        battery.addEventListener('chargingchange', checkBattery);
      }).catch(() => {
        // Battery API not supported or permission denied
      });
    }

    // Connection-aware optimizations
    if (navigator.connection) {
      const updateConnectionMode = () => {
        // Only auto-switch if user hasn't set a preference
        if (getPerformanceModePreference() !== null) return;

        const { effectiveType, saveData } = navigator.connection;
        if (saveData || effectiveType === '2g' || effectiveType === 'slow-2g') {
          document.body.classList.add('low-end-mode');
        } else if (!isLowEndDevice()) {
          document.body.classList.remove('low-end-mode');
        }
      };

      navigator.connection.addEventListener('change', updateConnectionMode);
    }

    // Merge embedded cards with any cached cards from API
    const getCachedCards = () => {
      try {
        const cached = localStorage.getItem('snap_card_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          // Use cache if less than 7 days old
          if (Date.now() - timestamp < 7 * 24 * 60 * 60 * 1000 && data?.length > 0) {
            return data;
          }
        }
      } catch (e) { console.log('Cache read error:', e); }
      return [];
    };

    // uniqueCards - mutable array that updates when card data loads
    let uniqueCards = [...CARD_DATA_FALLBACK];
    let uniqueCardsUpdateCallbacks = [];

    // Function to update uniqueCards and notify listeners
    const updateUniqueCards = (newCards) => {
      // Dedupe by name
      uniqueCards = newCards.reduce((acc, card) => {
        if (!acc.find(c => c.name === card.name)) acc.push(card);
        return acc;
      }, []);
      // Notify all listeners
      uniqueCardsUpdateCallbacks.forEach(cb => cb(uniqueCards));
      console.log(`[uniqueCards] Updated with ${uniqueCards.length} cards`);
    };

    // Subscribe to uniqueCards updates
    const onUniqueCardsUpdate = (callback) => {
      uniqueCardsUpdateCallbacks.push(callback);
      return () => {
        uniqueCardsUpdateCallbacks = uniqueCardsUpdateCallbacks.filter(cb => cb !== callback);
      };
    };

    // Initialize uniqueCards with best available data
    (() => {
      const cachedCards = getCachedCards();
      const baseCards = cachedCards.length > CARD_DATA.length ? cachedCards : CARD_DATA;
      updateUniqueCards(baseCards);
    })();

    // Update uniqueCards when CardDataLoader finishes
    CardDataLoader.load().then(cards => {
      if (cards && cards.length > uniqueCards.length) {
        updateUniqueCards(cards);
      }
    }).catch(err => console.warn('[uniqueCards] Load error:', err));

    // ==================== DYNAMIC META CONTEXT ====================
    // Phase 3: Centralized meta information - update this with each patch/season
    const META_CONTEXT = {
      currentDate: new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' }),
      season: "Dragons Season",
      lastUpdated: "January 2026",
      recentOTA: [
        "Merlin: 3/5 → 3/4 (nerfed)",
        "Fantomex: 4/4 → 4/5 (buffed)",
        "Vulture: 3/3 → 3/4 (buffed)",
        "Iron Lad: 4/6 → 4/7 (buffed)",
        "Shou-Lao: New card enabling dragon combos"
      ],
      topArchetypes: [
        { name: "Shou-Lao Combo", tier: "S", description: "Dragon synergy with Shou-Lao and Draconic cards" },
        { name: "Destroy", tier: "S", description: "Knull/Death/Deadpool core with Killmonger tech" },
        { name: "High Evo", tier: "A", description: "High Evolutionary with no-ability cards" },
        { name: "Bounce", tier: "A", description: "Beast/Falcon with Hitmonkey/Angela payoffs" },
        { name: "Discard", tier: "A", description: "Apocalypse/MODOK/Hela control" },
        { name: "Move", tier: "B+", description: "Dagger/Human Torch with Heimdall finisher" }
      ],
      hotCards: ["Shou-Lao", "Knull", "Death", "High Evolutionary", "Hela", "Hit-Monkey", "Angela"],
      techCards: ["Killmonger", "Enchantress", "Shadow King", "Rogue", "Shang-Chi", "Cosmo"]
    };

    // ==================== SNAPAPOULOUS PERSONA ====================
    // Phase 4: Default fallback persona (used if persona.json fails to load)
    const DEFAULT_PERSONA = {
      name: "Snapapoulous",
      role: "Marvel Snap Tactical Advisor",
      personality: {
        tone: "Confident, knowledgeable, encouraging",
        style: "Direct tactical guidance with clear reasoning",
        voice: "Like a seasoned hero mentoring a new Avenger",
        quirks: [
          "References Marvel lore when relevant to strategy",
          "Uses card game terminology naturally",
          "Celebrates good plays with enthusiasm",
          "Constructively critiques mistakes without being harsh"
        ]
      },
      expertise: [
        "Deck building and optimization",
        "Meta analysis and counter-strategies",
        "Probability and statistics (hypergeometric draw calculations)",
        "Snap/retreat decision making",
        "Card synergies and combos",
        "Location priority mathematics",
        "OTA balance impact analysis"
      ],
      principles: [
        "The 8-Cube Mandate: Play for high-value wins when the odds favor you",
        "Retreat is not defeat: Preserving cubes is a winning strategy",
        "Adapt or fall: The meta shifts constantly, flexibility is power",
        "Know your outs: Always calculate the probability before snapping"
      ],
      knowledgeBase: {
        archetypes: ["Destroy", "Discard", "High Evolutionary", "Move", "Bounce", "Cerebro", "Shou-Lao Combo", "Zoo/Swarm", "Control", "Ongoing", "On Reveal"],
        keyConcepts: ["Cube equity", "Win condition identification", "Tech card flexibility", "Lane management", "Turn 6 power calculations"]
      },
      sampleResponses: {
        greeting: "Ready to climb the ranks? Let's review your arsenal and find your path to Infinite.",
        deckApproved: "This deck has solid synergy. You've got the tools - now trust your reads and snap with confidence.",
        retreatAdvice: "Sometimes the smartest play is knowing when to fold. Live to fight another match.",
        snapEncouragement: "The odds are in your favor. This is your moment - SNAP!"
      }
    };

    // Phase 4: Cached persona from persona.json (loaded async)
    let loadedPersona = null;
    let personaLoadAttempted = false;

    // Load persona.json asynchronously (enabled by default)
    const loadPersonaFromFile = async () => {
      if (personaLoadAttempted) return loadedPersona || DEFAULT_PERSONA;
      personaLoadAttempted = true;

      try {
        const response = await fetch('persona.json');
        if (response.ok) {
          const data = await response.json();
          loadedPersona = data.persona || data;
          console.log('Loaded persona from persona.json');
          return loadedPersona;
        }
      } catch (e) {
        console.log('Using default persona (persona.json not available):', e.message);
      }
      return DEFAULT_PERSONA;
    };

    // Get active persona (supports toggle via settings)
    const getActivePersona = () => {
      const settings = JSON.parse(localStorage.getItem('snap_settings') || '{}');
      // Phase 4: Enhanced persona ON by default, toggle to turn OFF
      if (settings.useSimplePersona) {
        return DEFAULT_PERSONA;
      }
      return loadedPersona || DEFAULT_PERSONA;
    };

    // Initialize persona loading on startup
    loadPersonaFromFile();

    // ==================== CONTEXT ANALYSIS HELPERS ====================
    // Phase 2: Rich context injection helpers

    const analyzeRecentMatches = (matches, recentCount = 10) => {
      if (!matches || matches.length === 0) {
        return {
          hasData: false,
          summary: "No match history recorded yet"
        };
      }

      const sortedMatches = [...matches].sort((a, b) =>
        new Date(b.timestamp) - new Date(a.timestamp)
      );

      const recentMatches = sortedMatches.slice(0, recentCount);
      const allTimeStats = calculateStats(matches);
      const recentStats = calculateStats(recentMatches);

      // Analyze trends
      const trend = recentStats.winRate > allTimeStats.winRate ? 'improving' :
                    recentStats.winRate < allTimeStats.winRate ? 'declining' : 'stable';

      // Analyze decks played (if tracked)
      const deckStats = analyzeDeckPerformance(matches);

      // Calculate streak
      let streak = 0;
      let streakType = null;
      for (const match of sortedMatches) {
        if (streakType === null) {
          streakType = match.result;
          streak = 1;
        } else if (match.result === streakType) {
          streak++;
        } else {
          break;
        }
      }

      return {
        hasData: true,
        allTime: allTimeStats,
        recent: recentStats,
        trend,
        streak: { count: streak, type: streakType },
        deckStats,
        recentMatchCount: recentMatches.length
      };
    };

    const calculateStats = (matches) => {
      if (matches.length === 0) return { games: 0, wins: 0, winRate: 0, netCubes: 0, avgCubes: 0 };

      const wins = matches.filter(m => m.result === 'WIN').length;
      const netCubes = matches.reduce((sum, m) =>
        sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0
      );

      return {
        games: matches.length,
        wins,
        winRate: Math.round((wins / matches.length) * 100),
        netCubes,
        avgCubes: (netCubes / matches.length).toFixed(2)
      };
    };

    const analyzeDeckPerformance = (matches) => {
      const deckMatches = matches.filter(m => m.deck && m.deck.trim());
      if (deckMatches.length === 0) return null;

      const deckData = {};
      for (const match of deckMatches) {
        const deck = match.deck.trim();
        if (!deckData[deck]) {
          deckData[deck] = { games: 0, wins: 0, cubes: 0 };
        }
        deckData[deck].games++;
        if (match.result === 'WIN') deckData[deck].wins++;
        deckData[deck].cubes += match.result === 'WIN' ? match.cubes : -match.cubes;
      }

      return Object.entries(deckData)
        .map(([name, stats]) => ({
          name,
          ...stats,
          winRate: Math.round((stats.wins / stats.games) * 100)
        }))
        .sort((a, b) => b.games - a.games)
        .slice(0, 5); // Top 5 most played decks
    };

    const analyzeCollectionGaps = (collection, allCards) => {
      const owned = new Set(collection.owned || []);
      const missing = allCards.filter(c => !owned.has(c.name));

      // Group missing by series
      const missingBySeries = {};
      for (const card of missing) {
        const series = card.series || 'Unknown';
        if (!missingBySeries[series]) missingBySeries[series] = [];
        missingBySeries[series].push(card.name);
      }

      // Identify key missing cards from current meta
      const metaCards = [...META_CONTEXT.hotCards, ...META_CONTEXT.techCards];
      const missingMetaCards = metaCards.filter(name => !owned.has(name));

      // Identify archetypes user can/cannot play
      const archetypeCards = {
        'Destroy': ['Knull', 'Death', 'Deadpool', 'Carnage', 'Venom', 'Deathlok'],
        'Discard': ['Hela', 'Apocalypse', 'MODOK', 'Blade', 'Moon Knight', 'Morbius'],
        'Bounce': ['Beast', 'Falcon', 'Hit-Monkey', 'Angela', 'Kitty Pryde'],
        'High Evo': ['High Evolutionary', 'Wasp', 'Misty Knight', 'Cyclops', 'Thing', 'Hulk'],
        'Move': ['Dagger', 'Human Torch', 'Heimdall', 'Doctor Strange', 'Iron Fist', 'Cloak']
      };

      const archetypeAccess = {};
      for (const [archetype, cards] of Object.entries(archetypeCards)) {
        const ownedCount = cards.filter(c => owned.has(c)).length;
        archetypeAccess[archetype] = {
          owned: ownedCount,
          total: cards.length,
          percent: Math.round((ownedCount / cards.length) * 100),
          missing: cards.filter(c => !owned.has(c))
        };
      }

      return {
        totalOwned: owned.size,
        totalCards: allCards.length,
        completionPercent: Math.round((owned.size / allCards.length) * 100),
        missingBySeries,
        missingMetaCards,
        archetypeAccess
      };
    };

    // ==================== AI PROVIDER MANAGER ====================
    const AIProviders = {
      'gemini-oauth': {
        id: 'gemini-oauth',
        name: 'Google (Gemini)',
        description: 'Sign in with Google - easiest option',
        authType: 'oauth',
        models: ['gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3-flash-preview', 'gemini-3-pro-preview', 'gemini-2.5-flash-lite'],
        defaultModel: 'gemini-2.5-flash',
        primary: true
      },
      'gemini': {
        id: 'gemini',
        name: 'Gemini (API Key)',
        description: 'Use your own Gemini API key',
        authType: 'api_key',
        models: ['gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3-flash-preview', 'gemini-3-pro-preview', 'gemini-2.5-flash-lite'],
        defaultModel: 'gemini-2.5-flash'
      },
      'groq': {
        id: 'groq',
        name: 'Groq',
        description: 'Fast inference, free tier available',
        authType: 'api_key',
        models: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
        defaultModel: 'llama-3.3-70b-versatile'
      },
      'claude': {
        id: 'claude',
        name: 'Claude (Anthropic)',
        description: 'Premium AI assistant',
        authType: 'api_key',
        models: ['claude-sonnet-4-20250514', 'claude-haiku-4-5-20251001'],
        defaultModel: 'claude-sonnet-4-20250514'
      },
      'openai': {
        id: 'openai',
        name: 'OpenAI (GPT)',
        description: 'ChatGPT models',
        authType: 'api_key',
        models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo'],
        defaultModel: 'gpt-4o-mini'
      },
      'local': {
        id: 'local',
        name: 'Local Models',
        description: 'Ollama, LM Studio, vLLM, or any OpenAI-compatible endpoint',
        authType: 'none',
        models: [],
        defaultModel: '',
        advanced: true
      }
    };

    // Build system prompt with user context (Phase 2: Enhanced context injection)
    const buildSystemPrompt = (collection, matches) => {
      const persona = getActivePersona();
      const matchAnalysis = analyzeRecentMatches(matches);
      const collectionAnalysis = analyzeCollectionGaps(collection, uniqueCards);

      // Build personality section from persona
      const personalitySection = `PERSONALITY:
- Tone: ${persona.personality?.tone || 'Confident and encouraging'}
- Style: ${persona.personality?.style || 'Direct tactical guidance'}
- Voice: ${persona.personality?.voice || 'Like a seasoned hero mentoring a new Avenger'}
${persona.personality?.quirks ? `- Quirks: ${persona.personality.quirks.join('; ')}` : ''}`;

      // Build expertise section
      const expertiseSection = persona.expertise ?
        `YOUR EXPERTISE:\n${persona.expertise.map(e => `- ${e}`).join('\n')}` : '';

      // Build principles section
      const principlesSection = persona.principles || persona.guiding_principles ?
        `GUIDING PRINCIPLES:\n${(persona.principles || persona.guiding_principles).map(p => `- ${p}`).join('\n')}` : '';

      // Build rich user context section
      let userContextSection = `USER CONTEXT (${META_CONTEXT.currentDate}):`;

      // Collection info
      userContextSection += `\n- Collection: ${collectionAnalysis.totalOwned}/${collectionAnalysis.totalCards} cards (${collectionAnalysis.completionPercent}% complete)`;

      // Match history section
      if (matchAnalysis.hasData) {
        userContextSection += `\n\nMATCH STATISTICS:`;
        userContextSection += `\n- All-Time: ${matchAnalysis.allTime.games} games, ${matchAnalysis.allTime.winRate}% win rate, ${matchAnalysis.allTime.netCubes >= 0 ? '+' : ''}${matchAnalysis.allTime.netCubes} cubes`;
        userContextSection += `\n- Recent (last ${matchAnalysis.recentMatchCount}): ${matchAnalysis.recent.winRate}% win rate, ${matchAnalysis.recent.netCubes >= 0 ? '+' : ''}${matchAnalysis.recent.netCubes} cubes`;
        userContextSection += `\n- Trend: ${matchAnalysis.trend === 'improving' ? '📈 Improving' : matchAnalysis.trend === 'declining' ? '📉 Declining' : '➡️ Stable'}`;

        if (matchAnalysis.streak.count > 1) {
          userContextSection += `\n- Current streak: ${matchAnalysis.streak.count} ${matchAnalysis.streak.type === 'WIN' ? 'wins' : 'losses'}`;
        }

        // Deck performance if available
        if (matchAnalysis.deckStats && matchAnalysis.deckStats.length > 0) {
          userContextSection += `\n\nDECK PERFORMANCE:`;
          for (const deck of matchAnalysis.deckStats.slice(0, 3)) {
            userContextSection += `\n- ${deck.name}: ${deck.games} games, ${deck.winRate}% WR, ${deck.cubes >= 0 ? '+' : ''}${deck.cubes} cubes`;
          }
        }
      } else {
        userContextSection += `\n- No match history recorded yet`;
      }

      // Collection gaps - key missing meta cards
      if (collectionAnalysis.missingMetaCards.length > 0) {
        userContextSection += `\n\nKEY MISSING META CARDS: ${collectionAnalysis.missingMetaCards.slice(0, 8).join(', ')}`;
      }

      // Archetype access summary
      const playableArchetypes = Object.entries(collectionAnalysis.archetypeAccess)
        .filter(([_, data]) => data.percent >= 60)
        .map(([name, data]) => `${name} (${data.percent}%)`)
        .join(', ');

      if (playableArchetypes) {
        userContextSection += `\n- Playable Archetypes: ${playableArchetypes}`;
      }

      // Build dynamic meta section
      const metaSection = `CURRENT META (${META_CONTEXT.lastUpdated} - ${META_CONTEXT.season}):
Top Archetypes:
${META_CONTEXT.topArchetypes.slice(0, 5).map(a => `- ${a.tier} Tier: ${a.name} - ${a.description}`).join('\n')}

Recent Balance Changes:
${META_CONTEXT.recentOTA.map(c => `- ${c}`).join('\n')}

Hot Cards: ${META_CONTEXT.hotCards.join(', ')}
Tech Options: ${META_CONTEXT.techCards.join(', ')}`;

      // Build knowledge base section if available from persona
      let knowledgeSection = '';
      if (persona.knowledgeBase || persona.knowledge_base) {
        const kb = persona.knowledgeBase || persona.knowledge_base;
        knowledgeSection = `\nKNOWLEDGE BASE:
- Archetypes: ${(kb.archetypes || []).join(', ')}
- Key Concepts: ${(kb.keyConcepts || kb.key_concepts || []).join(', ')}`;
      }

      // Assemble the complete system prompt
      return `You are ${persona.name}, a ${persona.role || persona.identity?.role}.
${persona.identity?.philosophy ? `\nPHILOSOPHY: "${persona.identity.philosophy}"` : ''}

${personalitySection}

${expertiseSection}

${principlesSection}

${userContextSection}

${metaSection}
${knowledgeSection}

RESPONSE GUIDELINES:
- Provide practical, actionable Marvel Snap advice
- Be thorough but focused - give complete answers without unnecessary padding
- Reference Marvel lore when it adds flavor or helps explain strategy
- Use card game terminology naturally (cube equity, snap decision, tech card, etc.)
- Consider the user's collection and recent performance when making recommendations
- If discussing decks, mention which cards the user owns vs. needs to acquire`;
    };

    // Helper to split system messages from chat messages for Gemini
    const splitSystemAndChat = (apiMessages) => {
      const systemTexts = apiMessages
        .filter(m => m.role === 'system')
        .map(m => m.content)
        .filter(Boolean);
      const chatMessages = apiMessages.filter(m => m.role !== 'system');
      return { systemText: systemTexts.join('\n\n'), chatMessages };
    };

    // API call functions for each provider
    const callGeminiOAuth = async (messages, model) => {
      // Get access token (will refresh if expired)
      const accessToken = await getGoogleAccessToken();

      if (!accessToken) {
        throw new Error('Not signed in to Google. Please sign in first.');
      }

      // Split system prompt from chat messages
      const { systemText, chatMessages } = splitSystemAndChat(messages);

      // Build request body with proper systemInstruction
      const requestBody = {
        contents: chatMessages.map(m => ({
          role: m.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: m.content }]
        })),
        generationConfig: {
          maxOutputTokens: 8192,
          temperature: 0.7
        }
      };

      // Add system instruction if we have system context
      if (systemText) {
        requestBody.systemInstruction = {
          parts: [{ text: systemText }]
        };
      }

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        if (response.status === 401) {
          // Token invalid - clear it
          localStorage.removeItem('snap_google_access_token');
          localStorage.removeItem('snap_google_token_expiry');
          throw new Error('Google session expired. Please sign in again.');
        }

        throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
      }

      const data = await response.json();

      if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
        throw new Error('Invalid response from Gemini API');
      }

      return data.candidates[0].content.parts[0].text;
    };

    const callGeminiAPIKey = async (messages, model, apiKey) => {
      // Split system prompt from chat messages
      const { systemText, chatMessages } = splitSystemAndChat(messages);

      // Build request body with proper systemInstruction
      const requestBody = {
        contents: chatMessages.map(m => ({
          role: m.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: m.content }]
        })),
        generationConfig: {
          maxOutputTokens: 8192,
          temperature: 0.7
        }
      };

      // Add system instruction if we have system context
      if (systemText) {
        requestBody.systemInstruction = {
          parts: [{ text: systemText }]
        };
      }

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        }
      );
      if (!response.ok) throw new Error(`Gemini API error: ${response.status}`);
      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    };

    const callGroq = async (messages, model, apiKey) => {
      const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 32768 })
      });
      if (!response.ok) throw new Error(`Groq error: ${response.status}`);
      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response';
    };

    const callClaude = async (messages, model, apiKey) => {
      const systemMsg = messages.find(m => m.role === 'system');
      const otherMsgs = messages.filter(m => m.role !== 'system');

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'Content-Type': 'application/json',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model,
          max_tokens: 8192,
          system: systemMsg?.content || '',
          messages: otherMsgs
        })
      });
      if (!response.ok) throw new Error(`Claude error: ${response.status}`);
      const data = await response.json();
      return data.content?.[0]?.text || 'No response';
    };

    const callOpenAI = async (messages, model, apiKey) => {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 32768 })
      });
      if (!response.ok) throw new Error(`OpenAI error: ${response.status}`);
      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response';
    };

    const callLocal = async (messages, model, endpoint) => {
      const response = await fetch(`${endpoint}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model, messages, stream: false })
      });
      if (!response.ok) throw new Error(`Local error: ${response.status}`);
      const data = await response.json();
      return data.message?.content || 'No response';
    };

    // ==================== LOG PARSER ====================
    const LogParser = {
      parsePlayerLog(logContent) {
        const matches = [];
        const lines = logContent.split('\n');

        let currentTimestamp = null;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Extract timestamp if present
          const tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\]/);
          if (tsMatch) {
            currentTimestamp = tsMatch[1];
          }

          // Look for game result patterns in the log
          if (line.includes('GameResult') || line.includes('MatchComplete') ||
              line.includes('BattleResult') || line.includes('GameOutcome') ||
              line.includes('"Result"') || line.includes('CubesDelta')) {
            try {
              // Try to find JSON object in the line
              const jsonMatch = line.match(/\{[^{}]*\}/);
              if (jsonMatch) {
                const data = JSON.parse(jsonMatch[0]);

                const result = this.normalizeResult(data.Result || data.GameOutcome || data.Outcome);
                const cubes = parseInt(data.CubesDelta || data.Cubes || data.cubes || 0);

                if (result && cubes !== 0) {
                  matches.push({
                    id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                    timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                    result: result,
                    cubes: Math.abs(cubes),
                    deckId: data.DeckId || data.DeckName || null,
                    opponent: data.OpponentName || null,
                    snapped: this.parseSnapState(data),
                    source: 'log_import',
                    notes: ''
                  });
                }
              }
            } catch (e) {
              // Not valid JSON, continue scanning
            }
          }

          // Alternative pattern: look for win/loss with cube values
          const simpleMatch = line.match(/(WIN|LOSS|VICTORY|DEFEAT|RETREAT)[^\d]*(\d+)\s*cube/i);
          if (simpleMatch && !matches.find(m => m.timestamp === currentTimestamp)) {
            const result = this.normalizeResult(simpleMatch[1]);
            const cubes = parseInt(simpleMatch[2]);
            if (result && cubes > 0) {
              matches.push({
                id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                result: result,
                cubes: cubes,
                deckId: null,
                opponent: null,
                snapped: 'NONE',
                source: 'log_import',
                notes: ''
              });
            }
          }
        }

        const unique = this.deduplicateMatches(matches);

        return {
          matches: unique,
          parseDate: new Date().toISOString(),
          rawLineCount: lines.length,
          matchCount: unique.length
        };
      },

      normalizeResult(result) {
        if (!result) return null;
        const r = String(result).toUpperCase();
        if (r.includes('WIN') || r === 'VICTORY') return 'WIN';
        if (r.includes('LOSS') || r.includes('LOSE') || r === 'DEFEAT') return 'LOSS';
        if (r.includes('RETREAT')) return 'LOSS';
        return null;
      },

      parseSnapState(data) {
        if (data.PlayerSnapped && data.OpponentSnapped) return 'BOTH';
        if (data.PlayerSnapped) return 'PLAYER';
        if (data.OpponentSnapped) return 'OPPONENT';
        return 'NONE';
      },

      deduplicateMatches(matches) {
        const seen = new Set();
        return matches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      },

      mergeWithExisting(newMatches, existingMatches) {
        const existingKeys = new Set(
          existingMatches.map(m => `${m.timestamp}-${m.result}-${m.cubes}`)
        );

        const toAdd = newMatches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          return !existingKeys.has(key);
        });

        return {
          added: toAdd,
          skipped: newMatches.length - toAdd.length,
          merged: [...existingMatches, ...toAdd].sort((a, b) =>
            new Date(b.timestamp) - new Date(a.timestamp)
          )
        };
      }
    };

    // ==================== GAME DATA PARSER (Phase 5) ====================
    const GameDataParser = {
      /**
       * Parse CollectionState.json for owned cards
       */
      parseCollection(json) {
        const cards = new Set();

        // Helper to recursively find all CardDefId values
        const findCards = (obj) => {
          if (!obj || typeof obj !== 'object') return;

          if (obj.CardDefId && typeof obj.CardDefId === 'string') {
            // Filter out tokens/created cards (usually have special naming)
            if (!obj.CardDefId.includes('Token') &&
                !obj.CardDefId.includes('Stone') &&
                !obj.CardDefId.includes('Shard') &&
                !obj.CardDefId.startsWith('_')) {
              cards.add(obj.CardDefId);
            }
          }

          // Recurse into arrays and objects
          if (Array.isArray(obj)) {
            obj.forEach(findCards);
          } else {
            Object.values(obj).forEach(findCards);
          }
        };

        findCards(json);

        return {
          type: 'collection',
          cards: Array.from(cards).sort(),
          count: cards.size,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse ProfileState.json for stats and card performance
       */
      parseProfile(json) {
        const account = json?.ServerState?.Account;
        if (!account) return null;

        // Parse card stats (net cubes per card)
        const cardStats = account.CardStats || {};
        const cardPerformance = Object.entries(cardStats)
          .map(([card, netCubes]) => ({ card, netCubes }))
          .sort((a, b) => b.netCubes - a.netCubes);

        // Parse wallet
        const wallet = json?.ServerState?.Wallet || {};
        const currencies = wallet.Currencies || {};

        const wins = account.Wins || 0;
        const losses = account.Losses || 0;

        return {
          type: 'profile',
          player: {
            name: account.Name || 'Unknown',
            tag: account.Tag || 0,
            snapId: `${account.Name || 'Unknown'}#${account.Tag || 0}`
          },
          stats: {
            wins: wins,
            losses: losses,
            ties: account.Ties || 0,
            totalGames: wins + losses + (account.Ties || 0),
            winRate: wins > 0 ? ((wins / (wins + losses)) * 100).toFixed(1) : '0.0',
            snaps: account.Snaps || 0,
            concedes: account.Concedes || 0,
            opponentConcedes: account.OpponentConcedes || 0
          },
          cardPerformance: {
            top10: cardPerformance.filter(c => c.netCubes > 0).slice(0, 10),
            bottom10: cardPerformance.filter(c => c.netCubes < 0).slice(-10).reverse(),
            all: cardPerformance
          },
          currencies: {
            credits: currencies.Credits?.TotalAmount || 0,
            gold: currencies.Gold?.TotalAmount || 0,
            tokens: currencies.CollectorsToken?.TotalAmount || 0
          },
          lastLogin: account.LastLogin,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse CharacterMasteryState.json for mastery levels
       */
      parseMastery(json) {
        const progress = json?.ServerState?.CharacterMasteryProgress?.CharacterProgressData;
        if (!progress) return null;

        const masteryData = Object.entries(progress)
          .map(([card, data]) => ({
            card,
            experience: data.Experience || 0,
            level: parseInt(data.LastClaimedLevel) || 1,
            levelCap: parseInt(data.LevelCap) || 30
          }))
          .sort((a, b) => b.level - a.level || b.experience - a.experience);

        return {
          type: 'mastery',
          cards: masteryData,
          totalCards: masteryData.length,
          avgLevel: masteryData.length > 0 ? (masteryData.reduce((sum, c) => sum + c.level, 0) / masteryData.length).toFixed(1) : '0',
          maxedCards: masteryData.filter(c => c.level >= c.levelCap).length,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse BattlePassState.json for season pass progress
       */
      parseBattlePass(json) {
        const battlePass = json?.ServerState?.BattlePass;
        if (!battlePass) return null;

        return {
          type: 'battlePass',
          season: battlePass.BattlePassDefId || 'Unknown',
          level: battlePass.Level || 0,
          xp: battlePass.Xp || 0,
          claimedLevels: battlePass.LevelsClaimed || [],
          parseDate: new Date().toISOString()
        };
      }
    };

    // ==================== INDEXEDDB HELPER (Phase 5) ====================
    const openSyncDB = () => {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('SnapSyncDB', 1);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          const db = request.result;
          resolve({
            get: (store, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readonly');
              const req = tx.objectStore(store).get(key);
              req.onsuccess = () => res(req.result);
              req.onerror = () => rej(req.error);
            }),
            put: (store, value, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readwrite');
              const req = tx.objectStore(store).put(value, key);
              req.onsuccess = () => res();
              req.onerror = () => rej(req.error);
            }),
            delete: (store, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readwrite');
              const req = tx.objectStore(store).delete(key);
              req.onsuccess = () => res();
              req.onerror = () => rej(req.error);
            })
          });
        };

        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('settings')) {
            db.createObjectStore('settings');
          }
        };
      });
    };

    // Auto-import all data without preview (for linked folder sync)
    const autoImportAll = (data) => {
      const timestamp = new Date().toISOString();
      const results = [];

      if (data.collection) {
        const existing = JSON.parse(localStorage.getItem('snap_collection') || '{"owned":[]}');
        const merged = [...new Set([...existing.owned, ...data.collection.cards])];
        localStorage.setItem('snap_collection', JSON.stringify({
          owned: merged,
          lastUpdated: timestamp,
          source: 'LinkedFolder'
        }));
        results.push(`Collection: ${merged.length} cards`);
      }

      if (data.profile) {
        localStorage.setItem('snap_profile_stats', JSON.stringify({
          ...data.profile.stats,
          snapId: data.profile.player.snapId,
          currencies: data.profile.currencies,
          importedAt: timestamp
        }));
        results.push(`Stats: ${data.profile.stats.winRate}% win rate`);

        // Card performance
        if (data.profile.cardPerformance) {
          const performanceMap = {};
          data.profile.cardPerformance.all.forEach(({ card, netCubes }) => {
            performanceMap[card] = { netCubes };
          });
          localStorage.setItem('snap_card_performance', JSON.stringify({
            cards: performanceMap,
            importedAt: timestamp
          }));
          results.push(`Card Performance: ${data.profile.cardPerformance.all.length} cards`);
        }
      }

      if (data.mastery) {
        localStorage.setItem('snap_mastery', JSON.stringify({
          cards: data.mastery.cards,
          importedAt: timestamp
        }));
        results.push(`Mastery: ${data.mastery.totalCards} cards`);
      }

      return results;
    };

    // ==================== COLLECTION INFERRER ====================
    const CollectionInferrer = {
      inferFromMatches(matches) {
        const usedCards = new Set();
        for (const match of matches) {
          if (match.deckCards && Array.isArray(match.deckCards)) {
            match.deckCards.forEach(card => usedCards.add(card));
          }
        }
        return Array.from(usedCards);
      },

      mergeWithCollection(inferredCards, existingCollection) {
        const existing = new Set(existingCollection.owned || []);
        let addedCount = 0;

        for (const card of inferredCards) {
          if (!existing.has(card)) {
            existing.add(card);
            addedCount++;
          }
        }

        return {
          owned: Array.from(existing),
          addedCount,
          lastUpdated: new Date().toISOString()
        };
      }
    };

    // ==================== VAULT MANAGER ====================
    const VaultManager = {
      exportFullVault(collection, matches, settings) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const totalGames = matches.length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          version: '1.0',
          exportDate: new Date().toISOString(),
          collection: collection,
          matches: matches,
          settings: settings,
          stats: {
            totalGames,
            wins: totalWins,
            losses: totalGames - totalWins,
            winRate: totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0,
            netCubes
          }
        };
      },

      generateSyncData(collection, matches) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          v: 1,
          c: collection.owned || [],
          s: {
            wins: totalWins,
            losses: matches.length - totalWins,
            cubes: netCubes
          }
        };
      },

      compressForQR(syncData) {
        try {
          return LZString.compressToEncodedURIComponent(JSON.stringify(syncData));
        } catch (e) {
          console.error('Compression failed:', e);
          return null;
        }
      },

      decompressFromQR(compressed) {
        try {
          const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
          return JSON.parse(decompressed);
        } catch (e) {
          console.error('Decompression failed:', e);
          return null;
        }
      }
    };

    // ==================== LOG ERROR MESSAGES ====================
    const LogErrors = {
      NO_MATCHES: 'No match data found. Make sure this is the Player.log file from Marvel Snap.',
      PARSE_FAILED: 'Could not parse log file. The game may have updated its format.',
      FILE_TOO_LARGE: 'File is too large (>50MB). Try using a more recent log file.',
      INVALID_FORMAT: 'This doesn\'t appear to be a Marvel Snap log file.',
      READ_ERROR: 'Could not read the file. Please try again.'
    };

    // ==================== UTILITY FUNCTIONS ====================
    const getSeriesBorderClass = (series) => `series-border-${series}`;

    const loadFromStorage = (key, defaultValue) => {
      try {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      } catch { return defaultValue; }
    };

    const saveToStorage = (key, value) => {
      try { localStorage.setItem(key, JSON.stringify(value)); }
      catch (e) { console.warn('Storage error:', e); }
    };

    const generateId = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });

    const formatDate = (dateString) => new Date(dateString).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
    });

    // ==================== COMPONENTS ====================

    // Navigation Bar
    const NavBar = ({ activeTab, setActiveTab }) => {
      const tabs = [
        { id: 'dashboard', label: 'Home', icon: '⚡' },
        { id: 'ai', label: 'AI', icon: '🤖' },
        { id: 'collection', label: 'Cards', icon: '🃏' },
        { id: 'decks', label: 'Decks', icon: '📋' },
        { id: 'simulator', label: 'Sim', icon: '🎲' },
        { id: 'settings', label: 'More', icon: '☰' }
      ];
      return (
        <nav className="fixed bottom-0 left-0 right-0 bg-marvel-black border-t-4 border-marvel-red z-50">
          <div className="flex justify-around items-center h-16 max-w-lg mx-auto">
            {tabs.map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)}
                className={`flex flex-col items-center justify-center w-full h-full transition-colors ${
                  activeTab === tab.id ? 'text-marvel-red tab-active' : 'text-gray-400 hover:text-white'
                }`}>
                <span className="text-xl">{tab.icon}</span>
                <span className="text-xs mt-1 font-medium">{tab.label}</span>
              </button>
            ))}
          </div>
        </nav>
      );
    };

    // Header
    const Header = ({ title }) => (
      <header className="bg-marvel-red halftone py-4 px-4 shadow-comic mb-4">
        <h1 className="text-2xl font-comic text-white text-center tracking-wider">{title}</h1>
      </header>
    );

    // Dashboard Component
    const Dashboard = ({ collection, matches, onQuickMatch }) => {
      const [importedStats, setImportedStats] = useState(null);

      // Load imported stats on mount and when data updates
      useEffect(() => {
        const loadImportedStats = () => {
          const stats = loadFromStorage('snap_profile_stats', null);
          setImportedStats(stats);
        };
        loadImportedStats();
        window.addEventListener('snap-data-updated', loadImportedStats);
        return () => window.removeEventListener('snap-data-updated', loadImportedStats);
      }, []);

      const totalCards = uniqueCards.length;
      // Only count cards that exist in our database
      const ownedInDatabase = collection.owned.filter(name => uniqueCards.some(c => c.name === name)).length;
      const completionPercent = Math.min(100, Math.round((ownedInDatabase / totalCards) * 100));
      const today = new Date().toDateString();
      const todayMatches = matches.filter(m => new Date(m.timestamp).toDateString() === today);
      const todayCubes = todayMatches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);
      const totalWins = matches.filter(m => m.result === 'WIN').length;
      const totalGames = matches.length;
      const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      // Use imported stats if available, otherwise use local tracking
      const displayStats = importedStats ? {
        wins: importedStats.wins,
        losses: importedStats.losses,
        totalGames: importedStats.totalGames || (importedStats.wins + importedStats.losses),
        winRate: importedStats.winRate,
        hasImported: true,
        snapId: importedStats.snapId
      } : {
        wins: totalWins,
        losses: totalGames - totalWins,
        totalGames: totalGames,
        winRate: winRate,
        hasImported: false,
        snapId: null
      };

      const getStreak = () => {
        if (matches.length === 0) return { count: 0, type: 'none' };
        const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        const firstResult = sorted[0].result;
        let count = 0;
        for (const match of sorted) {
          if (match.result === firstResult) count++;
          else break;
        }
        return { count, type: firstResult };
      };
      const streak = getStreak();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAPAPOULOUS PRIME" />
          {/* Lifetime Stats (from imported data) */}
          {displayStats.hasImported && (
            <div className="bg-gray-800 rounded-lg p-3 mb-4 panel-border border-l-4 border-marvel-blue">
              <div className="flex items-center justify-between mb-2">
                <span className="text-xs uppercase text-gray-400">Lifetime Stats</span>
                <span className="text-xs px-2 py-0.5 bg-marvel-blue/30 text-marvel-blue rounded">From Game</span>
              </div>
              <div className="grid grid-cols-4 gap-2 text-center">
                <div>
                  <div className="text-lg font-bold text-white">{displayStats.totalGames.toLocaleString()}</div>
                  <div className="text-xs text-gray-500">Games</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-green-400">{displayStats.wins.toLocaleString()}</div>
                  <div className="text-xs text-gray-500">Wins</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-red-400">{displayStats.losses.toLocaleString()}</div>
                  <div className="text-xs text-gray-500">Losses</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-marvel-gold">{displayStats.winRate}%</div>
                  <div className="text-xs text-gray-500">Win Rate</div>
                </div>
              </div>
              {displayStats.snapId && (
                <div className="text-xs text-gray-500 text-right mt-2">{displayStats.snapId}</div>
              )}
            </div>
          )}

          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-red panel-border">
              <div className="text-gray-400 text-xs uppercase">Collection</div>
              <div className="text-2xl font-comic text-white">{completionPercent}%</div>
              <div className="text-sm text-gray-400">{ownedInDatabase}/{totalCards} cards</div>
            </div>
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-gold panel-border">
              <div className="text-gray-400 text-xs uppercase">{displayStats.hasImported ? 'Session' : 'Win Rate'}</div>
              <div className="text-2xl font-comic text-white">{winRate}%</div>
              <div className="text-sm text-gray-400">{totalWins}/{totalGames} {displayStats.hasImported ? 'tracked' : 'games'}</div>
            </div>
          </div>
          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-blue panel-border">
              <div className="text-gray-400 text-xs uppercase">Net Cubes</div>
              <div className={`text-2xl font-comic ${netCubes >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {netCubes >= 0 ? '+' : ''}{netCubes}
              </div>
              <div className="text-sm text-gray-400">Today: {todayCubes >= 0 ? '+' : ''}{todayCubes}</div>
            </div>
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-series-3 panel-border">
              <div className="text-gray-400 text-xs uppercase">Streak</div>
              <div className={`text-2xl font-comic ${streak.type === 'WIN' ? 'text-green-400' : streak.type === 'LOSS' ? 'text-red-400' : 'text-gray-400'}`}>
                {streak.count} {streak.type === 'WIN' ? 'W' : streak.type === 'LOSS' ? 'L' : '-'}
              </div>
              <div className="text-sm text-gray-400">Current</div>
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h2 className="text-lg font-comic text-marvel-gold mb-3">Quick Match</h2>
            <div className="mb-3">
              <div className="text-sm text-green-400 mb-2">WIN</div>
              <div className="flex gap-2">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`win-${cubes}`} onClick={() => onQuickMatch('WIN', cubes)}
                    className="flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded shadow-comic-sm active:shadow-none active:translate-x-0.5 active:translate-y-0.5 transition-all">
                    +{cubes}
                  </button>
                ))}
              </div>
            </div>
            <div>
              <div className="text-sm text-red-400 mb-2">LOSS</div>
              <div className="flex gap-2">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`loss-${cubes}`} onClick={() => onQuickMatch('LOSS', cubes)}
                    className="flex-1 bg-red-600 hover:bg-red-500 text-white font-bold py-3 rounded shadow-comic-sm active:shadow-none active:translate-x-0.5 active:translate-y-0.5 transition-all">
                    -{cubes}
                  </button>
                ))}
              </div>
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <h2 className="text-lg font-comic text-marvel-gold mb-3">Recent Matches</h2>
            {matches.length === 0 ? (
              <p className="text-gray-400 text-center py-4">No matches recorded yet</p>
            ) : (
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {[...matches].reverse().slice(0, 5).map(match => (
                  <div key={match.id} className={`flex items-center justify-between p-2 rounded ${
                    match.result === 'WIN' ? 'bg-green-900/30' : 'bg-red-900/30'
                  }`}>
                    <span className={`font-bold ${match.result === 'WIN' ? 'text-green-400' : 'text-red-400'}`}>
                      {match.result === 'WIN' ? '+' : '-'}{match.cubes} cubes
                    </span>
                    <span className="text-gray-400 text-sm">{formatDate(match.timestamp)}</span>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    };

    // AI Chat Component
    const AIChat = ({ collection, matches, aiConfig, setActiveTab }) => {
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);
      const messagesEndRef = useRef(null);

      const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      };

      useEffect(() => {
        scrollToBottom();
      }, [messages]);

      useEffect(() => {
        if (messages.length === 0) {
          setMessages([{
            id: generateId(),
            role: 'assistant',
            content: "Ready to climb the ranks? I'm Snapapoulous, your Marvel Snap tactical advisor. Ask me about deck building, meta matchups, snap decisions, or anything else about the game!"
          }]);
        }
      }, []);

      const isConfigured = () => {
        if (!aiConfig.provider) return false;
        if (aiConfig.provider === 'gemini-oauth') return isGoogleTokenValid();
        if (aiConfig.provider === 'local') return !!aiConfig.localEndpoint;
        return !!aiConfig.apiKeys?.[aiConfig.provider];
      };

      const sendMessage = async () => {
        if (!input.trim() || isLoading) return;
        if (!isConfigured()) {
          setError('Please configure an AI provider in Settings first.');
          return;
        }

        const userMessage = { id: generateId(), role: 'user', content: input.trim() };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);
        setError(null);

        try {
          const systemPrompt = buildSystemPrompt(collection, matches);
          const apiMessages = [
            { role: 'system', content: systemPrompt },
            ...messages.filter(m => m.role !== 'assistant' || messages.indexOf(m) > 0).map(m => ({
              role: m.role, content: m.content
            })),
            { role: 'user', content: userMessage.content }
          ];

          let response;
          const model = aiConfig.model || AIProviders[aiConfig.provider]?.defaultModel;

          switch (aiConfig.provider) {
            case 'gemini-oauth':
              // Pass full messages - callGeminiOAuth handles system instruction extraction
              response = await callGeminiOAuth(apiMessages, model);
              break;
            case 'gemini':
              // Pass full messages - callGeminiAPIKey handles system instruction extraction
              response = await callGeminiAPIKey(apiMessages, model, aiConfig.apiKeys?.gemini);
              break;
            case 'groq':
              response = await callGroq(apiMessages, model, aiConfig.apiKeys?.groq);
              break;
            case 'claude':
              response = await callClaude(apiMessages, model, aiConfig.apiKeys?.claude);
              break;
            case 'openai':
              response = await callOpenAI(apiMessages, model, aiConfig.apiKeys?.openai);
              break;
            case 'local':
              response = await callLocal(apiMessages, model, aiConfig.localEndpoint);
              break;
            default:
              throw new Error('Unknown provider');
          }

          setMessages(prev => [...prev, {
            id: generateId(),
            role: 'assistant',
            content: response
          }]);
        } catch (err) {
          setError(err.message || 'Failed to get response');
          console.error('AI error:', err);
        } finally {
          setIsLoading(false);
        }
      };

      const quickPrompts = [
        "Analyze my win rate",
        "Best deck for climbing?",
        "When should I snap?",
        "Counter Destroy decks"
      ];

      return (
        <div className="flex flex-col h-[calc(100vh-4rem)] pb-16">
          <Header title="SNAPAPOULOUS AI" />

          {!isConfigured() && (
            <div className="mx-4 mb-4 bg-yellow-900/50 border border-yellow-600 rounded-lg p-4">
              <p className="text-yellow-200 text-sm mb-2">AI not configured yet!</p>
              <button onClick={() => setActiveTab('settings')}
                className="bg-marvel-gold text-black px-4 py-2 rounded font-medium hover:bg-yellow-400">
                Configure AI Provider
              </button>
            </div>
          )}

          <div className="flex-1 overflow-y-auto px-4 space-y-4">
            {messages.map(msg => (
              <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                <div className={`max-w-[85%] p-3 chat-bubble ${
                  msg.role === 'user'
                    ? 'bg-marvel-blue text-white chat-bubble-user'
                    : 'bg-gray-700 text-white chat-bubble-ai'
                }`}>
                  <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                </div>
              </div>
            ))}

            {isLoading && (
              <div className="flex justify-start">
                <div className="bg-gray-700 p-4 rounded-lg chat-bubble chat-bubble-ai">
                  <div className="flex gap-1">
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                  </div>
                </div>
              </div>
            )}

            {error && (
              <div className="bg-red-900/50 border border-red-500 rounded-lg p-3">
                <p className="text-red-300 text-sm">{error}</p>
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>

          {messages.length <= 1 && (
            <div className="px-4 py-2">
              <div className="flex flex-wrap gap-2">
                {quickPrompts.map(prompt => (
                  <button key={prompt} onClick={() => setInput(prompt)}
                    className="bg-gray-700 text-gray-300 text-xs px-4 py-2 rounded-full hover:bg-gray-600 touch-target-sm">
                    {prompt}
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="p-4 bg-gray-900 border-t border-gray-700">
            <div className="flex gap-2">
              <input type="text" value={input} onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && sendMessage()}
                placeholder="Ask Snapapoulous..."
                disabled={isLoading}
                className="flex-1 bg-gray-800 text-white rounded-lg px-4 py-3 border-2 border-gray-700 focus:border-marvel-red focus:outline-none disabled:opacity-50"
              />
              <button onClick={sendMessage} disabled={isLoading || !input.trim()}
                className="bg-marvel-red text-white px-6 py-3 rounded-lg font-medium hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed shadow-comic-sm">
                Send
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Collection Component
    const Collection = ({ collection, setCollection }) => {
      const [search, setSearch] = useState('');
      const [seriesFilter, setSeriesFilter] = useState('all');
      const [ownedFilter, setOwnedFilter] = useState('all');
      const [selectedCard, setSelectedCard] = useState(null);
      const [confirmDialog, setConfirmDialog] = useState({ isOpen: false, action: null });

      const handleClearAll = useCallback(() => {
        setConfirmDialog({
          isOpen: true,
          action: 'clearCollection'
        });
      }, []);

      const confirmClearCollection = useCallback(() => {
        setCollection({ owned: [], lastUpdated: new Date().toISOString() });
        setConfirmDialog({ isOpen: false, action: null });
      }, [setCollection]);

      const filteredCards = useMemo(() => {
        return uniqueCards.filter(card => {
          if (search && !card.name.toLowerCase().includes(search.toLowerCase())) return false;
          if (seriesFilter !== 'all' && card.series !== parseInt(seriesFilter)) return false;
          const isOwned = collection.owned.includes(card.name);
          if (ownedFilter === 'owned' && !isOwned) return false;
          if (ownedFilter === 'missing' && isOwned) return false;
          return true;
        });
      }, [search, seriesFilter, ownedFilter, collection.owned]);

      const toggleCard = (cardName) => {
        setCollection(prev => {
          const isOwned = prev.owned.includes(cardName);
          return {
            owned: isOwned ? prev.owned.filter(c => c !== cardName) : [...prev.owned, cardName],
            lastUpdated: new Date().toISOString()
          };
        });
      };

      const markAllSeries = (series) => {
        const seriesCards = uniqueCards.filter(c => c.series === series).map(c => c.name);
        setCollection(prev => ({
          owned: [...new Set([...prev.owned, ...seriesCards])],
          lastUpdated: new Date().toISOString()
        }));
      };

      // Only count cards that exist in our database
      const ownedInDatabase = collection.owned.filter(name => uniqueCards.some(c => c.name === name)).length;
      const completionPercent = Math.min(100, Math.round((ownedInDatabase / uniqueCards.length) * 100));

      return (
        <div className="px-4 pb-20">
          <Header title="COLLECTION" />
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between mb-2">
              <span className="text-white font-medium">Completion</span>
              <span className="text-marvel-gold font-bold">{completionPercent}%</span>
            </div>
            <div className="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
              <div className="bg-gradient-to-r from-marvel-red to-marvel-gold h-full transition-all duration-500"
                style={{ width: `${completionPercent}%` }} />
            </div>
            <div className="text-center text-sm text-gray-400 mt-2">
              {ownedInDatabase} / {uniqueCards.length} cards owned
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <input type="text" placeholder="Search cards..." value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-3 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
            <div className="flex gap-2 mb-3">
              <select value={seriesFilter} onChange={(e) => setSeriesFilter(e.target.value)}
                className="flex-1 bg-gray-700 text-white rounded px-2 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none">
                <option value="all">All Series</option>
                <option value="1">Series 1</option>
                <option value="2">Series 2</option>
                <option value="3">Series 3</option>
                <option value="4">Series 4</option>
                <option value="5">Series 5</option>
              </select>
              <select value={ownedFilter} onChange={(e) => setOwnedFilter(e.target.value)}
                className="flex-1 bg-gray-700 text-white rounded px-2 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none">
                <option value="all">All Cards</option>
                <option value="owned">Owned</option>
                <option value="missing">Missing</option>
              </select>
            </div>
            <div className="flex gap-2 flex-wrap">
              <button onClick={() => markAllSeries(1)} className="bg-series-1 text-white text-xs px-3 py-2 rounded hover:opacity-80 touch-target-sm">Own S1</button>
              <button onClick={() => markAllSeries(2)} className="bg-series-2 text-white text-xs px-3 py-2 rounded hover:opacity-80 touch-target-sm">Own S2</button>
              <button onClick={() => markAllSeries(3)} className="bg-series-3 text-white text-xs px-3 py-2 rounded hover:opacity-80 touch-target-sm">Own S3</button>
              <button onClick={() => markAllSeries(4)} className="bg-series-4 text-white text-xs px-3 py-2 rounded hover:opacity-80 touch-target-sm">Own S4</button>
              <button onClick={() => markAllSeries(5)} className="bg-series-5 text-white text-xs px-3 py-2 rounded hover:opacity-80 touch-target-sm">Own S5</button>
              <button onClick={handleClearAll}
                className="bg-red-600 text-white text-xs px-3 py-2 rounded hover:opacity-80 ml-auto touch-target-sm">Clear All</button>
            </div>
          </div>
          <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
            {filteredCards.map(card => {
              const isOwned = collection.owned.includes(card.name);
              return (
                <div key={card.name} className={`relative p-2 rounded-lg border-3 transition-all card-hover ${getSeriesBorderClass(card.series)} ${
                    isOwned ? 'bg-gray-700 border-opacity-100' : 'bg-gray-900 border-opacity-30 opacity-50'
                  }`} style={{ borderWidth: '3px' }}>
                  <button onClick={() => toggleCard(card.name)} className="w-full h-full">
                    <div className="absolute top-1 left-1 w-6 h-6 bg-marvel-blue rounded-full flex items-center justify-center text-xs font-bold text-white">{card.cost}</div>
                    <div className="absolute top-1 right-1 w-6 h-6 bg-marvel-red rounded-full flex items-center justify-center text-xs font-bold text-white">{card.power}</div>
                    <div className="mt-6 text-xs text-white text-center truncate">{card.name}</div>
                    {isOwned && (
                      <div className="absolute -top-1 -right-1 w-6 h-6 bg-green-500 rounded-full flex items-center justify-center">
                        <span className="text-white text-xs">✓</span>
                      </div>
                    )}
                  </button>
                  <button onClick={(e) => { e.stopPropagation(); setSelectedCard(card); }}
                    className="absolute bottom-1 right-1 w-7 h-7 bg-gray-600 hover:bg-marvel-gold rounded-full flex items-center justify-center text-xs text-white z-10 touch-expand"
                    title="View card details">i</button>
                </div>
              );
            })}
          </div>
          {filteredCards.length === 0 && <div className="text-center text-gray-400 py-8">No cards found</div>}

          {/* Card Detail Modal */}
          {selectedCard && (
            <div className="fixed inset-0 bg-black bg-opacity-80 z-50 flex items-center justify-center p-4" onClick={() => setSelectedCard(null)}>
              <div className="bg-gray-800 rounded-lg panel-border max-w-sm w-full p-6" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-start mb-4">
                  <h3 className="text-xl font-comic text-white">{selectedCard.name}</h3>
                  <button onClick={() => setSelectedCard(null)} className="text-gray-400 hover:text-white text-xl">&times;</button>
                </div>
                <div className="flex gap-4 mb-4">
                  <div className="flex items-center gap-2">
                    <span className="w-8 h-8 bg-marvel-blue rounded-full flex items-center justify-center font-bold text-white">{selectedCard.cost}</span>
                    <span className="text-gray-400 text-sm">Cost</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="w-8 h-8 bg-marvel-red rounded-full flex items-center justify-center font-bold text-white">{selectedCard.power}</span>
                    <span className="text-gray-400 text-sm">Power</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className={`w-8 h-8 rounded-full flex items-center justify-center font-bold text-white ${
                      selectedCard.series === 1 ? 'bg-series-1' : selectedCard.series === 2 ? 'bg-series-2' :
                      selectedCard.series === 3 ? 'bg-series-3' : selectedCard.series === 4 ? 'bg-series-4' : 'bg-series-5'
                    }`}>{selectedCard.series}</span>
                    <span className="text-gray-400 text-sm">Series</span>
                  </div>
                </div>
                <div className="bg-gray-700 rounded-lg p-4">
                  <p className="text-gray-300 text-sm leading-relaxed">{selectedCard.ability || 'No ability text available.'}</p>
                </div>
                <div className="mt-4 flex gap-2">
                  <button onClick={() => { toggleCard(selectedCard.name); setSelectedCard(null); }}
                    className={`flex-1 py-2 rounded font-medium ${
                      collection.owned.includes(selectedCard.name)
                        ? 'bg-red-600 hover:bg-red-700 text-white'
                        : 'bg-green-600 hover:bg-green-700 text-white'
                    }`}>
                    {collection.owned.includes(selectedCard.name) ? 'Remove from Collection' : 'Add to Collection'}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Clear Collection Confirmation Dialog */}
          <ConfirmDialog
            isOpen={confirmDialog.isOpen && confirmDialog.action === 'clearCollection'}
            title="Clear Collection"
            message="Are you sure you want to clear your entire collection? This cannot be undone."
            confirmText="Clear All"
            cancelText="Keep Cards"
            danger={true}
            onConfirm={confirmClearCollection}
            onCancel={() => setConfirmDialog({ isOpen: false, action: null })}
          />
        </div>
      );
    };

    // ==================== DECKS COMPONENT ====================
    const Decks = ({ decks, setDecks, collection }) => {
      const [view, setView] = useState('list'); // list, create, edit, import
      const [editingDeck, setEditingDeck] = useState(null);
      const [deckName, setDeckName] = useState('');
      const [selectedCards, setSelectedCards] = useState([]);
      const [importCode, setImportCode] = useState('');
      const [importUrl, setImportUrl] = useState('');
      const [importError, setImportError] = useState('');
      const [searchCard, setSearchCard] = useState('');
      const [seriesFilter, setSeriesFilter] = useState('all');
      const [deckToDelete, setDeckToDelete] = useState(null);

      const startNewDeck = () => {
        setDeckName('');
        setSelectedCards([]);
        setEditingDeck(null);
        setView('create');
      };

      const editDeck = (deck) => {
        setDeckName(deck.name);
        setSelectedCards([...deck.cards]);
        setEditingDeck(deck.id);
        setView('create');
      };

      const toggleCardInDeck = (cardName) => {
        if (selectedCards.includes(cardName)) {
          setSelectedCards(prev => prev.filter(c => c !== cardName));
        } else if (selectedCards.length < 12) {
          setSelectedCards(prev => [...prev, cardName]);
        }
      };

      const saveDeck = () => {
        if (!deckName.trim() || selectedCards.length !== 12) {
          alert('Please name your deck and select exactly 12 cards.');
          return;
        }
        const newDeck = {
          id: editingDeck || generateId(),
          name: deckName.trim(),
          cards: selectedCards,
          createdAt: editingDeck ? decks.find(d => d.id === editingDeck)?.createdAt : new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        if (editingDeck) {
          setDecks(prev => prev.map(d => d.id === editingDeck ? newDeck : d));
        } else {
          setDecks(prev => [...prev, newDeck]);
        }
        setView('list');
        setEditingDeck(null);
      };

      const deleteDeck = useCallback((id) => {
        setDeckToDelete(id);
      }, []);

      const confirmDeleteDeck = useCallback(() => {
        if (deckToDelete) {
          setDecks(prev => prev.filter(d => d.id !== deckToDelete));
          setDeckToDelete(null);
        }
      }, [deckToDelete, setDecks]);

      // Decode deck code (base64 encoded card list)
      const decodeDeckCode = (code) => {
        try {
          const decoded = atob(code.trim());
          const cardNames = decoded.split(',').map(s => s.trim()).filter(Boolean);
          if (cardNames.length !== 12) throw new Error('Deck must have 12 cards');
          // Verify cards exist
          cardNames.forEach(name => {
            if (!uniqueCards.find(c => c.name.toLowerCase() === name.toLowerCase())) {
              throw new Error(`Unknown card: ${name}`);
            }
          });
          return cardNames.map(name => uniqueCards.find(c => c.name.toLowerCase() === name.toLowerCase()).name);
        } catch (e) {
          throw new Error('Invalid deck code: ' + e.message);
        }
      };

      // Import from MarvelSnapZone URL
      const importFromUrl = async () => {
        setImportError('');
        try {
          // Extract deck name and cards from URL
          // URL format: https://marvelsnapzone.com/decks/deck-name/
          const url = importUrl.trim();
          if (!url.includes('marvelsnapzone.com') && !url.includes('untapped.gg')) {
            throw new Error('Please enter a MarvelSnapZone or Untapped.gg deck URL');
          }

          // For demonstration, we'll parse the URL manually
          // In production, you'd fetch the page and parse the card list
          setImportError('URL import coming soon! For now, please use a deck code.');
        } catch (e) {
          setImportError(e.message);
        }
      };

      const importFromCode = () => {
        setImportError('');
        try {
          const cards = decodeDeckCode(importCode);
          setSelectedCards(cards);
          setDeckName('Imported Deck');
          setView('create');
        } catch (e) {
          setImportError(e.message);
        }
      };

      // Calculate deck stats
      const getDeckStats = (cardNames) => {
        const cards = cardNames.map(name => uniqueCards.find(c => c.name === name)).filter(Boolean);
        const avgCost = cards.length > 0 ? (cards.reduce((sum, c) => sum + c.cost, 0) / cards.length).toFixed(1) : 0;
        const totalPower = cards.reduce((sum, c) => sum + c.power, 0);
        const ownedCount = cardNames.filter(name => collection.owned.includes(name)).length;
        const curve = [0, 0, 0, 0, 0, 0, 0]; // 0-6+ cost
        cards.forEach(c => { curve[Math.min(c.cost, 6)]++; });
        return { avgCost, totalPower, ownedCount, curve, cards };
      };

      const filteredCards = useMemo(() => {
        return uniqueCards.filter(c => {
          if (searchCard && !c.name.toLowerCase().includes(searchCard.toLowerCase())) return false;
          if (seriesFilter !== 'all' && c.series !== parseInt(seriesFilter)) return false;
          return true;
        });
      }, [searchCard, seriesFilter]);

      // List View
      if (view === 'list') {
        return (
          <div className="px-4 pb-20">
            <Header title="MY DECKS" />
            <div className="flex gap-2 mb-4">
              <button onClick={startNewDeck}
                className="flex-1 bg-marvel-red text-white py-3 rounded-lg font-comic hover:opacity-80 panel-border">
                + Create Deck
              </button>
              <button onClick={() => setView('import')}
                className="flex-1 bg-series-3 text-white py-3 rounded-lg font-comic hover:opacity-80 panel-border">
                Import Deck
              </button>
            </div>
            {decks.length === 0 ? (
              <div className="text-center text-gray-400 py-12">
                <p className="text-lg mb-2">No decks yet</p>
                <p className="text-sm">Create a deck or import one from MarvelSnapZone</p>
              </div>
            ) : (
              <div className="space-y-3">
                {decks.map(deck => {
                  const stats = getDeckStats(deck.cards);
                  return (
                    <div key={deck.id} className="bg-gray-800 rounded-lg p-4 panel-border">
                      <div className="flex justify-between items-start mb-2">
                        <h3 className="text-lg font-comic text-white">{deck.name}</h3>
                        <div className="flex gap-2">
                          <button onClick={() => editDeck(deck)} className="text-marvel-blue hover:text-white text-sm">Edit</button>
                          <button onClick={() => deleteDeck(deck.id)} className="text-red-500 hover:text-red-400 text-sm">Delete</button>
                        </div>
                      </div>
                      <div className="flex gap-4 text-sm text-gray-400 mb-3">
                        <span>Avg Cost: <span className="text-marvel-blue">{stats.avgCost}</span></span>
                        <span>Total Power: <span className="text-marvel-red">{stats.totalPower}</span></span>
                        <span>Owned: <span className={stats.ownedCount === 12 ? 'text-green-500' : 'text-yellow-500'}>{stats.ownedCount}/12</span></span>
                      </div>
                      {/* Mana Curve */}
                      <div className="flex gap-1 items-end h-8 mb-3">
                        {stats.curve.map((count, cost) => (
                          <div key={cost} className="flex-1 flex flex-col items-center">
                            <div className="bg-marvel-blue w-full rounded-t" style={{ height: count * 8 + 'px' }}></div>
                            <span className="text-xs text-gray-500">{cost}{cost === 6 ? '+' : ''}</span>
                          </div>
                        ))}
                      </div>
                      {/* Card Pills */}
                      <div className="flex flex-wrap gap-1">
                        {deck.cards.map(cardName => {
                          const card = uniqueCards.find(c => c.name === cardName);
                          const owned = collection.owned.includes(cardName);
                          return (
                            <span key={cardName} className={`text-xs px-2 py-1 rounded-full ${owned ? 'bg-gray-700 text-white' : 'bg-red-900 text-red-300'}`}>
                              {card?.cost || '?'}/{cardName}
                            </span>
                          );
                        })}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}

            {/* Delete Deck Confirmation Dialog */}
            <ConfirmDialog
              isOpen={!!deckToDelete}
              title="Delete Deck"
              message="Are you sure you want to delete this deck? This cannot be undone."
              confirmText="Delete"
              cancelText="Keep Deck"
              danger={true}
              onConfirm={confirmDeleteDeck}
              onCancel={() => setDeckToDelete(null)}
            />
          </div>
        );
      }

      // Import View
      if (view === 'import') {
        return (
          <div className="px-4 pb-20">
            <Header title="IMPORT DECK" />
            <button onClick={() => setView('list')} className="text-marvel-blue mb-4">&larr; Back to Decks</button>

            <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
              <h3 className="text-lg font-comic text-marvel-gold mb-3">Import from Deck Code</h3>
              <p className="text-gray-400 text-sm mb-2">Paste a base64 encoded deck code</p>
              <input type="text" placeholder="Paste deck code here..."
                value={importCode} onChange={(e) => setImportCode(e.target.value)}
                className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              <button onClick={importFromCode}
                className="w-full bg-marvel-red text-white py-2 rounded hover:opacity-80">
                Import from Code
              </button>
            </div>

            <div className="bg-gray-800 rounded-lg p-4 panel-border">
              <h3 className="text-lg font-comic text-marvel-gold mb-3">Import from URL</h3>
              <p className="text-gray-400 text-sm mb-2">Paste a MarvelSnapZone or Untapped.gg deck URL</p>
              <input type="text" placeholder="https://marvelsnapzone.com/decks/..."
                value={importUrl} onChange={(e) => setImportUrl(e.target.value)}
                className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              <button onClick={importFromUrl}
                className="w-full bg-series-3 text-white py-2 rounded hover:opacity-80">
                Import from URL
              </button>
            </div>

            {importError && (
              <div className="mt-4 bg-red-900 text-red-300 p-3 rounded-lg">{importError}</div>
            )}
          </div>
        );
      }

      // Create/Edit View
      return (
        <div className="px-4 pb-20">
          <Header title={editingDeck ? 'EDIT DECK' : 'CREATE DECK'} />
          <button onClick={() => setView('list')} className="text-marvel-blue mb-4">&larr; Back to Decks</button>

          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <input type="text" placeholder="Deck name..."
              value={deckName} onChange={(e) => setDeckName(e.target.value)}
              className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-3 border-2 border-gray-600 focus:border-marvel-red focus:outline-none text-lg font-comic" />
            <div className="flex justify-between items-center">
              <span className="text-gray-400">Cards: <span className={selectedCards.length === 12 ? 'text-green-500' : 'text-yellow-500'}>{selectedCards.length}/12</span></span>
              <button onClick={saveDeck} disabled={selectedCards.length !== 12 || !deckName.trim()}
                className="bg-marvel-red text-white px-4 py-2 rounded hover:opacity-80 disabled:opacity-50">
                Save Deck
              </button>
            </div>
          </div>

          {/* Selected Cards */}
          {selectedCards.length > 0 && (
            <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
              <h3 className="text-sm text-gray-400 mb-2">Selected Cards</h3>
              <div className="flex flex-wrap gap-1">
                {selectedCards.map(cardName => {
                  const card = uniqueCards.find(c => c.name === cardName);
                  return (
                    <button key={cardName} onClick={() => toggleCardInDeck(cardName)}
                      className="text-xs px-2 py-1 rounded-full bg-marvel-red text-white hover:bg-red-700">
                      {card?.cost || '?'}/{cardName} &times;
                    </button>
                  );
                })}
              </div>
              {selectedCards.length === 12 && (
                <div className="mt-3 pt-3 border-t border-gray-700">
                  <div className="flex gap-4 text-sm text-gray-400">
                    <span>Avg Cost: <span className="text-marvel-blue">{getDeckStats(selectedCards).avgCost}</span></span>
                    <span>Total Power: <span className="text-marvel-red">{getDeckStats(selectedCards).totalPower}</span></span>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Card Picker */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <div className="flex gap-2 mb-3">
              <input type="text" placeholder="Search cards..."
                value={searchCard} onChange={(e) => setSearchCard(e.target.value)}
                className="flex-1 bg-gray-700 text-white rounded px-3 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              <select value={seriesFilter} onChange={(e) => setSeriesFilter(e.target.value)}
                className="bg-gray-700 text-white rounded px-2 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none">
                <option value="all">All</option>
                <option value="1">S1</option>
                <option value="2">S2</option>
                <option value="3">S3</option>
                <option value="4">S4</option>
                <option value="5">S5</option>
              </select>
            </div>
            <div className="grid grid-cols-3 sm:grid-cols-4 gap-2 max-h-96 overflow-y-auto">
              {filteredCards.map(card => {
                const isSelected = selectedCards.includes(card.name);
                const isOwned = collection.owned.includes(card.name);
                return (
                  <button key={card.name} onClick={() => toggleCardInDeck(card.name)}
                    disabled={!isSelected && selectedCards.length >= 12}
                    className={`relative p-2 rounded-lg border-2 transition-all ${
                      isSelected ? 'border-marvel-red bg-gray-600' :
                      isOwned ? 'border-gray-600 bg-gray-700 hover:border-marvel-blue' :
                      'border-gray-700 bg-gray-800 opacity-60'
                    } disabled:opacity-30`}>
                    <div className="absolute top-0 left-0 w-4 h-4 bg-marvel-blue rounded-br flex items-center justify-center text-xs text-white">{card.cost}</div>
                    <div className="absolute top-0 right-0 w-4 h-4 bg-marvel-red rounded-bl flex items-center justify-center text-xs text-white">{card.power}</div>
                    <div className="mt-4 text-xs text-white text-center truncate">{card.name}</div>
                    {isSelected && (
                      <div className="absolute -top-1 -right-1 w-6 h-6 bg-green-500 rounded-full flex items-center justify-center">
                        <span className="text-white text-xs">✓</span>
                      </div>
                    )}
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      );
    };

    // Calculator Component
    const Calculator = () => {
      const [turn, setTurn] = useState(4);
      const [confidence, setConfidence] = useState(50);
      const [cardsToDraw, setCardsToDraw] = useState(1);
      const [copiesInDeck, setCopiesInDeck] = useState(1);

      const cardsSeen = Math.min(12, 3 + turn);

      const hypergeometric = (N, K, n) => {
        const factorial = (num) => { if (num <= 1) return 1; let r = 1; for (let i = 2; i <= num; i++) r *= i; return r; };
        const comb = (a, b) => { if (b > a) return 0; if (b === 0 || b === a) return 1; return factorial(a) / (factorial(b) * factorial(a - b)); };
        return 1 - (comb(N - K, n) / comb(N, n));
      };

      const drawProbability = hypergeometric(12, copiesInDeck, cardsToDraw) * 100;

      const getRecommendation = () => {
        const turnRiskFactor = turn <= 3 ? 0.9 : turn <= 5 ? 1.0 : 1.1;
        const adj = confidence / turnRiskFactor;
        if (adj >= 70) return { action: 'SNAP', bgColor: 'bg-green-600', animate: true };
        if (adj >= 45) return { action: 'HOLD', bgColor: 'bg-yellow-600', animate: false };
        return { action: 'RETREAT', bgColor: 'bg-red-600', animate: false };
      };
      const rec = getRecommendation();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAP CALCULATOR" />
          <div className={`${rec.bgColor} rounded-lg p-6 panel-border mb-4 text-center ${rec.animate ? 'pulse-snap' : ''}`}>
            <div className="text-4xl font-comic text-white mb-2">{rec.action}</div>
            <div className="text-white/80">
              {rec.action === 'SNAP' && 'The odds favor you. Make your move!'}
              {rec.action === 'HOLD' && 'Wait for more information.'}
              {rec.action === 'RETREAT' && 'Live to fight another match.'}
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Current Turn</span>
              <span className="text-marvel-gold font-bold text-xl">{turn}</span>
            </div>
            <input type="range" min="1" max="7" value={turn} onChange={(e) => setTurn(parseInt(e.target.value))} className="w-full" />
            <div className="text-center text-sm text-gray-400 mt-2">Cards seen: {cardsSeen}/12</div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Win Confidence</span>
              <span className={`font-bold text-xl ${confidence >= 70 ? 'text-green-400' : confidence >= 45 ? 'text-yellow-400' : 'text-red-400'}`}>{confidence}%</span>
            </div>
            <input type="range" min="0" max="100" value={confidence} onChange={(e) => setConfidence(parseInt(e.target.value))} className="w-full" />
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Draw Probability</h3>
            <div className="grid grid-cols-2 gap-3 mb-4">
              <div>
                <label htmlFor="cards-to-draw" className="text-sm text-gray-400">Cards to Draw</label>
                <input id="cards-to-draw" type="number" min="1" max="12" value={cardsToDraw}
                  onChange={(e) => setCardsToDraw(Math.max(1, Math.min(12, parseInt(e.target.value) || 1)))}
                  className="w-full bg-gray-700 text-white rounded px-3 py-2 mt-1 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              </div>
              <div>
                <label htmlFor="copies-in-deck" className="text-sm text-gray-400">Copies in Deck</label>
                <input id="copies-in-deck" type="number" min="1" max="4" value={copiesInDeck}
                  onChange={(e) => setCopiesInDeck(Math.max(1, Math.min(4, parseInt(e.target.value) || 1)))}
                  className="w-full bg-gray-700 text-white rounded px-3 py-2 mt-1 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              </div>
            </div>
            <div className="bg-gray-700 rounded-lg p-4 text-center">
              <div className="text-gray-400 text-sm mb-1">Probability of drawing at least 1:</div>
              <div className={`text-3xl font-comic ${drawProbability >= 70 ? 'text-green-400' : drawProbability >= 40 ? 'text-yellow-400' : 'text-red-400'}`}>
                {drawProbability.toFixed(1)}%
              </div>
            </div>
          </div>
        </div>
      );
    };

    // ==================== DECK SIMULATOR ====================
    // Simulation Engine - Pure math functions
    const SimulationEngine = {
      // Factorial with memoization for performance
      _factorialCache: [1, 1],
      factorial(n) {
        if (n < 0) return 0;
        if (n < this._factorialCache.length) return this._factorialCache[n];
        let result = this._factorialCache[this._factorialCache.length - 1];
        for (let i = this._factorialCache.length; i <= n; i++) {
          result *= i;
          this._factorialCache[i] = result;
        }
        return result;
      },

      // Combination C(n, k) = n! / (k! * (n-k)!)
      combination(n, k) {
        if (k < 0 || k > n) return 0;
        if (k === 0 || k === n) return 1;
        // Optimize for large numbers
        k = Math.min(k, n - k);
        let result = 1;
        for (let i = 0; i < k; i++) {
          result = result * (n - i) / (i + 1);
        }
        return Math.round(result);
      },

      // Hypergeometric probability: P(X >= 1) = 1 - P(X = 0)
      // N = population size (deck), K = success states (copies), n = draws
      hypergeometricAtLeastOne(N, K, n) {
        if (K <= 0 || n <= 0 || N <= 0) return 0;
        if (K >= N || n >= N) return 1;
        // P(X = 0) = C(K,0) * C(N-K, n) / C(N, n)
        const pZero = this.combination(N - K, n) / this.combination(N, n);
        return Math.max(0, Math.min(1, 1 - pZero));
      },

      // Probability of drawing ALL of k specific cards by drawing n cards
      // Uses inclusion-exclusion principle
      hypergeometricAllCards(N, targetCards, n) {
        const k = targetCards.length;
        if (k === 0) return 1;
        if (k > n) return 0;
        if (n >= N) return 1;

        // P(have all k cards in n draws) = C(N-k, n-k) / C(N, n)
        return this.combination(N - k, n - k) / this.combination(N, n);
      },

      // Opening hand probabilities for each card
      openingHandProbabilities(deckSize, handSize) {
        // P(specific card in hand) = 1 - C(deckSize-1, handSize) / C(deckSize, handSize)
        // Simplifies to: handSize / deckSize
        return handSize / deckSize;
      },

      // Probability of having specific card by turn T
      cardByTurnProbability(deckSize, handSize, turn) {
        const cardsSeen = Math.min(deckSize, handSize + turn);
        return cardsSeen / deckSize;
      }
    };

    // Seeded Random Number Generator (Mulberry32)
    const createSeededRNG = (seed) => {
      let state = seed;
      return () => {
        state |= 0;
        state = state + 0x6D2B79F5 | 0;
        let t = Math.imul(state ^ state >>> 15, 1 | state);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    };

    // Monte Carlo Simulation Runner (runs in main thread for small counts, worker for large)
    const MonteCarloEngine = {
      // Shuffle array using Fisher-Yates with provided RNG
      shuffle(array, rng) {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      },

      // Simulate single game and return results
      simulateGame(deck, options, rng) {
        const {
          handSize = 3,
          turnsToSimulate = 6,
          extraDrawsPerTurn = 0,
          thinningPerTurn = 0,
          junkInsertsPerTurn = 0,
          handSizeLimit = Infinity
        } = options;

        let currentDeck = this.shuffle([...deck], rng);
        let hand = currentDeck.splice(0, handSize);
        const drawnCards = [...hand];
        const handByTurn = [{ turn: 0, hand: [...hand], deckSize: currentDeck.length }];

        for (let turn = 1; turn <= turnsToSimulate; turn++) {
          // Apply thinning (remove cards from deck)
          for (let i = 0; i < thinningPerTurn && currentDeck.length > 0; i++) {
            const idx = Math.floor(rng() * currentDeck.length);
            currentDeck.splice(idx, 1);
          }

          // Apply junk inserts
          for (let i = 0; i < junkInsertsPerTurn; i++) {
            currentDeck.push({ name: `Junk_${turn}_${i}`, cost: 99, power: 0, isJunk: true });
          }

          // Draw cards
          const drawCount = 1 + extraDrawsPerTurn;
          for (let i = 0; i < drawCount && currentDeck.length > 0; i++) {
            const card = currentDeck.shift();
            hand.push(card);
            drawnCards.push(card);
          }

          // Apply hand size limit
          while (hand.length > handSizeLimit && hand.length > 0) {
            const idx = Math.floor(rng() * hand.length);
            hand.splice(idx, 1);
          }

          handByTurn.push({ turn, hand: [...hand], deckSize: currentDeck.length });
        }

        return { hand, drawnCards, handByTurn };
      },

      // Run Monte Carlo simulation
      runSimulation(deck, options, numRuns, onProgress, seed = null) {
        const results = {
          openingHands: {},
          cardByTurn: {},
          curveAnalysis: [],
          comboResults: {},
          sampleHands: []
        };

        const rng = seed !== null ? createSeededRNG(seed) : Math.random;
        const comboCards = options.comboCards || [];
        const deckCardNames = deck.map(c => c.name);

        // Initialize tracking
        deckCardNames.forEach(name => {
          results.openingHands[name] = 0;
          results.cardByTurn[name] = Array(7).fill(0);
        });

        for (let turn = 1; turn <= 6; turn++) {
          results.curveAnalysis.push({
            turn,
            onCurvePlays: 0,
            brickCount: 0,
            totalPlayableEnergy: 0
          });
        }

        if (comboCards.length > 0) {
          for (let turn = 1; turn <= 6; turn++) {
            results.comboResults[turn] = 0;
          }
        }

        // Run simulations
        for (let i = 0; i < numRuns; i++) {
          const simRng = seed !== null ? createSeededRNG(seed + i) : () => Math.random();
          const { handByTurn } = this.simulateGame(deck, options, simRng);

          // Opening hand analysis
          const openingHand = handByTurn[0].hand;
          openingHand.forEach(card => {
            if (results.openingHands[card.name] !== undefined) {
              results.openingHands[card.name]++;
            }
          });

          // Store sample hands (first 10 runs)
          if (i < 10) {
            results.sampleHands.push(openingHand.map(c => c.name));
          }

          // Card by turn analysis
          const seenCards = new Set();
          handByTurn.forEach(({ turn, hand }) => {
            hand.forEach(card => {
              if (!seenCards.has(card.name) && results.cardByTurn[card.name]) {
                seenCards.add(card.name);
                for (let t = turn; t <= 6; t++) {
                  results.cardByTurn[card.name][t]++;
                }
              }
            });
          });

          // Curve analysis
          handByTurn.slice(1).forEach(({ turn, hand }) => {
            const analysis = results.curveAnalysis[turn - 1];
            const playableCosts = hand.filter(c => !c.isJunk && c.cost <= turn).map(c => c.cost);

            if (playableCosts.length > 0) {
              analysis.onCurvePlays++;
              analysis.totalPlayableEnergy += Math.max(...playableCosts);
            } else {
              analysis.brickCount++;
            }
          });

          // Combo analysis
          if (comboCards.length > 0) {
            handByTurn.slice(1).forEach(({ turn, hand }) => {
              const handNames = new Set(hand.map(c => c.name));
              if (comboCards.every(name => handNames.has(name))) {
                results.comboResults[turn]++;
              }
            });
          }

          // Progress callback
          if (onProgress && i % Math.max(1, Math.floor(numRuns / 100)) === 0) {
            onProgress(i / numRuns);
          }
        }

        // Convert counts to percentages
        Object.keys(results.openingHands).forEach(name => {
          results.openingHands[name] = (results.openingHands[name] / numRuns) * 100;
        });

        Object.keys(results.cardByTurn).forEach(name => {
          results.cardByTurn[name] = results.cardByTurn[name].map(count => (count / numRuns) * 100);
        });

        results.curveAnalysis = results.curveAnalysis.map(a => ({
          ...a,
          onCurveRate: (a.onCurvePlays / numRuns) * 100,
          brickRate: (a.brickCount / numRuns) * 100,
          avgPlayableEnergy: a.totalPlayableEnergy / numRuns
        }));

        if (comboCards.length > 0) {
          Object.keys(results.comboResults).forEach(turn => {
            results.comboResults[turn] = (results.comboResults[turn] / numRuns) * 100;
          });
        }

        return results;
      }
    };

    // Web Worker code as string for inline Blob worker
    const workerCode = `
      // Seeded RNG (Mulberry32)
      const createSeededRNG = (seed) => {
        let state = seed;
        return () => {
          state |= 0;
          state = state + 0x6D2B79F5 | 0;
          let t = Math.imul(state ^ state >>> 15, 1 | state);
          t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
      };

      const shuffle = (array, rng) => {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      };

      const simulateGame = (deck, options, rng) => {
        const { handSize = 3, turnsToSimulate = 6, extraDrawsPerTurn = 0, thinningPerTurn = 0, junkInsertsPerTurn = 0, handSizeLimit = Infinity } = options;
        let currentDeck = shuffle([...deck], rng);
        let hand = currentDeck.splice(0, handSize);
        const handByTurn = [{ turn: 0, hand: [...hand], deckSize: currentDeck.length }];

        for (let turn = 1; turn <= turnsToSimulate; turn++) {
          for (let i = 0; i < thinningPerTurn && currentDeck.length > 0; i++) {
            currentDeck.splice(Math.floor(rng() * currentDeck.length), 1);
          }
          for (let i = 0; i < junkInsertsPerTurn; i++) {
            currentDeck.push({ name: 'Junk_' + turn + '_' + i, cost: 99, power: 0, isJunk: true });
          }
          const drawCount = 1 + extraDrawsPerTurn;
          for (let i = 0; i < drawCount && currentDeck.length > 0; i++) {
            hand.push(currentDeck.shift());
          }
          while (hand.length > handSizeLimit && hand.length > 0) {
            hand.splice(Math.floor(rng() * hand.length), 1);
          }
          handByTurn.push({ turn, hand: [...hand], deckSize: currentDeck.length });
        }
        return { hand, handByTurn };
      };

      self.onmessage = function(e) {
        const { deck, options, numRuns, seed, chunkSize = 1000 } = e.data;
        const results = {
          openingHands: {},
          cardByTurn: {},
          curveAnalysis: [],
          comboResults: {},
          sampleHands: []
        };

        const comboCards = options.comboCards || [];
        const deckCardNames = deck.map(c => c.name);

        deckCardNames.forEach(name => {
          results.openingHands[name] = 0;
          results.cardByTurn[name] = Array(7).fill(0);
        });

        for (let turn = 1; turn <= 6; turn++) {
          results.curveAnalysis.push({ turn, onCurvePlays: 0, brickCount: 0, totalPlayableEnergy: 0 });
        }

        if (comboCards.length > 0) {
          for (let turn = 1; turn <= 6; turn++) results.comboResults[turn] = 0;
        }

        let completed = 0;
        const runChunk = () => {
          const chunkEnd = Math.min(completed + chunkSize, numRuns);

          for (let i = completed; i < chunkEnd; i++) {
            const simRng = seed !== null ? createSeededRNG(seed + i) : () => Math.random();
            const { handByTurn } = simulateGame(deck, options, simRng);

            const openingHand = handByTurn[0].hand;
            openingHand.forEach(card => {
              if (results.openingHands[card.name] !== undefined) results.openingHands[card.name]++;
            });

            if (i < 10) results.sampleHands.push(openingHand.map(c => c.name));

            const seenCards = new Set();
            handByTurn.forEach(({ turn, hand }) => {
              hand.forEach(card => {
                if (!seenCards.has(card.name) && results.cardByTurn[card.name]) {
                  seenCards.add(card.name);
                  for (let t = turn; t <= 6; t++) results.cardByTurn[card.name][t]++;
                }
              });
            });

            handByTurn.slice(1).forEach(({ turn, hand }) => {
              const analysis = results.curveAnalysis[turn - 1];
              const playableCosts = hand.filter(c => !c.isJunk && c.cost <= turn).map(c => c.cost);
              if (playableCosts.length > 0) {
                analysis.onCurvePlays++;
                analysis.totalPlayableEnergy += Math.max(...playableCosts);
              } else {
                analysis.brickCount++;
              }
            });

            if (comboCards.length > 0) {
              handByTurn.slice(1).forEach(({ turn, hand }) => {
                const handNames = new Set(hand.map(c => c.name));
                if (comboCards.every(name => handNames.has(name))) results.comboResults[turn]++;
              });
            }
          }

          completed = chunkEnd;
          self.postMessage({ type: 'progress', progress: completed / numRuns });

          if (completed < numRuns) {
            setTimeout(runChunk, 0);
          } else {
            // Finalize results
            Object.keys(results.openingHands).forEach(name => {
              results.openingHands[name] = (results.openingHands[name] / numRuns) * 100;
            });
            Object.keys(results.cardByTurn).forEach(name => {
              results.cardByTurn[name] = results.cardByTurn[name].map(count => (count / numRuns) * 100);
            });
            results.curveAnalysis = results.curveAnalysis.map(a => ({
              ...a,
              onCurveRate: (a.onCurvePlays / numRuns) * 100,
              brickRate: (a.brickCount / numRuns) * 100,
              avgPlayableEnergy: a.totalPlayableEnergy / numRuns
            }));
            if (comboCards.length > 0) {
              Object.keys(results.comboResults).forEach(turn => {
                results.comboResults[turn] = (results.comboResults[turn] / numRuns) * 100;
              });
            }
            self.postMessage({ type: 'complete', results });
          }
        };

        runChunk();
      };
    `;

    // Create Web Worker from Blob
    const createSimulationWorker = () => {
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    };

    // Simulator Component
    const Simulator = ({ decks, collection }) => {
      const [selectedDeckId, setSelectedDeckId] = useState(() => {
        const saved = localStorage.getItem('snap_simulator_deck');
        return saved || (decks.length > 0 ? decks[0].id : '');
      });
      const [mode, setMode] = useState('opening');
      const [numRuns, setNumRuns] = useState(10000);
      const [isRunning, setIsRunning] = useState(false);
      const [progress, setProgress] = useState(0);
      const [results, setResults] = useState(null);
      const [useSeed, setUseSeed] = useState(false);
      const [seed, setSeed] = useState(12345);
      const [comboCards, setComboCards] = useState([]);
      const [showAdvanced, setShowAdvanced] = useState(false);
      const [advancedOptions, setAdvancedOptions] = useState({
        handSize: 3,
        deckSizeOverride: 12,
        extraDrawsPerTurn: 0,
        thinningPerTurn: 0,
        junkInsertsPerTurn: 0,
        handSizeLimit: 0
      });

      // Interactive play-through state
      const [playState, setPlayState] = useState(null);
      const [playHistory, setPlayHistory] = useState([]);

      const workerRef = useRef(null);

      const selectedDeck = decks.find(d => d.id === selectedDeckId);
      const deckCards = selectedDeck ? selectedDeck.cards.map(name => {
        const card = uniqueCards.find(c => c.name === name);
        return card || { name, cost: 0, power: 0, series: 0 };
      }) : [];

      const isAdvancedModified = advancedOptions.handSize !== 3 ||
        advancedOptions.extraDrawsPerTurn !== 0 ||
        advancedOptions.thinningPerTurn !== 0 ||
        advancedOptions.junkInsertsPerTurn !== 0 ||
        advancedOptions.handSizeLimit !== 0;

      // Save deck selection to localStorage
      useEffect(() => {
        if (selectedDeckId) {
          localStorage.setItem('snap_simulator_deck', selectedDeckId);
        }
      }, [selectedDeckId]);

      // Save simulator settings
      useEffect(() => {
        localStorage.setItem('snap_simulator_settings', JSON.stringify({
          numRuns, useSeed, seed, advancedOptions
        }));
      }, [numRuns, useSeed, seed, advancedOptions]);

      // Load saved settings
      useEffect(() => {
        try {
          const saved = JSON.parse(localStorage.getItem('snap_simulator_settings') || '{}');
          if (saved.numRuns) setNumRuns(saved.numRuns);
          if (saved.useSeed !== undefined) setUseSeed(saved.useSeed);
          if (saved.seed) setSeed(saved.seed);
          if (saved.advancedOptions) setAdvancedOptions(prev => ({ ...prev, ...saved.advancedOptions }));
        } catch (e) {}
      }, []);

      // Cleanup worker on unmount
      useEffect(() => {
        return () => {
          if (workerRef.current) {
            workerRef.current.terminate();
          }
        };
      }, []);

      const runSimulation = useCallback(() => {
        if (!selectedDeck || deckCards.length !== 12) {
          alert('Please select a valid 12-card deck');
          return;
        }

        setIsRunning(true);
        setProgress(0);
        setResults(null);

        const options = {
          handSize: advancedOptions.handSize,
          turnsToSimulate: 6,
          extraDrawsPerTurn: advancedOptions.extraDrawsPerTurn,
          thinningPerTurn: advancedOptions.thinningPerTurn,
          junkInsertsPerTurn: advancedOptions.junkInsertsPerTurn,
          handSizeLimit: advancedOptions.handSizeLimit || Infinity,
          comboCards
        };

        // Use worker for large simulations
        if (numRuns >= 5000) {
          if (workerRef.current) {
            workerRef.current.terminate();
          }

          const worker = createSimulationWorker();
          workerRef.current = worker;

          worker.onmessage = (e) => {
            if (e.data.type === 'progress') {
              setProgress(e.data.progress);
            } else if (e.data.type === 'complete') {
              setResults(e.data.results);
              setIsRunning(false);
              setProgress(1);
              worker.terminate();
              workerRef.current = null;
            }
          };

          worker.onerror = (err) => {
            console.error('Worker error:', err);
            setIsRunning(false);
            worker.terminate();
            workerRef.current = null;
          };

          worker.postMessage({
            deck: deckCards,
            options,
            numRuns,
            seed: useSeed ? seed : null,
            chunkSize: Math.min(1000, Math.ceil(numRuns / 100))
          });
        } else {
          // Small runs - use main thread with RAF chunking
          requestAnimationFrame(() => {
            const results = MonteCarloEngine.runSimulation(
              deckCards,
              options,
              numRuns,
              (p) => setProgress(p),
              useSeed ? seed : null
            );
            setResults(results);
            setIsRunning(false);
            setProgress(1);
          });
        }
      }, [selectedDeck, deckCards, numRuns, useSeed, seed, advancedOptions, comboCards]);

      const cancelSimulation = () => {
        if (workerRef.current) {
          workerRef.current.terminate();
          workerRef.current = null;
        }
        setIsRunning(false);
        setProgress(0);
      };

      // Interactive play-through functions
      const startNewGame = () => {
        if (!selectedDeck || deckCards.length !== 12) return;

        const rng = useSeed ? createSeededRNG(seed) : () => Math.random();
        const shuffledDeck = MonteCarloEngine.shuffle([...deckCards], rng);
        const hand = shuffledDeck.splice(0, advancedOptions.handSize);

        const state = {
          turn: 0,
          hand,
          deck: shuffledDeck,
          drawnThisTurn: [...hand]
        };

        setPlayState(state);
        setPlayHistory([{ ...state, action: 'start' }]);
      };

      const drawNext = () => {
        if (!playState || playState.deck.length === 0 || playState.turn >= 6) return;

        const newDeck = [...playState.deck];
        const newHand = [...playState.hand];
        const drawCount = 1 + advancedOptions.extraDrawsPerTurn;
        const drawnCards = [];

        for (let i = 0; i < drawCount && newDeck.length > 0; i++) {
          const card = newDeck.shift();
          newHand.push(card);
          drawnCards.push(card);
        }

        const newState = {
          turn: playState.turn + 1,
          hand: newHand,
          deck: newDeck,
          drawnThisTurn: drawnCards
        };

        setPlayState(newState);
        setPlayHistory(prev => [...prev, { ...newState, action: 'draw' }]);
      };

      const undoAction = () => {
        if (playHistory.length <= 1) return;
        const newHistory = playHistory.slice(0, -1);
        setPlayHistory(newHistory);
        setPlayState(newHistory[newHistory.length - 1]);
      };

      const autoPlay = async () => {
        if (!playState) return;

        let currentState = playState;
        while (currentState.turn < 6 && currentState.deck.length > 0) {
          await new Promise(r => setTimeout(r, 500));
          drawNext();
          currentState = { ...currentState, turn: currentState.turn + 1 };
        }
      };

      const toggleComboCard = (cardName) => {
        setComboCards(prev =>
          prev.includes(cardName)
            ? prev.filter(c => c !== cardName)
            : [...prev, cardName]
        );
      };

      // Exact math results for comparison
      const exactResults = useMemo(() => {
        if (!selectedDeck || deckCards.length !== 12) return null;

        const deckSize = 12;
        const handSize = advancedOptions.handSize;

        const openingHandProb = SimulationEngine.openingHandProbabilities(deckSize, handSize) * 100;

        const cardByTurn = {};
        deckCards.forEach(card => {
          cardByTurn[card.name] = [];
          for (let turn = 0; turn <= 6; turn++) {
            const cardsSeen = Math.min(deckSize, handSize + turn);
            cardByTurn[card.name].push((cardsSeen / deckSize) * 100);
          }
        });

        const comboByTurn = {};
        if (comboCards.length >= 2) {
          for (let turn = 1; turn <= 6; turn++) {
            const cardsSeen = Math.min(deckSize, handSize + turn);
            comboByTurn[turn] = SimulationEngine.hypergeometricAllCards(deckSize, comboCards, cardsSeen) * 100;
          }
        }

        return { openingHandProb, cardByTurn, comboByTurn };
      }, [selectedDeck, deckCards, advancedOptions.handSize, comboCards]);

      // Progress bar component
      const ProgressBar = ({ value }) => (
        <div className="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
          <div
            className="bg-marvel-red h-full transition-all duration-200 ease-out"
            style={{ width: `${value * 100}%` }}
          />
        </div>
      );

      // Percentage bar component
      const PercentBar = ({ value, color = 'bg-marvel-blue', label }) => (
        <div className="flex items-center gap-2">
          <div className="flex-1 bg-gray-700 rounded h-4 overflow-hidden">
            <div className={`${color} h-full`} style={{ width: `${Math.min(100, value)}%` }} />
          </div>
          <span className="text-white text-sm w-16 text-right">{value.toFixed(1)}%</span>
          {label && <span className="text-gray-400 text-xs">{label}</span>}
        </div>
      );

      return (
        <div className="px-4 pb-20">
          <Header title="DECK SIMULATOR" />

          {/* Deck Selector */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <label className="block text-sm text-gray-400 mb-2">Select Deck</label>
            {decks.length === 0 ? (
              <div className="text-center text-gray-400 py-4">
                <p className="mb-2">No decks created yet</p>
                <p className="text-sm">Go to Decks tab to create a 12-card deck</p>
              </div>
            ) : (
              <select
                value={selectedDeckId}
                onChange={(e) => setSelectedDeckId(e.target.value)}
                className="w-full bg-gray-700 text-white rounded px-3 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none"
              >
                <option value="">Select a deck...</option>
                {decks.map(deck => (
                  <option key={deck.id} value={deck.id}>{deck.name} ({deck.cards.length} cards)</option>
                ))}
              </select>
            )}

            {selectedDeck && (
              <div className="mt-3 flex flex-wrap gap-1">
                {selectedDeck.cards.map(cardName => {
                  const card = uniqueCards.find(c => c.name === cardName);
                  const owned = collection.owned.includes(cardName);
                  return (
                    <span
                      key={cardName}
                      className={`text-xs px-2 py-1 rounded-full ${owned ? 'bg-gray-700 text-white' : 'bg-red-900 text-red-300'}`}
                    >
                      {card?.cost || '?'}/{cardName}
                    </span>
                  );
                })}
              </div>
            )}
          </div>

          {/* Mode Selector */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <label className="block text-sm text-gray-400 mb-2">Simulation Mode</label>
            <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
              {[
                { id: 'opening', label: 'Opening Hand', icon: '🃏' },
                { id: 'draw', label: 'Draw by Turn', icon: '📊' },
                { id: 'curve', label: 'Curve Analysis', icon: '📈' },
                { id: 'combo', label: 'Combo Finder', icon: '🎯' },
                { id: 'play', label: 'Play Through', icon: '🎮' },
                { id: 'advanced', label: 'All Results', icon: '⚙️' }
              ].map(m => (
                <button
                  key={m.id}
                  onClick={() => setMode(m.id)}
                  className={`p-3 rounded-lg text-sm font-medium transition-colors ${
                    mode === m.id
                      ? 'bg-marvel-red text-white'
                      : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                  }`}
                >
                  <span className="block text-lg mb-1">{m.icon}</span>
                  {m.label}
                </button>
              ))}
            </div>
          </div>

          {/* Run Controls (not for play-through mode) */}
          {mode !== 'play' && (
            <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
              <div className="flex gap-2 mb-3">
                <button
                  onClick={() => setNumRuns(1000)}
                  className={`px-3 py-1 rounded text-sm ${numRuns === 1000 ? 'bg-marvel-blue text-white' : 'bg-gray-700 text-gray-300'}`}
                >1K</button>
                <button
                  onClick={() => setNumRuns(10000)}
                  className={`px-3 py-1 rounded text-sm ${numRuns === 10000 ? 'bg-marvel-blue text-white' : 'bg-gray-700 text-gray-300'}`}
                >10K</button>
                <button
                  onClick={() => setNumRuns(50000)}
                  className={`px-3 py-1 rounded text-sm ${numRuns === 50000 ? 'bg-marvel-blue text-white' : 'bg-gray-700 text-gray-300'}`}
                >50K</button>
                <input
                  type="number"
                  value={numRuns}
                  onChange={(e) => setNumRuns(Math.max(100, Math.min(200000, parseInt(e.target.value) || 1000)))}
                  className="flex-1 bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600"
                  placeholder="Custom"
                />
              </div>

              <div className="flex items-center gap-3 mb-3">
                <label className="flex items-center gap-2 text-sm text-gray-300">
                  <input
                    type="checkbox"
                    checked={useSeed}
                    onChange={(e) => setUseSeed(e.target.checked)}
                    className="w-4 h-4 accent-marvel-red"
                  />
                  Use seed for reproducibility
                </label>
                {useSeed && (
                  <input
                    type="number"
                    value={seed}
                    onChange={(e) => setSeed(parseInt(e.target.value) || 0)}
                    className="w-24 bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600"
                  />
                )}
              </div>

              {isRunning ? (
                <div className="space-y-2">
                  <ProgressBar value={progress} />
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-gray-400">{Math.round(progress * 100)}% complete</span>
                    <button
                      onClick={cancelSimulation}
                      className="px-4 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              ) : (
                <button
                  onClick={runSimulation}
                  disabled={!selectedDeck || deckCards.length !== 12}
                  className="w-full bg-marvel-red text-white py-3 rounded-lg font-comic hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  ▶ RUN SIMULATION ({numRuns.toLocaleString()} runs)
                </button>
              )}
            </div>
          )}

          {/* Advanced Rules Panel */}
          <div className="bg-gray-800 rounded-lg panel-border mb-4 overflow-hidden">
            <button
              onClick={() => setShowAdvanced(!showAdvanced)}
              className="w-full p-4 flex justify-between items-center text-left"
            >
              <span className="text-white font-medium">
                Advanced Rules {isAdvancedModified && <span className="text-marvel-gold text-xs ml-2">(Modified)</span>}
              </span>
              <span className="text-gray-400">{showAdvanced ? '▲' : '▼'}</span>
            </button>

            {showAdvanced && (
              <div className="px-4 pb-4 space-y-3 border-t border-gray-700 pt-3">
                {isAdvancedModified && (
                  <div className="bg-yellow-900/30 border border-yellow-600 rounded p-2 text-xs text-yellow-300">
                    ⚠️ Advanced rules active - Exact math disabled, Monte Carlo only
                  </div>
                )}

                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="block text-xs text-gray-400 mb-1">Starting Hand Size</label>
                    <input
                      type="number"
                      value={advancedOptions.handSize}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, handSize: Math.max(1, Math.min(12, parseInt(e.target.value) || 3)) }))}
                      className="w-full bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-400 mb-1">Extra Draws/Turn</label>
                    <input
                      type="number"
                      value={advancedOptions.extraDrawsPerTurn}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, extraDrawsPerTurn: Math.max(0, Math.min(5, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-400 mb-1">Thinning/Turn</label>
                    <input
                      type="number"
                      value={advancedOptions.thinningPerTurn}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, thinningPerTurn: Math.max(0, Math.min(5, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-400 mb-1">Junk Inserts/Turn</label>
                    <input
                      type="number"
                      value={advancedOptions.junkInsertsPerTurn}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, junkInsertsPerTurn: Math.max(0, Math.min(5, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600"
                    />
                  </div>
                  <div className="col-span-2">
                    <label className="block text-xs text-gray-400 mb-1">Hand Size Limit (0 = unlimited)</label>
                    <input
                      type="number"
                      value={advancedOptions.handSizeLimit}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, handSizeLimit: Math.max(0, Math.min(20, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600"
                    />
                  </div>
                </div>

                <button
                  onClick={() => setAdvancedOptions({ handSize: 3, deckSizeOverride: 12, extraDrawsPerTurn: 0, thinningPerTurn: 0, junkInsertsPerTurn: 0, handSizeLimit: 0 })}
                  className="text-sm text-marvel-blue hover:underline"
                >
                  Reset to defaults
                </button>
              </div>
            )}
          </div>

          {/* Combo Card Selector (for combo mode) */}
          {mode === 'combo' && selectedDeck && (
            <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
              <label className="block text-sm text-gray-400 mb-2">Select Combo Pieces (click cards)</label>
              <div className="flex flex-wrap gap-1 mb-3">
                {selectedDeck.cards.map(cardName => {
                  const isSelected = comboCards.includes(cardName);
                  const card = uniqueCards.find(c => c.name === cardName);
                  return (
                    <button
                      key={cardName}
                      onClick={() => toggleComboCard(cardName)}
                      className={`text-xs px-2 py-1 rounded-full transition-colors ${
                        isSelected
                          ? 'bg-marvel-gold text-black font-medium'
                          : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                      }`}
                    >
                      {card?.cost || '?'}/{cardName}
                    </button>
                  );
                })}
              </div>
              {comboCards.length < 2 && (
                <p className="text-sm text-gray-400">Select at least 2 cards to analyze combo probability</p>
              )}
              {comboCards.length >= 2 && (
                <p className="text-sm text-marvel-gold">Combo: {comboCards.join(' + ')}</p>
              )}
            </div>
          )}

          {/* Results Display */}
          {results && mode !== 'play' && (
            <div className="space-y-4">
              {/* Opening Hand Results */}
              {(mode === 'opening' || mode === 'advanced') && (
                <div className="bg-gray-800 rounded-lg p-4 panel-border">
                  <h3 className="text-lg font-comic text-marvel-gold mb-3">Opening Hand Probability</h3>
                  <p className="text-xs text-gray-400 mb-3">Chance of each card in starting hand ({advancedOptions.handSize} cards)</p>

                  {!isAdvancedModified && exactResults && (
                    <div className="mb-3 p-2 bg-gray-700 rounded text-xs text-gray-300">
                      <span className="text-marvel-blue">Exact math:</span> {exactResults.openingHandProb.toFixed(1)}% per card
                    </div>
                  )}

                  <div className="space-y-2">
                    {Object.entries(results.openingHands)
                      .sort((a, b) => b[1] - a[1])
                      .map(([name, prob]) => (
                        <div key={name}>
                          <div className="flex justify-between text-sm mb-1">
                            <span className="text-white">{name}</span>
                            <span className="text-gray-400">{prob.toFixed(1)}%</span>
                          </div>
                          <PercentBar value={prob} />
                        </div>
                      ))}
                  </div>

                  {results.sampleHands.length > 0 && (
                    <div className="mt-4 pt-4 border-t border-gray-700">
                      <h4 className="text-sm text-gray-400 mb-2">Sample Opening Hands</h4>
                      <div className="space-y-1 max-h-40 overflow-y-auto">
                        {results.sampleHands.slice(0, 5).map((hand, i) => (
                          <div key={i} className="flex gap-1 flex-wrap">
                            <span className="text-xs text-gray-500 w-6">#{i+1}</span>
                            {hand.map((name, j) => (
                              <span key={j} className="text-xs px-2 py-0.5 bg-gray-700 rounded text-white">{name}</span>
                            ))}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}

              {/* Draw by Turn Results */}
              {(mode === 'draw' || mode === 'advanced') && (
                <div className="bg-gray-800 rounded-lg p-4 panel-border">
                  <h3 className="text-lg font-comic text-marvel-gold mb-3">Draw by Turn Probability</h3>
                  <p className="text-xs text-gray-400 mb-3">Chance of having each card by end of turn</p>

                  <div className="overflow-x-auto">
                    <table className="w-full text-sm">
                      <thead>
                        <tr className="text-gray-400">
                          <th className="text-left py-1">Card</th>
                          {[1,2,3,4,5,6].map(t => (
                            <th key={t} className="text-center py-1 w-12">T{t}</th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {Object.entries(results.cardByTurn).map(([name, turns]) => (
                          <tr key={name} className="border-t border-gray-700">
                            <td className="py-1 text-white text-xs">{name}</td>
                            {turns.slice(1).map((prob, i) => (
                              <td key={i} className={`text-center py-1 ${prob >= 70 ? 'text-green-400' : prob >= 40 ? 'text-yellow-400' : 'text-gray-400'}`}>
                                {prob.toFixed(0)}%
                              </td>
                            ))}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {/* Curve Analysis Results */}
              {(mode === 'curve' || mode === 'advanced') && (
                <div className="bg-gray-800 rounded-lg p-4 panel-border">
                  <h3 className="text-lg font-comic text-marvel-gold mb-3">Curve / Brick Analysis</h3>
                  <p className="text-xs text-gray-400 mb-3">On-curve = have at least one playable card that turn</p>

                  <div className="space-y-3">
                    {results.curveAnalysis.map(({ turn, onCurveRate, brickRate, avgPlayableEnergy }) => (
                      <div key={turn}>
                        <div className="flex justify-between text-sm mb-1">
                          <span className="text-white">Turn {turn}</span>
                          <span className="text-gray-400">
                            <span className={onCurveRate >= 90 ? 'text-green-400' : onCurveRate >= 70 ? 'text-yellow-400' : 'text-red-400'}>
                              {onCurveRate.toFixed(1)}% playable
                            </span>
                            <span className="mx-2">|</span>
                            <span className={brickRate <= 5 ? 'text-green-400' : brickRate <= 15 ? 'text-yellow-400' : 'text-red-400'}>
                              {brickRate.toFixed(1)}% brick
                            </span>
                          </span>
                        </div>
                        <div className="flex gap-1 h-4">
                          <div className="bg-green-600 h-full rounded-l" style={{ width: `${onCurveRate}%` }} />
                          <div className="bg-red-600 h-full rounded-r" style={{ width: `${brickRate}%` }} />
                        </div>
                        <div className="text-xs text-gray-500 mt-0.5">
                          Avg playable cost: {avgPlayableEnergy.toFixed(1)} energy
                        </div>
                      </div>
                    ))}
                  </div>

                  <div className="mt-4 pt-4 border-t border-gray-700 grid grid-cols-2 gap-4">
                    <div className="text-center">
                      <div className="text-2xl font-bold text-green-400">
                        {(results.curveAnalysis.reduce((sum, a) => sum + a.onCurveRate, 0) / 6).toFixed(1)}%
                      </div>
                      <div className="text-xs text-gray-400">Avg On-Curve Rate</div>
                    </div>
                    <div className="text-center">
                      <div className="text-2xl font-bold text-red-400">
                        {(results.curveAnalysis.reduce((sum, a) => sum + a.brickRate, 0) / 6).toFixed(1)}%
                      </div>
                      <div className="text-xs text-gray-400">Avg Brick Rate</div>
                    </div>
                  </div>
                </div>
              )}

              {/* Combo Results */}
              {(mode === 'combo' || mode === 'advanced') && comboCards.length >= 2 && (
                <div className="bg-gray-800 rounded-lg p-4 panel-border">
                  <h3 className="text-lg font-comic text-marvel-gold mb-3">Combo Finder Results</h3>
                  <p className="text-xs text-gray-400 mb-3">Chance of having ALL pieces: {comboCards.join(' + ')}</p>

                  <div className="space-y-2">
                    {Object.entries(results.comboResults).map(([turn, prob]) => (
                      <div key={turn}>
                        <div className="flex justify-between text-sm mb-1">
                          <span className="text-white">By Turn {turn}</span>
                          <div className="text-right">
                            <span className={prob >= 50 ? 'text-green-400' : prob >= 25 ? 'text-yellow-400' : 'text-red-400'}>
                              {prob.toFixed(1)}%
                            </span>
                            {!isAdvancedModified && exactResults?.comboByTurn?.[turn] && (
                              <span className="text-xs text-gray-500 ml-2">(exact: {exactResults.comboByTurn[turn].toFixed(1)}%)</span>
                            )}
                          </div>
                        </div>
                        <PercentBar
                          value={prob}
                          color={prob >= 50 ? 'bg-green-600' : prob >= 25 ? 'bg-yellow-600' : 'bg-red-600'}
                        />
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Interactive Play-Through Mode */}
          {mode === 'play' && (
            <div className="space-y-4">
              <div className="bg-gray-800 rounded-lg p-4 panel-border">
                <div className="flex gap-2 mb-4">
                  <button
                    onClick={startNewGame}
                    disabled={!selectedDeck}
                    className="flex-1 bg-marvel-red text-white py-2 rounded font-medium hover:opacity-90 disabled:opacity-50"
                  >
                    New Game
                  </button>
                  <button
                    onClick={drawNext}
                    disabled={!playState || playState.turn >= 6 || playState.deck.length === 0}
                    className="flex-1 bg-marvel-blue text-white py-2 rounded font-medium hover:opacity-90 disabled:opacity-50"
                  >
                    Draw Next
                  </button>
                  <button
                    onClick={undoAction}
                    disabled={playHistory.length <= 1}
                    className="px-4 bg-gray-600 text-white py-2 rounded font-medium hover:opacity-90 disabled:opacity-50"
                  >
                    Undo
                  </button>
                </div>

                {playState && (
                  <>
                    <div className="flex justify-between text-sm text-gray-400 mb-3">
                      <span>Turn: <span className="text-white font-bold">{playState.turn}</span></span>
                      <span>Deck: <span className="text-white">{playState.deck.length} cards</span></span>
                    </div>

                    <div className="mb-4">
                      <h4 className="text-sm text-gray-400 mb-2">Your Hand ({playState.hand.length} cards)</h4>
                      <div className="flex flex-wrap gap-2">
                        {playState.hand.map((card, i) => (
                          <div
                            key={i}
                            className={`relative p-2 rounded-lg border-2 bg-gray-700 min-w-16 ${
                              playState.drawnThisTurn.includes(card) && playState.turn > 0
                                ? 'border-marvel-gold'
                                : 'border-gray-600'
                            }`}
                          >
                            <div className="absolute top-0 left-0 w-5 h-5 bg-marvel-blue rounded-br flex items-center justify-center text-xs text-white font-bold">
                              {card.cost}
                            </div>
                            <div className="absolute top-0 right-0 w-5 h-5 bg-marvel-red rounded-bl flex items-center justify-center text-xs text-white font-bold">
                              {card.power}
                            </div>
                            <div className="mt-5 text-xs text-white text-center">{card.name}</div>
                          </div>
                        ))}
                      </div>
                    </div>

                    {playState.turn > 0 && playState.drawnThisTurn.length > 0 && (
                      <div className="text-sm text-marvel-gold">
                        Drew this turn: {playState.drawnThisTurn.map(c => c.name).join(', ')}
                      </div>
                    )}

                    <div className="mt-4 pt-4 border-t border-gray-700">
                      <h4 className="text-sm text-gray-400 mb-2">Remaining Deck</h4>
                      <div className="flex flex-wrap gap-1">
                        {playState.deck.map((card, i) => (
                          <span key={i} className="text-xs px-2 py-0.5 bg-gray-700 text-gray-400 rounded">
                            ?
                          </span>
                        ))}
                      </div>
                    </div>
                  </>
                )}

                {!playState && selectedDeck && (
                  <div className="text-center text-gray-400 py-8">
                    <p className="mb-2">Click "New Game" to start a simulation</p>
                    <p className="text-sm">Deck: {selectedDeck.name}</p>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Info Panel */}
          {!results && mode !== 'play' && selectedDeck && (
            <div className="bg-gray-800 rounded-lg p-4 panel-border">
              <h3 className="text-lg font-comic text-marvel-gold mb-2">Simulation Info</h3>
              <p className="text-sm text-gray-400 mb-3">
                Marvel Snap draws 3 cards initially, then 1 per turn. By turn 6, you've seen 9 of 12 cards.
              </p>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div className="bg-gray-700 rounded p-2 text-center">
                  <div className="text-marvel-blue font-bold">12</div>
                  <div className="text-gray-400 text-xs">Deck Size</div>
                </div>
                <div className="bg-gray-700 rounded p-2 text-center">
                  <div className="text-marvel-blue font-bold">3</div>
                  <div className="text-gray-400 text-xs">Starting Hand</div>
                </div>
                <div className="bg-gray-700 rounded p-2 text-center">
                  <div className="text-marvel-blue font-bold">1</div>
                  <div className="text-gray-400 text-xs">Draw/Turn</div>
                </div>
                <div className="bg-gray-700 rounded p-2 text-center">
                  <div className="text-marvel-blue font-bold">9</div>
                  <div className="text-gray-400 text-xs">Cards by T6</div>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    // Log Preview Modal Component
    const LogPreviewModal = ({ matches, skippedCount, onConfirm, onCancel }) => {
      const wins = matches.filter(m => m.result === 'WIN').length;
      const losses = matches.filter(m => m.result === 'LOSS').length;
      const totalCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-comic text-marvel-gold mb-4 text-center">Log Analysis Complete</h3>

            <div className="grid grid-cols-2 gap-3 mb-4">
              <div className="bg-gray-700 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">{matches.length}</div>
                <div className="text-xs text-gray-400">New Matches</div>
              </div>
              <div className="bg-gray-700 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-gray-400">{skippedCount}</div>
                <div className="text-xs text-gray-400">Duplicates Skipped</div>
              </div>
              <div className="bg-green-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-green-400">{wins}</div>
                <div className="text-xs text-gray-400">Wins</div>
              </div>
              <div className="bg-red-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-red-400">{losses}</div>
                <div className="text-xs text-gray-400">Losses</div>
              </div>
            </div>

            <div className="bg-gray-700 rounded-lg p-3 mb-4 text-center">
              <div className="text-xs text-gray-400 mb-1">Net Cubes from Import</div>
              <div className={`text-2xl font-bold ${totalCubes >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {totalCubes >= 0 ? '+' : ''}{totalCubes}
              </div>
            </div>

            {matches.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-300 mb-2">Preview (Recent 5):</h4>
                <div className="space-y-1 max-h-32 overflow-y-auto">
                  {matches.slice(0, 5).map((m, i) => (
                    <div key={i} className={`flex items-center justify-between p-2 rounded text-sm ${
                      m.result === 'WIN' ? 'bg-green-900/30' : 'bg-red-900/30'
                    }`}>
                      <span className={m.result === 'WIN' ? 'text-green-400' : 'text-red-400'}>{m.result}</span>
                      <span className="text-white">{m.result === 'WIN' ? '+' : '-'}{m.cubes}</span>
                      <span className="text-gray-400 text-xs">{formatDate(m.timestamp)}</span>
                    </div>
                  ))}
                  {matches.length > 5 && (
                    <div className="text-center text-gray-400 text-xs py-1">...and {matches.length - 5} more</div>
                  )}
                </div>
              </div>
            )}

            <div className="flex gap-2">
              <button onClick={() => onConfirm(matches)}
                className="flex-1 bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import {matches.length} Matches
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-gray-600 text-white py-3 rounded-lg font-medium hover:bg-gray-500">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Sync Confirm Modal Component
    const SyncConfirmModal = ({ syncData, onConfirm, onCancel }) => {
      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-comic text-marvel-gold mb-4 text-center">Sync Data Received</h3>

            <div className="bg-gray-700 rounded-lg p-4 mb-4">
              <div className="text-center mb-3">
                <div className="text-3xl font-bold text-marvel-blue">{syncData.c?.length || 0}</div>
                <div className="text-sm text-gray-400">Cards in Collection</div>
              </div>
              {syncData.s && (
                <div className="grid grid-cols-3 gap-2 text-center text-sm">
                  <div>
                    <div className="text-green-400 font-bold">{syncData.s.wins || 0}</div>
                    <div className="text-gray-400 text-xs">Wins</div>
                  </div>
                  <div>
                    <div className="text-red-400 font-bold">{syncData.s.losses || 0}</div>
                    <div className="text-gray-400 text-xs">Losses</div>
                  </div>
                  <div>
                    <div className={`font-bold ${(syncData.s.cubes || 0) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                      {(syncData.s.cubes || 0) >= 0 ? '+' : ''}{syncData.s.cubes || 0}
                    </div>
                    <div className="text-gray-400 text-xs">Cubes</div>
                  </div>
                </div>
              )}
            </div>

            <p className="text-gray-400 text-sm mb-4 text-center">
              This will merge the synced collection with your current data.
            </p>

            <div className="flex gap-2">
              <button onClick={onConfirm}
                className="flex-1 bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import Collection
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-gray-600 text-white py-3 rounded-lg font-medium hover:bg-gray-500">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Phase 5: Toast notification helper
    const showToast = (message) => {
      const existing = document.querySelector('.toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.setAttribute('role', 'alert');
      toast.setAttribute('aria-live', 'polite');
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.remove(), 3500);
    };

    // Phase 5: Linked Folder Sync Component (Chrome/Edge only)
    const LinkedFolderSync = ({ onSyncComplete }) => {
      const [folderHandle, setFolderHandle] = useState(null);
      const [isLinked, setIsLinked] = useState(false);
      const [lastSync, setLastSync] = useState(null);
      const [syncing, setSyncing] = useState(false);
      const [error, setError] = useState(null);

      // Check if File System Access API is supported
      const isSupported = typeof window !== 'undefined' && 'showDirectoryPicker' in window;

      // On mount, try to restore saved folder handle
      useEffect(() => {
        restoreFolderHandle();
      }, []);

      async function restoreFolderHandle() {
        try {
          const db = await openSyncDB();
          const handle = await db.get('settings', 'folderHandle');
          if (handle) {
            const permission = await handle.queryPermission({ mode: 'read' });
            if (permission === 'granted') {
              setFolderHandle(handle);
              setIsLinked(true);
              const syncTime = await db.get('settings', 'lastSyncTime');
              if (syncTime) setLastSync(new Date(syncTime));
            }
          }
        } catch (err) {
          console.log('No saved folder handle or permission expired');
        }
      }

      async function handleLinkFolder() {
        try {
          setError(null);

          const handle = await window.showDirectoryPicker({
            id: 'snap-nvprod',
            mode: 'read',
            startIn: 'desktop'
          });

          // Verify it looks like the right folder
          const files = [];
          for await (const entry of handle.values()) {
            files.push(entry.name);
          }

          const expectedFiles = ['CollectionState.json', 'ProfileState.json'];
          const hasExpectedFiles = expectedFiles.some(f => files.includes(f));

          if (!hasExpectedFiles) {
            setError("This doesn't look like the nvprod folder. Please select the folder containing CollectionState.json");
            return;
          }

          const db = await openSyncDB();
          await db.put('settings', handle, 'folderHandle');

          setFolderHandle(handle);
          setIsLinked(true);

          await syncFromFolder(handle);
        } catch (err) {
          if (err.name === 'AbortError') return;
          setError(`Failed to link folder: ${err.message}`);
        }
      }

      async function handleUnlink() {
        try {
          const db = await openSyncDB();
          await db.delete('settings', 'folderHandle');
          await db.delete('settings', 'lastSyncTime');

          setFolderHandle(null);
          setIsLinked(false);
          setLastSync(null);
        } catch (err) {
          console.error('Failed to unlink:', err);
        }
      }

      async function syncFromFolder(handle = folderHandle) {
        if (!handle) return;

        setSyncing(true);
        setError(null);

        try {
          const permission = await handle.requestPermission({ mode: 'read' });
          if (permission !== 'granted') {
            setError('Permission denied. Please re-link the folder.');
            setIsLinked(false);
            return;
          }

          const results = {
            collection: null,
            profile: null,
            mastery: null,
            battlePass: null
          };

          const fileMap = {
            'CollectionState.json': 'collection',
            'ProfileState.json': 'profile',
            'CharacterMasteryState.json': 'mastery',
            'BattlePassState.json': 'battlePass'
          };

          for (const [filename, key] of Object.entries(fileMap)) {
            try {
              const fileHandle = await handle.getFileHandle(filename);
              const file = await fileHandle.getFile();
              const content = await file.text();
              const json = JSON.parse(content);

              switch (key) {
                case 'collection':
                  results.collection = GameDataParser.parseCollection(json);
                  break;
                case 'profile':
                  results.profile = GameDataParser.parseProfile(json);
                  break;
                case 'mastery':
                  results.mastery = GameDataParser.parseMastery(json);
                  break;
                case 'battlePass':
                  results.battlePass = GameDataParser.parseBattlePass(json);
                  break;
              }
            } catch (err) {
              console.log(`Could not read ${filename}:`, err.message);
            }
          }

          const importResults = autoImportAll(results);

          const now = new Date();
          const db = await openSyncDB();
          await db.put('settings', now.toISOString(), 'lastSyncTime');
          setLastSync(now);

          showToast(`Sync complete!\n${importResults.map(r => '✓ ' + r).join('\n')}`);

          if (onSyncComplete) onSyncComplete();
          window.dispatchEvent(new Event('snap-data-updated'));
        } catch (err) {
          setError(`Sync failed: ${err.message}`);
        } finally {
          setSyncing(false);
        }
      }

      if (!isSupported) {
        return (
          <div className="linked-folder-section" style={{ opacity: 0.7 }}>
            <h4>Link Game Folder</h4>
            <div className="not-supported-msg">
              Folder linking requires Chrome or Edge browser.
              <br />
              Use drag & drop below instead.
            </div>
          </div>
        );
      }

      return (
        <div className="linked-folder-section">
          <h4>Link Game Folder</h4>
          <p className="description">
            Link your game data folder once, then sync with one click anytime.
          </p>

          {!isLinked ? (
            <div>
              <button className="link-folder-btn" onClick={handleLinkFolder}>
                Select nvprod Folder
              </button>
              <p style={{ fontSize: '0.75em', color: '#9CA3AF', marginTop: '8px' }}>
                Navigate to:<br />
                <code style={{ background: '#1A1A1A', padding: '2px 6px', borderRadius: '4px', color: '#FFC107' }}>
                  %AppData%\LocalLow\Second Dinner\SNAP\Standalone\States\nvprod
                </code>
              </p>
            </div>
          ) : (
            <div className="linked-status">
              <div className="status-row">
                <span className="status-badge linked">Folder Linked</span>
                <button className="unlink-btn" onClick={handleUnlink}>Unlink</button>
              </div>

              <button className="sync-btn" onClick={() => syncFromFolder()} disabled={syncing}>
                {syncing ? 'Syncing...' : 'Sync Now'}
              </button>

              {lastSync && (
                <p className="last-sync">
                  Last synced: {lastSync.toLocaleString()}
                </p>
              )}
            </div>
          )}

          {error && (
            <div style={{ marginTop: '10px', padding: '10px', background: 'rgba(239,68,68,0.2)', borderRadius: '8px', color: '#ef4444', fontSize: '0.85em' }}>
              {error}
            </div>
          )}
        </div>
      );
    };

    // Phase 5: JSON Sync Preview Modal
    const JSONSyncPreviewModal = ({ data, onConfirm, onCancel }) => {
      const [selectedImports, setSelectedImports] = useState({
        collection: !!data.collection,
        stats: !!data.profile,
        cardPerformance: !!data.profile?.cardPerformance,
        mastery: !!data.mastery
      });

      return (
        <div className="modal-overlay">
          <div className="modal sync-preview-modal" style={{ padding: '20px' }}>
            <h3 style={{ margin: '0 0 16px 0', color: '#FFC107', fontFamily: 'Impact, sans-serif' }}>
              Game Data Found!
            </h3>

            {/* Collection Preview */}
            {data.collection && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.collection}
                    onChange={(e) => setSelectedImports(s => ({...s, collection: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Collection</span>
                </label>
                <div className="preview-stats-grid" style={{ gridTemplateColumns: '1fr' }}>
                  <div className="preview-stat">
                    <span className="value">{data.collection.count}</span>
                    <span className="label">cards found</span>
                  </div>
                </div>
              </div>
            )}

            {/* Profile Stats Preview */}
            {data.profile && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.stats}
                    onChange={(e) => setSelectedImports(s => ({...s, stats: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Lifetime Stats</span>
                </label>
                <div className="preview-stats-grid">
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.totalGames.toLocaleString()}</span>
                    <span className="label">Total Games</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value" style={{ color: '#22c55e' }}>{data.profile.stats.winRate}%</span>
                    <span className="label">Win Rate</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.wins.toLocaleString()}</span>
                    <span className="label">Wins</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.snaps.toLocaleString()}</span>
                    <span className="label">Snaps</span>
                  </div>
                </div>
              </div>
            )}

            {/* Card Performance Preview */}
            {data.profile?.cardPerformance && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.cardPerformance}
                    onChange={(e) => setSelectedImports(s => ({...s, cardPerformance: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Card Performance</span>
                </label>
                <div className="card-performance-preview">
                  <div>
                    <h5 style={{ margin: '0 0 6px 0', fontSize: '0.8em', color: '#22c55e' }}>Best</h5>
                    {data.profile.cardPerformance.top10.slice(0, 3).map((c, i) => (
                      <div key={i} className="card-stat positive">
                        <span className="card-name">{c.card}</span>
                        <span className="cubes">+{c.netCubes}</span>
                      </div>
                    ))}
                  </div>
                  <div>
                    <h5 style={{ margin: '0 0 6px 0', fontSize: '0.8em', color: '#ef4444' }}>Worst</h5>
                    {data.profile.cardPerformance.bottom10.slice(0, 3).map((c, i) => (
                      <div key={i} className="card-stat negative">
                        <span className="card-name">{c.card}</span>
                        <span className="cubes">{c.netCubes}</span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* Mastery Preview */}
            {data.mastery && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.mastery}
                    onChange={(e) => setSelectedImports(s => ({...s, mastery: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Character Mastery</span>
                </label>
                <div className="preview-stats-grid" style={{ gridTemplateColumns: 'repeat(3, 1fr)' }}>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.totalCards}</span>
                    <span className="label">Cards</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.avgLevel}</span>
                    <span className="label">Avg Level</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.maxedCards}</span>
                    <span className="label">Maxed</span>
                  </div>
                </div>
              </div>
            )}

            <div style={{ display: 'flex', gap: '10px', marginTop: '16px' }}>
              <button
                onClick={() => onConfirm(data, selectedImports)}
                style={{ flex: 1, padding: '12px', background: '#006EC7', color: 'white', border: 'none', borderRadius: '8px', fontWeight: 'bold', cursor: 'pointer' }}
              >
                Import Selected
              </button>
              <button
                onClick={onCancel}
                style={{ flex: 1, padding: '12px', background: '#4B5563', color: 'white', border: 'none', borderRadius: '8px', cursor: 'pointer' }}
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Phase 5: Drag & Drop JSON Sync Component
    const DragDropJSONSync = ({ onDataParsed }) => {
      const [dragOver, setDragOver] = useState(false);
      const [processing, setProcessing] = useState(false);
      const fileInputRef = useRef(null);

      const handleFileDrop = async (e) => {
        e.preventDefault();
        setDragOver(false);
        const files = Array.from(e.dataTransfer?.files || []);
        if (files.length > 0) processFiles(files);
      };

      const handleFileSelect = (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length > 0) processFiles(files);
      };

      const processFiles = async (files) => {
        setProcessing(true);

        const results = {
          collection: null,
          profile: null,
          mastery: null,
          battlePass: null
        };

        for (const file of files) {
          try {
            const content = await file.text();
            const json = JSON.parse(content);

            if (file.name === 'CollectionState.json' || file.name.includes('Collection')) {
              results.collection = GameDataParser.parseCollection(json);
            } else if (file.name === 'ProfileState.json' || file.name.includes('Profile')) {
              results.profile = GameDataParser.parseProfile(json);
            } else if (file.name === 'CharacterMasteryState.json' || file.name.includes('Mastery')) {
              results.mastery = GameDataParser.parseMastery(json);
            } else if (file.name === 'BattlePassState.json' || file.name.includes('BattlePass')) {
              results.battlePass = GameDataParser.parseBattlePass(json);
            } else {
              // Try to detect file type from content
              if (json?.ServerState?.CardInventory) {
                results.collection = GameDataParser.parseCollection(json);
              } else if (json?.ServerState?.Account) {
                results.profile = GameDataParser.parseProfile(json);
              } else if (json?.ServerState?.CharacterMasteryProgress) {
                results.mastery = GameDataParser.parseMastery(json);
              } else if (json?.ServerState?.BattlePass) {
                results.battlePass = GameDataParser.parseBattlePass(json);
              }
            }
          } catch (err) {
            console.error(`Failed to parse ${file.name}:`, err);
          }
        }

        setProcessing(false);

        if (Object.values(results).some(v => v !== null)) {
          onDataParsed(results);
        } else {
          showToast('No valid game data found in the selected files');
        }
      };

      return (
        <div className="drag-drop-section">
          <h4>Drag & Drop Files</h4>
          <p className="description">Works in all browsers</p>

          <div
            className={`drop-zone-json ${dragOver ? 'drag-over' : ''}`}
            onDrop={handleFileDrop}
            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
            onDragLeave={() => setDragOver(false)}
            onClick={() => fileInputRef.current?.click()}
          >
            {processing ? (
              <div>
                <div className="spinner" style={{ margin: '0 auto 10px' }}></div>
                <span>Processing files...</span>
              </div>
            ) : (
              <>
                <span style={{ fontSize: '2.5em', display: 'block', marginBottom: '8px' }}>📁</span>
                <p style={{ margin: '0 0 8px 0', fontWeight: 'bold' }}>Drop JSON files here</p>
                <p style={{ margin: 0, fontSize: '0.85em', color: '#9CA3AF' }}>
                  CollectionState.json, ProfileState.json, etc.
                </p>
                <code>%AppData%\LocalLow\Second Dinner\SNAP\Standalone\States\nvprod\</code>
              </>
            )}
          </div>

          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileSelect}
            accept=".json"
            multiple
            style={{ display: 'none' }}
          />

          <div style={{ marginTop: '12px', padding: '10px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
            <p style={{ margin: '0 0 6px 0', fontSize: '0.85em', fontWeight: 'bold', color: '#FFC107' }}>Supported Files:</p>
            <ul style={{ margin: 0, paddingLeft: '18px', fontSize: '0.8em', color: '#aaa' }}>
              <li><strong>CollectionState.json</strong> - Your card collection</li>
              <li><strong>ProfileState.json</strong> - Lifetime stats & card performance</li>
              <li><strong>CharacterMasteryState.json</strong> - Card mastery levels</li>
              <li><strong>BattlePassState.json</strong> - Season pass progress</li>
            </ul>
            <p style={{ margin: '8px 0 0 0', fontSize: '0.8em', color: '#006EC7' }}>
              Tip: Select all 4 files and drop them together!
            </p>
          </div>
        </div>
      );
    };

    // Phase 5: Card Performance View (Analytics Tab)
    const CardPerformanceView = () => {
      const [performanceData, setPerformanceData] = useState(null);
      const [profileStats, setProfileStats] = useState(null);
      const [sortBy, setSortBy] = useState('netCubes');
      const [filterType, setFilterType] = useState('all');

      useEffect(() => {
        loadData();
        window.addEventListener('snap-data-updated', loadData);
        return () => window.removeEventListener('snap-data-updated', loadData);
      }, []);

      const loadData = () => {
        const perfData = loadFromStorage('snap_card_performance', null);
        const stats = loadFromStorage('snap_profile_stats', null);
        setPerformanceData(perfData);
        setProfileStats(stats);
      };

      if (!performanceData && !profileStats) {
        return (
          <div className="px-4 pb-20">
            <Header title="ANALYTICS" />
            <div className="import-prompt" style={{ padding: '40px 20px' }}>
              <p style={{ fontSize: '1.1em', marginBottom: '12px' }}>No game data imported yet.</p>
              <p style={{ fontSize: '0.9em' }}>
                Import your game files from<br />
                <a href="#" onClick={(e) => { e.preventDefault(); }}>Settings &rarr; PC Game Data Sync</a>
              </p>
            </div>
          </div>
        );
      }

      const cards = performanceData ? Object.entries(performanceData.cards)
        .map(([card, data]) => ({ card, ...data }))
        .filter(c => {
          if (filterType === 'positive') return c.netCubes > 0;
          if (filterType === 'negative') return c.netCubes < 0;
          return true;
        })
        .sort((a, b) => {
          if (sortBy === 'name') return a.card.localeCompare(b.card);
          return b.netCubes - a.netCubes;
        }) : [];

      const totalPositive = cards.filter(c => c.netCubes > 0).reduce((sum, c) => sum + c.netCubes, 0);
      const totalNegative = cards.filter(c => c.netCubes < 0).reduce((sum, c) => sum + c.netCubes, 0);

      return (
        <div className="px-4 pb-20">
          <Header title="ANALYTICS" />

          {/* Lifetime Stats */}
          {profileStats && (
            <div className="stats-section">
              <h3>Lifetime Stats</h3>
              <div className="stats-grid">
                <div className="stat-card">
                  <span className="stat-value">{(profileStats.totalGames || profileStats.wins + profileStats.losses).toLocaleString()}</span>
                  <span className="stat-label">Total Games</span>
                </div>
                <div className="stat-card highlight">
                  <span className="stat-value">{profileStats.winRate}%</span>
                  <span className="stat-label">Win Rate</span>
                </div>
                <div className="stat-card positive">
                  <span className="stat-value">{(profileStats.wins || 0).toLocaleString()}</span>
                  <span className="stat-label">Wins</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value">{(profileStats.snaps || 0).toLocaleString()}</span>
                  <span className="stat-label">Snaps</span>
                </div>
              </div>
              {profileStats.snapId && (
                <p className="data-source">
                  {profileStats.snapId} • Imported {new Date(profileStats.importedAt || Date.now()).toLocaleDateString()}
                </p>
              )}
            </div>
          )}

          {/* Currency Stats */}
          {profileStats?.currencies && (
            <div className="stats-section">
              <h3>Currencies</h3>
              <div className="stats-grid" style={{ gridTemplateColumns: 'repeat(3, 1fr)' }}>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#22c55e' }}>{(profileStats.currencies.credits || 0).toLocaleString()}</span>
                  <span className="stat-label">Credits</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#FFC107' }}>{(profileStats.currencies.gold || 0).toLocaleString()}</span>
                  <span className="stat-label">Gold</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#8B5CF6' }}>{(profileStats.currencies.tokens || 0).toLocaleString()}</span>
                  <span className="stat-label">Tokens</span>
                </div>
              </div>
            </div>
          )}

          {/* Card Performance */}
          {performanceData && cards.length > 0 && (
            <>
              <div className="stats-section" style={{ padding: '12px 16px' }}>
                <h3 style={{ marginBottom: '8px' }}>Card Performance</h3>
                <p style={{ margin: 0, fontSize: '0.8em', color: '#9CA3AF' }}>Net cubes earned/lost per card (lifetime)</p>

                <div className="performance-summary" style={{ marginTop: '12px' }}>
                  <div className="summary-stat positive">
                    <span className="label">Gained</span>
                    <span className="value">+{totalPositive.toLocaleString()}</span>
                  </div>
                  <div className="summary-stat negative">
                    <span className="label">Lost</span>
                    <span className="value">{totalNegative.toLocaleString()}</span>
                  </div>
                  <div className="summary-stat net">
                    <span className="label">Net</span>
                    <span className="value">{(totalPositive + totalNegative).toLocaleString()}</span>
                  </div>
                </div>

                <div style={{ display: 'flex', gap: '8px', marginBottom: '12px' }}>
                  <select
                    value={filterType}
                    onChange={(e) => setFilterType(e.target.value)}
                    style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
                  >
                    <option value="all">All Cards ({Object.keys(performanceData.cards).length})</option>
                    <option value="positive">Winners Only</option>
                    <option value="negative">Losers Only</option>
                  </select>
                  <select
                    value={sortBy}
                    onChange={(e) => setSortBy(e.target.value)}
                    style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
                  >
                    <option value="netCubes">By Cubes</option>
                    <option value="name">By Name</option>
                  </select>
                </div>

                <div style={{ maxHeight: '350px', overflowY: 'auto' }}>
                  {cards.map((card, i) => (
                    <div
                      key={card.card}
                      className={`performance-card ${card.netCubes >= 0 ? 'positive' : 'negative'}`}
                    >
                      <span className="rank">#{i + 1}</span>
                      <span className="card-name">{card.card}</span>
                      <span className="net-cubes">
                        {card.netCubes >= 0 ? '+' : ''}{card.netCubes}
                      </span>
                    </div>
                  ))}
                </div>
              </div>

              <p style={{ textAlign: 'center', fontSize: '0.75em', color: '#9CA3AF' }}>
                Data from: {new Date(performanceData.importedAt).toLocaleDateString()}
              </p>
            </>
          )}
        </div>
      );
    };

    // Settings Component
    const Settings = ({ settings, setSettings, collection, matches, setCollection, setMatches, aiConfig, setAiConfig, decks, setDecks }) => {
      const [showImport, setShowImport] = useState(false);
      const [importData, setImportData] = useState('');
      const [showAdvanced, setShowAdvanced] = useState(false);
      const [testStatus, setTestStatus] = useState({});
      const [rapidApiKey, setRapidApiKey] = useState(loadFromStorage('snap_rapidapi_key', ''));
      const [isRefreshingCards, setIsRefreshingCards] = useState(false);

      // Phase 4: Log Ingestor state
      const [isDragOver, setIsDragOver] = useState(false);
      const [isProcessingLog, setIsProcessingLog] = useState(false);
      const [logError, setLogError] = useState(null);
      const [showLogPreview, setShowLogPreview] = useState(false);
      const [parsedMatches, setParsedMatches] = useState([]);
      const [skippedCount, setSkippedCount] = useState(0);
      const fileInputRef = useRef(null);

      // Phase 4: QR Sync state
      const [qrDataUrl, setQrDataUrl] = useState(null);

      // Performance mode state
      const [performanceMode, setPerformanceMode] = useState(() => {
        const stored = localStorage.getItem('snap_performance_mode');
        return stored || 'auto';
      });
      const [qrError, setQrError] = useState(null);

      // Phase 5: JSON Sync state
      const [showJSONSyncPreview, setShowJSONSyncPreview] = useState(false);
      const [jsonSyncData, setJSONSyncData] = useState(null);

      // Google OAuth 2.0 state
      const [googleSignedIn, setGoogleSignedIn] = useState(isGoogleTokenValid());

      // Google OAuth initialization
      useEffect(() => {
        // Initialize OAuth 2.0 token client
        const initOAuth = () => {
          if (window.google?.accounts?.oauth2) {
            initGoogleOAuth((accessToken) => {
              // Token received callback
              setGoogleSignedIn(true);
              setAiConfig(prev => ({
                ...prev,
                provider: 'gemini-oauth',
                model: AIProviders['gemini-oauth'].defaultModel
              }));
              setTestStatus(prev => ({ ...prev, 'gemini-oauth': 'success' }));
              showToast('Signed in with Google');
            });
          }
        };

        // Try to init now, or wait for script to load
        if (window.google?.accounts?.oauth2) {
          initOAuth();
        } else {
          const checkGoogle = setInterval(() => {
            if (window.google?.accounts?.oauth2) {
              clearInterval(checkGoogle);
              initOAuth();
            }
          }, 500);
          // Stop checking after 10 seconds
          setTimeout(() => clearInterval(checkGoogle), 10000);
        }

        // Check if we have a valid token
        if (isGoogleTokenValid()) {
          setGoogleSignedIn(true);
        }
      }, []);

      const handleGoogleSignIn = async () => {
        try {
          await requestGoogleAccessToken();
          setGoogleSignedIn(true);
          setAiConfig(prev => ({
            ...prev,
            provider: 'gemini-oauth',
            model: AIProviders['gemini-oauth'].defaultModel
          }));
          setTestStatus(prev => ({ ...prev, 'gemini-oauth': 'success' }));
        } catch (err) {
          if (err.message !== 'popup_closed') {
            showToast('Google sign-in failed: ' + err.message);
          }
        }
      };

      const handleGoogleSignOut = () => {
        signOutGoogle();
        setGoogleSignedIn(false);
        setAiConfig(prev => ({ ...prev, provider: '' }));
        setTestStatus(prev => ({ ...prev, 'gemini-oauth': null }));
        showToast('Signed out from Google');
      };

      const setApiKey = (provider, key) => {
        setAiConfig(prev => ({
          ...prev,
          apiKeys: { ...prev.apiKeys, [provider]: key }
        }));
      };

      const selectProvider = (providerId) => {
        const provider = AIProviders[providerId];
        setAiConfig(prev => ({
          ...prev,
          provider: providerId,
          model: provider.defaultModel
        }));
      };

      const testConnection = async (providerId) => {
        setTestStatus(prev => ({ ...prev, [providerId]: 'testing' }));
        try {
          const testMessages = [{ role: 'user', content: 'Say "Connection successful!" in 5 words or less.' }];
          const model = aiConfig.model || AIProviders[providerId]?.defaultModel;

          switch (providerId) {
            case 'gemini-oauth':
              if (!isGoogleTokenValid()) {
                throw new Error('Please sign in with Google first');
              }
              await callGeminiOAuth(testMessages, model);
              break;
            case 'gemini':
              await callGeminiAPIKey(testMessages, model, aiConfig.apiKeys?.gemini);
              break;
            case 'groq':
              await callGroq(testMessages, model, aiConfig.apiKeys?.groq);
              break;
            case 'claude':
              await callClaude(testMessages, model, aiConfig.apiKeys?.claude);
              break;
            case 'openai':
              await callOpenAI(testMessages, model, aiConfig.apiKeys?.openai);
              break;
            case 'local':
              await callLocal(testMessages, model, aiConfig.localEndpoint);
              break;
          }
          setTestStatus(prev => ({ ...prev, [providerId]: 'success' }));
        } catch (err) {
          console.error('Test failed:', err);
          setTestStatus(prev => ({ ...prev, [providerId]: 'error' }));
        }
      };

      // CORS proxy helper - uses multiple fallback proxies
      const fetchWithCorsProxy = async (url) => {
        const CORS_PROXIES = [
          (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
          (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`
        ];

        // First try direct fetch (in case CORS is enabled)
        try {
          const directResponse = await fetch(url);
          if (directResponse.ok) return directResponse;
        } catch (e) {
          console.log('Direct fetch failed, trying CORS proxies...');
        }

        // Try each CORS proxy
        for (const proxyFn of CORS_PROXIES) {
          try {
            const proxyUrl = proxyFn(url);
            const response = await fetch(proxyUrl);
            if (response.ok) return response;
          } catch (e) {
            console.log('Proxy failed, trying next...');
          }
        }

        throw new Error('All fetch methods failed (CORS blocked)');
      };

      const refreshCardData = async () => {
        setIsRefreshingCards(true);
        try {
          // Try marvelsnap.io API first (353+ cards)
          let normalizedCards = [];
          try {
            const response = await fetchWithCorsProxy('https://marvelsnap.io/api/search.php?database&limit=500');
            if (response.ok) {
              const data = await response.json();
              normalizedCards = (data || []).filter(c => c.type === 'Character').map(card => ({
                name: card.name,
                cost: parseInt(card.cost) || 0,
                power: parseInt(card.power) || 0,
                ability: card.ability || '',
                series: card.pool?.includes('Pool 1') || card.pool?.includes('Starter') ? 1 :
                        card.pool?.includes('Pool 2') ? 2 :
                        card.pool?.includes('Pool 3') ? 3 :
                        card.pool?.includes('Series 4') ? 4 : 5
              }));
            }
          } catch (e) {
            console.log('marvelsnap.io failed, trying MarvelSnapZone...', e.message);
          }

          // Fallback to MarvelSnapZone if marvelsnap.io fails
          if (normalizedCards.length === 0) {
            const response = await fetchWithCorsProxy('https://marvelsnapzone.com/getinfo/?searchtype=cards&searchcardstype=true');
            if (!response.ok) throw new Error('Both APIs failed');
            const data = await response.json();
            normalizedCards = (data.success?.cards || []).map(card => ({
              name: card.name,
              cost: parseInt(card.cost) || 0,
              power: parseInt(card.power) || 0,
              ability: card.ability || card.description || '',
              series: parseInt(card.source?.match(/Series (\d)/)?.[1]) || 3
            }));
          }

          if (normalizedCards.length > 0) {
            saveToStorage('snap_card_cache', { data: normalizedCards, timestamp: Date.now() });
            alert(`Card data refreshed! ${normalizedCards.length} cards loaded.`);
            window.location.reload(); // Reload to apply new card data
          } else {
            throw new Error('No cards returned from API');
          }
        } catch (err) {
          alert('Failed to refresh cards: ' + err.message + '. Using built-in card database.');
        } finally {
          setIsRefreshingCards(false);
        }
      };

      // Handle performance mode change
      const handlePerformanceModeChange = (mode) => {
        setPerformanceMode(mode);
        localStorage.setItem('snap_performance_mode', mode);
        applyPerformanceMode();
        showToast(`Performance mode: ${mode === 'auto' ? 'Auto-detect' : mode === 'low' ? 'Low-end' : 'Full effects'}`);
      };

      // Phase 4: Log file handlers
      const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
      };

      const handleLogDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
        const file = e.dataTransfer?.files[0];
        if (file) processLogFile(file);
      };

      const handleFileSelect = (e) => {
        const file = e.target.files?.[0];
        if (file) processLogFile(file);
      };

      const processLogFile = (file) => {
        setLogError(null);

        // Validate file
        if (!file.name.endsWith('.log') && !file.name.endsWith('.txt')) {
          setLogError('Please select a .log or .txt file');
          return;
        }

        // Size check (50MB limit)
        if (file.size > 50 * 1024 * 1024) {
          setLogError(LogErrors.FILE_TOO_LARGE);
          return;
        }

        setIsProcessingLog(true);

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const content = event.target.result;
            const parsed = LogParser.parsePlayerLog(content);

            if (parsed.matches.length === 0) {
              setLogError(LogErrors.NO_MATCHES);
              setIsProcessingLog(false);
              return;
            }

            // Check for duplicates against existing data
            const merged = LogParser.mergeWithExisting(parsed.matches, matches);

            setParsedMatches(merged.added);
            setSkippedCount(merged.skipped);
            setShowLogPreview(true);
            setIsProcessingLog(false);
          } catch (err) {
            console.error('Log parse error:', err);
            setLogError(LogErrors.PARSE_FAILED);
            setIsProcessingLog(false);
          }
        };

        reader.onerror = () => {
          setLogError(LogErrors.READ_ERROR);
          setIsProcessingLog(false);
        };

        reader.readAsText(file);
      };

      const handleLogImport = (matchesToImport) => {
        setMatches(prev => [...prev, ...matchesToImport].sort((a, b) =>
          new Date(b.timestamp) - new Date(a.timestamp)
        ));
        setShowLogPreview(false);
        setParsedMatches([]);
        alert(`Successfully imported ${matchesToImport.length} matches!`);
      };

      // Phase 5: JSON Sync Confirm Handler
      const handleJSONSyncConfirm = (data, selectedImports) => {
        const timestamp = new Date().toISOString();
        const syncLog = [];

        // Import Collection
        if (selectedImports.collection && data.collection) {
          const existingCollection = JSON.parse(localStorage.getItem('snap_collection') || '{"owned":[]}');
          const mergedCards = [...new Set([...existingCollection.owned, ...data.collection.cards])];

          const newCollection = {
            owned: mergedCards,
            lastUpdated: timestamp,
            source: 'JSONImport'
          };
          localStorage.setItem('snap_collection', JSON.stringify(newCollection));
          setCollection(newCollection);

          syncLog.push(`Collection: ${mergedCards.length} cards`);
        }

        // Import Profile Stats
        if (selectedImports.stats && data.profile) {
          localStorage.setItem('snap_profile_stats', JSON.stringify({
            ...data.profile.stats,
            snapId: data.profile.player.snapId,
            currencies: data.profile.currencies,
            importedAt: timestamp,
            source: 'ProfileState.json'
          }));

          syncLog.push(`Stats: ${data.profile.stats.totalGames.toLocaleString()} games`);
        }

        // Import Card Performance
        if (selectedImports.cardPerformance && data.profile?.cardPerformance) {
          const performanceMap = {};
          data.profile.cardPerformance.all.forEach(({ card, netCubes }) => {
            performanceMap[card] = { netCubes };
          });

          localStorage.setItem('snap_card_performance', JSON.stringify({
            cards: performanceMap,
            importedAt: timestamp,
            source: 'ProfileState.json'
          }));

          syncLog.push(`Card Performance: ${data.profile.cardPerformance.all.length} cards tracked`);
        }

        // Import Mastery
        if (selectedImports.mastery && data.mastery) {
          localStorage.setItem('snap_mastery', JSON.stringify({
            cards: data.mastery.cards,
            importedAt: timestamp,
            source: 'CharacterMasteryState.json'
          }));

          syncLog.push(`Mastery: ${data.mastery.totalCards} cards`);
        }

        // Update sync history
        const syncHistory = JSON.parse(localStorage.getItem('snap_sync_history') || '[]');
        syncHistory.unshift({
          date: timestamp,
          imported: syncLog
        });
        localStorage.setItem('snap_sync_history', JSON.stringify(syncHistory.slice(0, 10)));

        setShowJSONSyncPreview(false);
        setJSONSyncData(null);

        showToast(`Sync Complete!\n${syncLog.map(r => '✓ ' + r).join('\n')}`);
        window.dispatchEvent(new Event('snap-data-updated'));
      };

      // Phase 4: QR Code generation
      const generateSyncQR = async () => {
        setQrError(null);
        setQrDataUrl(null);

        try {
          const syncData = VaultManager.generateSyncData(collection, matches);
          const compressed = VaultManager.compressForQR(syncData);

          if (!compressed) {
            setQrError('Failed to compress data');
            return;
          }

          // QR codes have size limits (~2.5KB for reliable scanning)
          if (compressed.length > 2500) {
            setQrError('Collection too large for QR sync. Use file export instead.');
            return;
          }

          const syncUrl = `https://platano78.github.io/Marvel-Snap-Tactics-/?sync=${compressed}`;

          // Generate QR code using the QRCode library
          const dataUrl = await QRCode.toDataURL(syncUrl, {
            width: 200,
            margin: 2,
            color: { dark: '#1A1A1A', light: '#FFFFFF' }
          });

          setQrDataUrl(dataUrl);
        } catch (err) {
          console.error('QR generation error:', err);
          setQrError('Failed to generate QR code');
        }
      };

      // Phase 4: Vault export
      const exportVault = () => {
        const vault = VaultManager.exportFullVault(collection, matches, settings);
        const blob = new Blob([JSON.stringify(vault, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `snapapoulous-vault-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      };

      const handleExport = (type) => {
        let data, filename;
        if (type === 'all') {
          data = { collection, matches, decks, settings, aiConfig: { ...aiConfig, apiKeys: {}, googleToken: null } };
          filename = `snapapoulous-backup-${new Date().toISOString().split('T')[0]}.json`;
        } else if (type === 'collection') {
          data = collection;
          filename = `snap-collection-${new Date().toISOString().split('T')[0]}.json`;
        } else if (type === 'decks') {
          data = decks;
          filename = `snap-decks-${new Date().toISOString().split('T')[0]}.json`;
        } else {
          data = matches;
          filename = `snap-matches-${new Date().toISOString().split('T')[0]}.json`;
        }
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
      };

      const handleImport = () => {
        try {
          const data = JSON.parse(importData);
          if (data.collection && data.matches) {
            setCollection(data.collection);
            setMatches(data.matches);
            if (data.decks) setDecks(data.decks);
            if (data.settings) setSettings(data.settings);
            alert('Data imported successfully!');
          } else if (data.owned) {
            setCollection(data);
            alert('Collection imported!');
          } else if (Array.isArray(data) && data[0]?.cards) {
            setDecks(data);
            alert('Decks imported!');
          } else if (Array.isArray(data)) {
            setMatches(data);
            alert('Matches imported!');
          } else {
            alert('Unrecognized format');
          }
          setShowImport(false);
          setImportData('');
        } catch { alert('Invalid JSON'); }
      };

      const StatusBadge = ({ status }) => {
        if (!status) return null;
        if (status === 'testing') return <span className="text-yellow-400 text-xs">Testing...</span>;
        if (status === 'success') return <span className="text-green-400 text-xs">Connected</span>;
        return <span className="text-red-400 text-xs">Failed</span>;
      };

      const mainProviders = Object.values(AIProviders).filter(p => !p.advanced);
      const advancedProviders = Object.values(AIProviders).filter(p => p.advanced);

      return (
        <div className="px-4 pb-20">
          <Header title="SETTINGS" />

          {/* App Info */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex items-center gap-3">
              <div className="w-12 h-12 bg-marvel-red rounded-lg flex items-center justify-center">
                <span className="text-2xl font-comic text-white">S</span>
              </div>
              <div>
                <div className="text-white font-bold">Snapapoulous Prime</div>
                <div className="text-gray-400 text-sm">v2.3.2 - Network-First HTML + Auto-Update</div>
              </div>
            </div>
          </div>

          {/* PC Game Data Sync - Phase 5 */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4 pc-sync-section">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">PC Game Data Sync</h3>
            <p className="text-gray-400 text-sm mb-4">
              Import your collection, stats, and card performance directly from game files.
            </p>

            {/* Method 1: Linked Folder (Chrome/Edge) */}
            <LinkedFolderSync onSyncComplete={() => {
              setCollection(loadFromStorage('snap_collection', { owned: [], lastUpdated: new Date().toISOString() }));
            }} />

            <div className="sync-divider">
              <span>or</span>
            </div>

            {/* Method 2: Drag & Drop JSON (All Browsers) */}
            <DragDropJSONSync onDataParsed={(data) => {
              setJSONSyncData(data);
              setShowJSONSyncPreview(true);
            }} />
          </div>

          {/* Legacy Log Sync (Player.log) */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Match Log Import</h3>
            <p className="text-gray-400 text-sm mb-4">
              Import match history from Player.log (legacy method).
            </p>

            <div
              className={`drop-zone ${isDragOver ? 'drag-over' : ''}`}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onDrop={handleLogDrop}
              onClick={() => fileInputRef.current?.click()}
            >
              {isProcessingLog ? (
                <div className="flex flex-col items-center">
                  <div className="spinner mb-2"></div>
                  <span className="text-gray-300">Analyzing Player.log...</span>
                  <span className="text-gray-500 text-xs mt-1">This may take a moment for large files</span>
                </div>
              ) : (
                <>
                  <span className="drop-icon">📜</span>
                  <span className="text-gray-300">Drop Player.log here or click to browse</span>
                  <span className="file-path">
                    Windows: %AppData%\LocalLow\Second Dinner\SNAP\...\Player.log
                  </span>
                </>
              )}
            </div>
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileSelect}
              accept=".log,.txt"
              className="hidden"
            />

            {logError && (
              <div className="mt-3 bg-red-900/50 border border-red-500 rounded-lg p-3">
                <p className="text-red-300 text-sm">{logError}</p>
              </div>
            )}
          </div>

          {/* QR Sync - Phase 4 */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Cross-Device Sync</h3>
            <p className="text-gray-400 text-sm mb-4">
              Generate a QR code to quickly sync your collection to another device.
            </p>

            <button
              onClick={generateSyncQR}
              className="w-full bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600 mb-3"
            >
              📱 Generate Sync QR Code
            </button>

            {qrError && (
              <div className="bg-red-900/50 border border-red-500 rounded-lg p-3 mb-3">
                <p className="text-red-300 text-sm">{qrError}</p>
              </div>
            )}

            {qrDataUrl && (
              <div className="text-center">
                <div className="qr-container inline-block mb-2">
                  <img src={qrDataUrl} alt="Sync QR Code" />
                </div>
                <p className="text-gray-400 text-xs">Scan with your phone camera to sync collection</p>
              </div>
            )}
          </div>

          {/* AI Provider Configuration */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-4">AI Provider</h3>

            {/* Google OAuth - Primary */}
            <div className="mb-4 p-4 bg-gray-700 rounded-lg border-2 border-marvel-blue">
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2">
                  <span className="text-white font-medium">Google (Gemini)</span>
                  <span className="bg-marvel-blue text-white text-xs px-2 py-0.5 rounded">Recommended</span>
                </div>
                <StatusBadge status={testStatus['gemini-oauth']} />
              </div>
              <p className="text-gray-400 text-sm mb-3">One-click sign in, no API key needed</p>

              {googleSignedIn ? (
                <div className="space-y-2">
                  <div className="flex gap-2">
                    <button onClick={() => selectProvider('gemini-oauth')}
                      className={`flex-1 py-2 rounded font-medium ${aiConfig.provider === 'gemini-oauth' ? 'bg-marvel-blue text-white' : 'bg-gray-600 text-gray-300'}`}>
                      {aiConfig.provider === 'gemini-oauth' ? 'Selected' : 'Use This'}
                    </button>
                    <button onClick={() => testConnection('gemini-oauth')}
                      className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-500">Test</button>
                    <button onClick={handleGoogleSignOut}
                      className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-500">Sign Out</button>
                  </div>
                  {/* Model selector for Gemini OAuth */}
                  {aiConfig.provider === 'gemini-oauth' && (
                    <div className="mt-2">
                      <label className="text-gray-400 text-xs mb-1 block">Select Model:</label>
                      <select
                        value={aiConfig.model || AIProviders['gemini-oauth'].defaultModel}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                        className="w-full bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-blue focus:outline-none">
                        {AIProviders['gemini-oauth'].models.map(m => (
                          <option key={m} value={m}>{m}</option>
                        ))}
                      </select>
                      <p className="text-gray-500 text-xs mt-1">Gemini 3 models are preview versions with latest capabilities</p>
                    </div>
                  )}
                </div>
              ) : (
                <div>
                  <button onClick={handleGoogleSignIn}
                    className="w-full bg-white text-gray-800 py-3 rounded-lg font-medium flex items-center justify-center gap-2 hover:bg-gray-100">
                    <svg className="w-5 h-5" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Continue with Google
                  </button>
                </div>
              )}
            </div>

            {/* API Key Providers */}
            {mainProviders.filter(p => p.id !== 'gemini-oauth').map(provider => (
              <div key={provider.id} className="mb-3 p-3 bg-gray-700 rounded-lg">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-white font-medium">{provider.name}</span>
                  <StatusBadge status={testStatus[provider.id]} />
                </div>
                <p className="text-gray-400 text-xs mb-2">{provider.description}</p>
                <div className="flex gap-2">
                  <input type="password" placeholder="API Key..."
                    value={aiConfig.apiKeys?.[provider.id] || ''}
                    onChange={(e) => setApiKey(provider.id, e.target.value)}
                    className="flex-1 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                  <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                    disabled={!aiConfig.apiKeys?.[provider.id]}
                    className="bg-marvel-blue text-white px-3 py-2 rounded text-sm hover:bg-blue-600 disabled:opacity-50">
                    Test
                  </button>
                </div>
                {aiConfig.provider === provider.id && (
                  <div className="mt-2">
                    <select value={aiConfig.model || provider.defaultModel}
                      onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                      className="w-full bg-gray-600 text-white rounded px-2 py-1 text-sm border border-gray-500">
                      {provider.models.map(m => <option key={m} value={m}>{m}</option>)}
                    </select>
                  </div>
                )}
              </div>
            ))}

            {/* Advanced Section */}
            <button onClick={() => setShowAdvanced(!showAdvanced)}
              className="w-full flex items-center justify-between py-2 text-gray-400 hover:text-white">
              <span className="text-sm">Advanced Options</span>
              <span>{showAdvanced ? '▲' : '▼'}</span>
            </button>

            {showAdvanced && (
              <div className="mt-3 space-y-3">
                {advancedProviders.map(provider => (
                  <div key={provider.id} className="p-3 bg-gray-700 rounded-lg">
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-white font-medium">{provider.name}</span>
                      <StatusBadge status={testStatus[provider.id]} />
                    </div>
                    <p className="text-gray-400 text-xs mb-2">{provider.description}</p>
                    <div className="flex gap-2">
                      <input type="text"
                        placeholder="http://localhost:11434"
                        value={aiConfig.localEndpoint || ''}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, localEndpoint: e.target.value }))}
                        className="flex-1 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                      <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                        className="bg-gray-600 text-white px-3 py-2 rounded text-sm hover:bg-gray-500">Test</button>
                    </div>
                    <p className="text-gray-500 text-xs mt-1">Common ports: Ollama (11434), LM Studio (1234), vLLM (8000)</p>
                    {aiConfig.provider === provider.id && (
                      <input type="text" placeholder="Model name..."
                        value={aiConfig.model || ''}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                        className="w-full mt-2 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                    )}
                  </div>
                ))}
              </div>
            )}

            {/* Current Selection */}
            {aiConfig.provider && (
              <div className="mt-4 p-3 bg-green-900/30 border border-green-600 rounded-lg">
                <div className="text-green-400 text-sm">
                  Active: <strong>{AIProviders[aiConfig.provider]?.name}</strong>
                  {aiConfig.model && <span className="text-green-300"> ({aiConfig.model})</span>}
                </div>
              </div>
            )}
          </div>

          {/* AI Context Settings - Phase 4 */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">AI Context</h3>
            <p className="text-gray-400 text-sm mb-3">
              Configure how much context Snapapoulous has access to for personalized advice.
            </p>

            {/* Enhanced Persona Toggle */}
            <div className="flex items-center justify-between py-2 border-b border-gray-700">
              <div>
                <span className="text-white font-medium">Enhanced AI Context</span>
                <p className="text-gray-500 text-xs mt-1">
                  Includes rich match analysis, collection gaps, meta context, and persona from persona.json
                </p>
              </div>
              <button
                onClick={() => setSettings(prev => ({ ...prev, useSimplePersona: !prev.useSimplePersona }))}
                className={`relative w-12 h-6 rounded-full transition-colors ${
                  !settings.useSimplePersona ? 'bg-series-2' : 'bg-gray-600'
                }`}
              >
                <span className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${
                  !settings.useSimplePersona ? 'left-7' : 'left-1'
                }`} />
              </button>
            </div>

            {/* Context Preview */}
            {!settings.useSimplePersona && (
              <div className="mt-3 p-3 bg-gray-700 rounded-lg text-xs text-gray-300">
                <p className="font-medium text-marvel-gold mb-2">Context includes:</p>
                <ul className="space-y-1 list-disc list-inside">
                  <li>Current date & season (Dragons Season)</li>
                  <li>Your match history analysis (trends, streaks, deck performance)</li>
                  <li>Collection gaps & playable archetypes</li>
                  <li>Recent OTA balance changes</li>
                  <li>Current meta tier list</li>
                  <li>Full persona from persona.json</li>
                </ul>
              </div>
            )}

            {settings.useSimplePersona && (
              <div className="mt-3 p-3 bg-gray-700 rounded-lg text-xs text-gray-300">
                <p className="font-medium text-gray-400 mb-2">Simplified mode active:</p>
                <p>Basic stats only. Faster responses but less personalized advice.</p>
              </div>
            )}
          </div>

          {/* Card Database */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Card Database</h3>
            <p className="text-gray-400 text-sm mb-3">Fetch latest card data from MarvelSnapZone. No API key required.</p>
            <button onClick={refreshCardData} disabled={isRefreshingCards}
              className="w-full bg-series-3 text-white py-2 rounded hover:opacity-80 disabled:opacity-50">
              {isRefreshingCards ? 'Refreshing...' : 'Refresh Card Data'}
            </button>
            <p className="text-gray-500 text-xs mt-2">
              Data source: <a href="https://marvelsnapzone.com" target="_blank" className="text-marvel-blue hover:underline">MarvelSnapZone</a>
            </p>
          </div>

          {/* Performance Mode */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Performance Mode</h3>
            <p className="text-gray-400 text-sm mb-3">
              Reduce animations and effects to improve performance on older devices or save battery.
            </p>
            <div className="grid grid-cols-3 gap-2">
              <button
                onClick={() => handlePerformanceModeChange('auto')}
                className={`py-3 rounded-lg font-medium text-sm transition-colors ${
                  performanceMode === 'auto'
                    ? 'bg-marvel-blue text-white'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                Auto
              </button>
              <button
                onClick={() => handlePerformanceModeChange('high')}
                className={`py-3 rounded-lg font-medium text-sm transition-colors ${
                  performanceMode === 'high'
                    ? 'bg-series-2 text-white'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                Full Effects
              </button>
              <button
                onClick={() => handlePerformanceModeChange('low')}
                className={`py-3 rounded-lg font-medium text-sm transition-colors ${
                  performanceMode === 'low'
                    ? 'bg-series-4 text-black'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                Low-End
              </button>
            </div>
            <p className="text-gray-500 text-xs mt-2">
              {performanceMode === 'auto' && 'Automatically detects device capabilities, battery level, and connection speed.'}
              {performanceMode === 'high' && 'All animations and effects enabled for the best visual experience.'}
              {performanceMode === 'low' && 'Minimal animations for smoother performance on any device.'}
            </p>
            {document.body.classList.contains('low-end-mode') && (
              <div className="mt-2 text-xs text-marvel-gold flex items-center gap-1">
                <span>Currently running in low-end mode</span>
              </div>
            )}
          </div>

          {/* Export/Import */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Export Data</h3>
            <div className="space-y-2 mb-4">
              <button onClick={exportVault} className="w-full bg-marvel-gold text-black py-3 rounded-lg font-medium hover:bg-yellow-400 flex items-center justify-center gap-2">
                <span>📦</span> Export Full Vault (Recommended)
              </button>
              <div className="grid grid-cols-4 gap-2">
                <button onClick={() => handleExport('all')} className="bg-marvel-blue text-white py-2 rounded text-sm hover:bg-blue-600">Backup</button>
                <button onClick={() => handleExport('collection')} className="bg-series-3 text-white py-2 rounded text-sm hover:opacity-80">Collection</button>
                <button onClick={() => handleExport('matches')} className="bg-series-2 text-white py-2 rounded text-sm hover:opacity-80">Matches</button>
                <button onClick={() => handleExport('decks')} className="bg-series-4 text-black py-2 rounded text-sm hover:opacity-80">Decks</button>
              </div>
            </div>

            <h3 className="text-lg font-comic text-marvel-gold mb-3">Import Data</h3>
            {!showImport ? (
              <button onClick={() => setShowImport(true)} className="w-full bg-gray-700 text-white py-2 rounded hover:bg-gray-600">
                Import from JSON
              </button>
            ) : (
              <div className="space-y-2">
                <textarea value={importData} onChange={(e) => setImportData(e.target.value)}
                  placeholder="Paste JSON data here..."
                  className="w-full h-24 bg-gray-700 text-white rounded px-3 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none text-sm" />
                <div className="flex gap-2">
                  <button onClick={handleImport} className="flex-1 bg-marvel-blue text-white py-2 rounded hover:bg-blue-600">Import</button>
                  <button onClick={() => { setShowImport(false); setImportData(''); }} className="flex-1 bg-gray-600 text-white py-2 rounded hover:bg-gray-500">Cancel</button>
                </div>
              </div>
            )}
          </div>

          {/* Danger Zone */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border border-red-500/50">
            <h3 className="text-lg font-comic text-red-400 mb-3">Danger Zone</h3>
            <button onClick={() => {
              if (confirm('Clear ALL data including AI settings?')) {
                localStorage.clear();
                setCollection({ owned: [], lastUpdated: new Date().toISOString() });
                setMatches([]);
                setDecks([]);
                setSettings({ theme: 'dark' });
                setAiConfig({ provider: '', model: '', apiKeys: {}, googleToken: null, localEndpoint: 'http://localhost:11434' });
                alert('All data cleared');
              }
            }} className="w-full bg-red-600 text-white py-2 rounded hover:bg-red-500">Clear All Data</button>
          </div>

          {/* Log Preview Modal */}
          {showLogPreview && (
            <LogPreviewModal
              matches={parsedMatches}
              skippedCount={skippedCount}
              onConfirm={handleLogImport}
              onCancel={() => { setShowLogPreview(false); setParsedMatches([]); }}
            />
          )}

          {/* JSON Sync Preview Modal - Phase 5 */}
          {showJSONSyncPreview && jsonSyncData && (
            <JSONSyncPreviewModal
              data={jsonSyncData}
              onConfirm={handleJSONSyncConfirm}
              onCancel={() => { setShowJSONSyncPreview(false); setJSONSyncData(null); }}
            />
          )}
        </div>
      );
    };

    // ==================== ERROR BOUNDARY ====================
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('App Error:', error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="p-4 bg-red-900/50 rounded-lg text-center m-4">
              <h2 className="text-xl font-comic text-marvel-red mb-2">Something went wrong</h2>
              <p className="text-gray-300 mb-4">{this.state.error?.message || 'An unexpected error occurred'}</p>
              <button
                onClick={() => this.setState({ hasError: false, error: null })}
                className="bg-marvel-blue px-4 py-2 rounded font-medium hover:bg-blue-600"
              >
                Try Again
              </button>
            </div>
          );
        }
        return this.props.children;
      }
    }

    // ==================== CONFIRMATION DIALOG ====================
    const ConfirmDialog = ({
      isOpen,
      title,
      message,
      confirmText = "Confirm",
      cancelText = "Cancel",
      danger = false,
      onConfirm,
      onCancel
    }) => {
      // Handle escape key
      useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape' && isOpen) {
            onCancel();
          }
        };
        window.addEventListener('keydown', handleEscape);
        return () => window.removeEventListener('keydown', handleEscape);
      }, [isOpen, onCancel]);

      if (!isOpen) return null;

      return (
        <div
          className="modal-overlay"
          role="dialog"
          aria-modal="true"
          aria-labelledby="confirm-dialog-title"
          onClick={onCancel}
        >
          <div
            className="modal p-6 max-w-sm"
            onClick={e => e.stopPropagation()}
          >
            <h3
              id="confirm-dialog-title"
              className="text-xl font-comic text-marvel-gold mb-3"
            >
              {title}
            </h3>
            <p className="text-gray-300 mb-6">{message}</p>
            <div className="flex gap-3">
              <button
                onClick={onCancel}
                className="flex-1 bg-gray-600 text-white py-3 rounded-lg font-medium hover:bg-gray-500 touch-target"
                autoFocus
              >
                {cancelText}
              </button>
              <button
                onClick={onConfirm}
                className={`flex-1 py-3 rounded-lg font-medium touch-target ${
                  danger
                    ? 'bg-red-600 text-white hover:bg-red-500'
                    : 'bg-marvel-blue text-white hover:bg-blue-600'
                }`}
              >
                {confirmText}
              </button>
            </div>
          </div>
        </div>
      );
    };

    // ==================== OFFLINE INDICATOR ====================
    const OfflineIndicator = () => {
      const [isOnline, setIsOnline] = useState(navigator.onLine);

      useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);

        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      if (isOnline) return null;

      return (
        <div
          className="fixed top-0 left-0 right-0 bg-yellow-600 text-black text-center py-2 text-sm font-medium z-50"
          role="alert"
          aria-live="polite"
          style={{ paddingTop: 'calc(0.5rem + env(safe-area-inset-top))' }}
        >
          You're offline - AI features unavailable
        </div>
      );
    };

    // ==================== PWA INSTALL BANNER ====================
    const InstallBanner = () => {
      const [deferredPrompt, setDeferredPrompt] = useState(null);
      const [showBanner, setShowBanner] = useState(false);
      const [dismissed, setDismissed] = useState(() => {
        return localStorage.getItem('snap_install_dismissed') === 'true';
      });

      useEffect(() => {
        // Check if already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
          return;
        }

        const handler = (e) => {
          e.preventDefault();
          setDeferredPrompt(e);
          if (!dismissed) {
            setShowBanner(true);
          }
        };

        window.addEventListener('beforeinstallprompt', handler);

        // Track successful installs
        window.addEventListener('appinstalled', () => {
          setShowBanner(false);
          setDeferredPrompt(null);
          console.log('App installed successfully');
        });

        return () => {
          window.removeEventListener('beforeinstallprompt', handler);
        };
      }, [dismissed]);

      const handleInstall = async () => {
        if (!deferredPrompt) return;

        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;

        if (outcome === 'accepted') {
          console.log('User accepted install');
        }
        setDeferredPrompt(null);
        setShowBanner(false);
      };

      const handleDismiss = () => {
        setShowBanner(false);
        setDismissed(true);
        localStorage.setItem('snap_install_dismissed', 'true');
      };

      if (!showBanner || !deferredPrompt) return null;

      return (
        <div
          className="fixed bottom-20 left-4 right-4 bg-marvel-blue rounded-lg p-4 shadow-lg z-40 panel-border install-banner-enter"
          role="complementary"
          aria-label="Install app prompt"
          style={{ marginBottom: 'env(safe-area-inset-bottom)' }}
        >
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 bg-marvel-red rounded-lg flex items-center justify-center flex-shrink-0">
              <span className="text-2xl">⚡</span>
            </div>
            <div className="flex-1 min-w-0">
              <h4 className="font-bold text-white text-sm">Install SnapPrime</h4>
              <p className="text-xs text-white/80 truncate">Add to home screen for quick access</p>
            </div>
            <button
              onClick={handleInstall}
              className="bg-marvel-gold text-black px-3 py-2 rounded font-bold text-sm hover:bg-yellow-400 flex-shrink-0"
            >
              Install
            </button>
            <button
              onClick={handleDismiss}
              className="text-white/60 p-2 hover:text-white flex-shrink-0"
              aria-label="Dismiss install prompt"
            >
              ✕
            </button>
          </div>
        </div>
      );
    };

    // ==================== MAIN APP ====================
    const App = () => {
      const [activeTab, setActiveTab] = useState('dashboard');
      const [collection, setCollection] = useState(() => loadFromStorage('snap_collection', { owned: [], lastUpdated: new Date().toISOString() }));
      const [matches, setMatches] = useState(() => loadFromStorage('snap_matches', []));
      const [decks, setDecks] = useState(() => loadFromStorage('snap_decks', []));
      const [settings, setSettings] = useState(() => loadFromStorage('snap_settings', { theme: 'dark' }));
      const [aiConfig, setAiConfig] = useState(() => loadFromStorage('snap_ai_config', {
        provider: '',
        model: '',
        apiKeys: {},
        googleToken: null,
        localEndpoint: 'http://localhost:11434'
      }));

      // Card data version - triggers re-render when uniqueCards updates
      const [cardDataVersion, setCardDataVersion] = useState(0);

      // Subscribe to uniqueCards updates to trigger re-renders
      useEffect(() => {
        const unsubscribe = onUniqueCardsUpdate((cards) => {
          setCardDataVersion(v => v + 1);
          console.log(`[App] Card data updated: ${cards.length} cards available`);
        });
        return unsubscribe;
      }, []);

      // Phase 4: URL Sync state
      const [syncImportData, setSyncImportData] = useState(null);
      const [showSyncConfirm, setShowSyncConfirm] = useState(false);

      useEffect(() => { saveToStorage('snap_collection', collection); }, [collection]);
      useEffect(() => { saveToStorage('snap_matches', matches); }, [matches]);
      useEffect(() => { saveToStorage('snap_decks', decks); }, [decks]);
      useEffect(() => { saveToStorage('snap_settings', settings); }, [settings]);
      useEffect(() => { saveToStorage('snap_ai_config', aiConfig); }, [aiConfig]);

      // Phase 4: Check for sync parameter in URL on load
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const syncData = params.get('sync');

        if (syncData) {
          try {
            const data = VaultManager.decompressFromQR(syncData);

            if (data && data.v === 1 && data.c) {
              setSyncImportData(data);
              setShowSyncConfirm(true);

              // Clean URL
              window.history.replaceState({}, '', window.location.pathname);
            }
          } catch (e) {
            console.error('Invalid sync data:', e);
          }
        }
      }, []);

      // Handle URL parameters for shortcuts and deep links
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const tab = params.get('tab');
        const action = params.get('action');

        if (tab && ['dashboard', 'ai', 'collection', 'decks', 'simulator', 'calculator', 'settings'].includes(tab)) {
          setActiveTab(tab);
        }

        if (action === 'quick-match') {
          // Could trigger quick match modal in the future
          setActiveTab('dashboard');
        }

        // Clean URL after handling (keep source param for analytics)
        if (tab || action) {
          const newUrl = window.location.pathname + (params.get('source') ? `?source=${params.get('source')}` : '');
          window.history.replaceState({}, '', newUrl);
        }
      }, []);

      const handleSyncImport = () => {
        if (syncImportData && syncImportData.c) {
          // Merge collections - add new cards without removing existing
          const existingOwned = new Set(collection.owned || []);
          syncImportData.c.forEach(card => existingOwned.add(card));

          setCollection({
            owned: Array.from(existingOwned),
            lastUpdated: new Date().toISOString()
          });

          setShowSyncConfirm(false);
          setSyncImportData(null);
          alert(`Synced ${syncImportData.c.length} cards to your collection!`);
        }
      };

      const handleQuickMatch = (result, cubes) => {
        setMatches(prev => [...prev, {
          id: generateId(),
          timestamp: new Date().toISOString(),
          result, cubes,
          opponent: '', deck: '', notes: '', snapped: 'NONE'
        }]);
      };

      useEffect(() => {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js')
            .then(reg => {
              console.log('SW registered:', reg.scope);

              // Check for updates immediately and periodically
              reg.update();

              // Listen for new service worker installing
              reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                console.log('[SW] New version found, installing...');

                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    // New SW installed and there's an existing one - new version available
                    console.log('[SW] New version installed, will reload...');
                    // Tell the new SW to take over immediately
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                  }
                });
              });
            })
            .catch(err => console.error('SW error:', err));

          // Reload page when new service worker takes control
          let refreshing = false;
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!refreshing) {
              refreshing = true;
              console.log('[SW] New version activated, reloading...');
              window.location.reload();
            }
          });
        }
      }, []);

      // Battery optimization - reduce animations when battery is low
      useEffect(() => {
        const checkBattery = async () => {
          if ('getBattery' in navigator) {
            try {
              const battery = await navigator.getBattery();

              const updatePowerMode = () => {
                const isLowPower = battery.level < 0.2 && !battery.charging;
                document.body.classList.toggle('low-power-mode', isLowPower);
              };

              updatePowerMode();
              battery.addEventListener('levelchange', updatePowerMode);
              battery.addEventListener('chargingchange', updatePowerMode);

              return () => {
                battery.removeEventListener('levelchange', updatePowerMode);
                battery.removeEventListener('chargingchange', updatePowerMode);
              };
            } catch (e) {
              console.log('Battery API not available');
            }
          }
        };

        // Low-end device detection
        const isLowEndDevice = () => {
          if (navigator.deviceMemory && navigator.deviceMemory < 4) return true;
          if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) return true;
          if (navigator.connection) {
            const { effectiveType, saveData } = navigator.connection;
            if (saveData || effectiveType === '2g' || effectiveType === 'slow-2g') return true;
          }
          return false;
        };

        if (isLowEndDevice()) {
          document.body.classList.add('low-end-mode');
        }

        checkBattery();
      }, []);

      // Android back button handling
      useEffect(() => {
        // Push initial state
        if (!window.history.state?.tab) {
          window.history.replaceState({ tab: activeTab }, '');
        }

        const handlePopState = (event) => {
          if (event.state?.tab) {
            setActiveTab(event.state.tab);
          } else if (activeTab !== 'dashboard') {
            // Navigate back to dashboard instead of closing app
            setActiveTab('dashboard');
            window.history.pushState({ tab: 'dashboard' }, '');
          }
        };

        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      // Push state when tab changes
      useEffect(() => {
        if (window.history.state?.tab !== activeTab) {
          window.history.pushState({ tab: activeTab }, '');
        }
      }, [activeTab]);


      return (
        <div className="min-h-screen bg-marvel-black">
          {/* Skip link for keyboard accessibility */}
          <a href="#main-content" className="sr-only focus:not-sr-only focus:absolute focus:top-0 focus:left-0 focus:z-50 focus:bg-marvel-red focus:text-white focus:px-4 focus:py-2 focus:font-medium">
            Skip to main content
          </a>
          <OfflineIndicator />
          <InstallBanner />
          <div id="main-content" tabIndex="-1">
            {activeTab === 'dashboard' && (
              <ErrorBoundary>
                <Dashboard collection={collection} matches={matches} onQuickMatch={handleQuickMatch} />
              </ErrorBoundary>
            )}
            {activeTab === 'ai' && (
              <ErrorBoundary>
                <AIChat collection={collection} matches={matches} aiConfig={aiConfig} setActiveTab={setActiveTab} />
              </ErrorBoundary>
            )}
            {activeTab === 'collection' && (
              <ErrorBoundary>
                <Collection collection={collection} setCollection={setCollection} />
              </ErrorBoundary>
            )}
            {activeTab === 'decks' && (
              <ErrorBoundary>
                <Decks decks={decks} setDecks={setDecks} collection={collection} />
              </ErrorBoundary>
            )}
            {activeTab === 'simulator' && (
              <ErrorBoundary>
                <Simulator decks={decks} collection={collection} />
              </ErrorBoundary>
            )}
            {activeTab === 'calculator' && (
              <ErrorBoundary>
                <Calculator />
              </ErrorBoundary>
            )}
            {activeTab === 'settings' && (
              <ErrorBoundary>
                <Settings settings={settings} setSettings={setSettings} collection={collection} matches={matches} setCollection={setCollection} setMatches={setMatches} aiConfig={aiConfig} setAiConfig={setAiConfig} decks={decks} setDecks={setDecks} />
              </ErrorBoundary>
            )}
          </div>
          <NavBar activeTab={activeTab} setActiveTab={setActiveTab} />

          {/* Phase 4: Sync Confirm Modal */}
          {showSyncConfirm && syncImportData && (
            <SyncConfirmModal
              syncData={syncImportData}
              onConfirm={handleSyncImport}
              onCancel={() => { setShowSyncConfirm(false); setSyncImportData(null); }}
            />
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
