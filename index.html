<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#ED1D24">
  <meta name="description" content="Marvel Snap AI Companion & Tracker - Track your collection, log matches, and get tactical advice">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SnapPrime">

  <title>Snapapoulous Prime - Marvel Snap Companion</title>

  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="assets/icons/icon-192.png">
  <link rel="apple-touch-icon" href="assets/icons/icon-192.png">

  <!-- Google Identity Services for OAuth -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- QR Code Generation -->
  <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>

  <!-- LZ-String for compression (QR sync) -->
  <script src="https://unpkg.com/lz-string@1.5.0/libs/lz-string.min.js"></script>

  <!-- Tailwind Config -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'marvel-red': '#ED1D24',
            'marvel-blue': '#006EC7',
            'marvel-gold': '#FFC107',
            'marvel-black': '#1A1A1A',
            'marvel-white': '#FFFFFF',
            'series-1': '#6B7280',
            'series-2': '#22C55E',
            'series-3': '#8B5CF6',
            'series-4': '#EAB308',
            'series-5': '#EF4444',
            'spotlight': '#F97316',
          },
          fontFamily: {
            'comic': ['Impact', 'Arial Black', 'sans-serif'],
          },
          boxShadow: {
            'comic': '4px 4px 0px #1A1A1A',
            'comic-sm': '2px 2px 0px #1A1A1A',
          }
        }
      }
    }
  </script>

  <style>
    * { -webkit-tap-highlight-color: transparent; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1A1A1A;
      color: #FFFFFF;
      min-height: 100vh;
      overflow-x: hidden;
    }
    .panel-border { border: 3px solid #1A1A1A; box-shadow: 4px 4px 0px #1A1A1A; }
    .halftone { background-image: radial-gradient(circle, rgba(0,0,0,0.1) 1px, transparent 1px); background-size: 8px 8px; }
    .card-hover { transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; }
    .card-hover:active { transform: scale(0.98); }
    .series-border-1 { border-color: #6B7280; }
    .series-border-2 { border-color: #22C55E; }
    .series-border-3 { border-color: #8B5CF6; }
    .series-border-4 { border-color: #EAB308; }
    .series-border-5 { border-color: #EF4444; }
    .series-border-spotlight { border-color: #F97316; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #2D2D2D; }
    ::-webkit-scrollbar-thumb { background: #ED1D24; border-radius: 4px; }
    .tab-active { position: relative; }
    .tab-active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 3px; background: #ED1D24; }
    input[type="range"] { -webkit-appearance: none; background: #2D2D2D; border-radius: 4px; height: 8px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #ED1D24; border-radius: 50%; cursor: pointer; border: 2px solid #FFC107; }
    @keyframes pulse-snap { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .pulse-snap { animation: pulse-snap 0.5s ease-in-out infinite; }
    @keyframes typing { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
    .typing-dot { animation: typing 1.4s infinite; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    .chat-bubble { border-radius: 1rem; }
    .chat-bubble-user { border-bottom-right-radius: 0.25rem; }
    .chat-bubble-ai { border-bottom-left-radius: 0.25rem; }
    /* Drop Zone Styling */
    .drop-zone {
      border: 3px dashed #006EC7;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      background: rgba(0, 110, 199, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .drop-zone:hover, .drop-zone.drag-over {
      border-color: #ED1D24;
      background: rgba(237, 29, 36, 0.1);
      transform: scale(1.02);
    }
    .drop-zone .drop-icon { font-size: 3rem; display: block; margin-bottom: 1rem; }
    .drop-zone .file-path {
      display: block;
      margin-top: 0.5rem;
      font-size: 0.7rem;
      color: #006EC7;
      font-family: monospace;
      opacity: 0.7;
    }
    /* Modal Overlay */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 1rem;
    }
    .modal {
      background: #2D2D2D;
      border-radius: 12px;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 3px solid #1A1A1A;
      box-shadow: 4px 4px 0px #1A1A1A;
    }
    /* Spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #2D2D2D;
      border-top-color: #ED1D24;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* QR Code Container */
    .qr-container { background: white; padding: 1rem; border-radius: 8px; display: inline-block; }

    /* Phase 5: Sync Section Styles */
    .pc-sync-section { margin: 0; }

    .sync-divider {
      display: flex;
      align-items: center;
      margin: 20px 0;
      color: #666;
    }
    .sync-divider::before,
    .sync-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #444;
    }
    .sync-divider span {
      padding: 0 16px;
      font-size: 0.9em;
    }

    /* Linked Folder Styles */
    .linked-folder-section {
      background: rgba(0, 110, 199, 0.1);
      border: 2px solid #006EC7;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .linked-folder-section h4 {
      margin: 0 0 8px 0;
      color: #006EC7;
      font-family: Impact, 'Arial Black', sans-serif;
    }
    .linked-folder-section .description {
      margin: 0 0 12px 0;
      color: #aaa;
      font-size: 0.85em;
    }
    .link-folder-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 1em;
      background: #006EC7;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    .link-folder-btn:hover { background: #0088ee; }
    .linked-status {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .status-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: bold;
    }
    .status-badge.linked {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }
    .unlink-btn {
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 0.85em;
    }
    .unlink-btn:hover {
      color: #ef4444;
      text-decoration: underline;
    }
    .sync-btn {
      padding: 12px 20px;
      font-size: 1em;
      background: #006EC7;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    .sync-btn:hover { background: #0088ee; }
    .sync-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .last-sync {
      margin: 0;
      font-size: 0.8em;
      color: #888;
      text-align: center;
    }
    .not-supported-msg {
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid #FFC107;
      border-radius: 8px;
      padding: 12px;
      font-size: 0.85em;
      color: #ccc;
    }

    /* Drag & Drop JSON Styles */
    .drag-drop-section h4 {
      margin: 0 0 4px 0;
      color: #aaa;
    }
    .drag-drop-section .description {
      margin: 0 0 12px 0;
      color: #666;
      font-size: 0.8em;
    }
    .drop-zone-json {
      border: 3px dashed #006EC7;
      border-radius: 12px;
      padding: 30px 20px;
      text-align: center;
      background: rgba(0, 110, 199, 0.05);
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .drop-zone-json:hover,
    .drop-zone-json.drag-over {
      border-color: #FFC107;
      background: rgba(255, 193, 7, 0.1);
    }
    .drop-zone-json code {
      background: #1A1A1A;
      color: #FFC107;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75em;
      word-break: break-all;
      display: block;
      margin-top: 8px;
    }

    /* Card Performance Styles */
    .performance-card {
      display: flex;
      align-items: center;
      padding: 10px 14px;
      border-radius: 8px;
      margin: 4px 0;
      background: rgba(255, 255, 255, 0.05);
    }
    .performance-card.positive { border-left: 4px solid #22c55e; }
    .performance-card.negative { border-left: 4px solid #ef4444; }
    .performance-card .rank {
      width: 36px;
      font-weight: bold;
      color: #FFC107;
      font-size: 0.9em;
    }
    .performance-card .card-name {
      flex: 1;
      font-size: 0.95em;
    }
    .performance-card .net-cubes {
      font-weight: bold;
      font-size: 1em;
    }
    .performance-card.positive .net-cubes { color: #22c55e; }
    .performance-card.negative .net-cubes { color: #ef4444; }

    /* Sync Preview Modal */
    .sync-preview-modal {
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .preview-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 14px;
      margin: 10px 0;
    }
    .import-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    .import-toggle input {
      width: 18px;
      height: 18px;
      accent-color: #ED1D24;
    }
    .preview-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    .preview-stat {
      text-align: center;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
    }
    .preview-stat .value {
      display: block;
      font-size: 1.3em;
      font-weight: bold;
      color: white;
    }
    .preview-stat .label {
      font-size: 0.75em;
      color: #888;
    }
    .card-performance-preview {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    .card-stat {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.85em;
    }
    .card-stat.positive { background: rgba(34, 197, 94, 0.15); }
    .card-stat.negative { background: rgba(239, 68, 68, 0.15); }
    .card-stat .cubes { font-weight: bold; }
    .card-stat.positive .cubes { color: #22c55e; }
    .card-stat.negative .cubes { color: #ef4444; }

    /* Performance Summary */
    .performance-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }
    .summary-stat {
      text-align: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
    }
    .summary-stat .label {
      display: block;
      font-size: 0.75em;
      color: #888;
      margin-bottom: 4px;
    }
    .summary-stat .value {
      font-size: 1.3em;
      font-weight: bold;
    }
    .summary-stat.positive .value { color: #22c55e; }
    .summary-stat.negative .value { color: #ef4444; }
    .summary-stat.net .value { color: #FFC107; }

    /* Stats Section Styling */
    .stats-section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .stats-section h3 {
      margin: 0 0 12px 0;
      font-size: 1em;
      color: #FFC107;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .stat-card {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
    }
    .stat-card .stat-value {
      display: block;
      font-size: 1.5em;
      font-weight: bold;
      color: white;
    }
    .stat-card .stat-label {
      font-size: 0.75em;
      color: #888;
    }
    .stat-card.highlight .stat-value { color: #FFC107; }
    .stat-card.positive .stat-value { color: #22c55e; }
    .stat-card.negative .stat-value { color: #ef4444; }
    .data-source {
      margin-top: 8px;
      font-size: 0.75em;
      color: #666;
      text-align: right;
    }
    .import-prompt {
      text-align: center;
      padding: 20px;
      color: #888;
    }
    .import-prompt a {
      color: #006EC7;
      text-decoration: underline;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      white-space: pre-line;
      max-width: 90%;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useRef } = React;

    // ==================== CONSTANTS ====================
    const GOOGLE_CLIENT_ID = '770573636629-tddodsck0vtmtqpdh7uj7dtevr07orn2.apps.googleusercontent.com';
    const GEMINI_SCOPES = 'https://www.googleapis.com/auth/generative-language.retriever';

    // ==================== GOOGLE OAUTH 2.0 HELPERS ====================
    let googleTokenClient = null;
    let pendingTokenResolve = null;
    let pendingTokenReject = null;

    // Initialize Google OAuth 2.0 Token Client
    const initGoogleOAuth = (callback) => {
      if (!window.google?.accounts?.oauth2) {
        console.log('Google OAuth2 library not loaded yet');
        return false;
      }

      googleTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GOOGLE_CLIENT_ID,
        scope: GEMINI_SCOPES,
        callback: (response) => {
          if (response.error) {
            console.error('Google OAuth error:', response.error);
            if (pendingTokenReject) {
              pendingTokenReject(new Error(response.error));
              pendingTokenReject = null;
              pendingTokenResolve = null;
            }
            return;
          }

          const expiresAt = Date.now() + (response.expires_in * 1000);
          localStorage.setItem('snap_google_access_token', response.access_token);
          localStorage.setItem('snap_google_token_expiry', expiresAt.toString());

          if (pendingTokenResolve) {
            pendingTokenResolve(response.access_token);
            pendingTokenResolve = null;
            pendingTokenReject = null;
          }

          if (callback) callback(response.access_token);
        },
        error_callback: (error) => {
          console.error('Google token error:', error);
          if (error.type !== 'popup_closed' && pendingTokenReject) {
            pendingTokenReject(new Error(error.message || error.type || 'Unknown error'));
            pendingTokenReject = null;
            pendingTokenResolve = null;
          }
        }
      });

      return true;
    };

    // Check if Google access token is valid
    const isGoogleTokenValid = () => {
      const token = localStorage.getItem('snap_google_access_token');
      const expiry = localStorage.getItem('snap_google_token_expiry');
      if (!token || !expiry) return false;
      return Date.now() < (parseInt(expiry) - 300000); // 5 min buffer
    };

    // Get Google access token (with auto-refresh)
    const getGoogleAccessToken = async () => {
      if (isGoogleTokenValid()) {
        return localStorage.getItem('snap_google_access_token');
      }

      // Need to get a new token
      return new Promise((resolve, reject) => {
        if (!googleTokenClient) {
          if (!initGoogleOAuth()) {
            reject(new Error('Google OAuth not initialized'));
            return;
          }
        }

        pendingTokenResolve = resolve;
        pendingTokenReject = reject;

        // Request new token - may show popup if consent needed
        googleTokenClient.requestAccessToken({ prompt: '' });
      });
    };

    // Request new Google access token (shows popup)
    const requestGoogleAccessToken = () => {
      return new Promise((resolve, reject) => {
        if (!googleTokenClient) {
          if (!initGoogleOAuth()) {
            reject(new Error('Google OAuth not initialized. Please refresh the page.'));
            return;
          }
        }

        pendingTokenResolve = resolve;
        pendingTokenReject = reject;

        googleTokenClient.requestAccessToken({ prompt: 'consent' });
      });
    };

    // Sign out from Google
    const signOutGoogle = () => {
      const token = localStorage.getItem('snap_google_access_token');
      if (token && window.google?.accounts?.oauth2) {
        google.accounts.oauth2.revoke(token, () => {
          console.log('Google token revoked');
        });
      }
      localStorage.removeItem('snap_google_access_token');
      localStorage.removeItem('snap_google_token_expiry');
    };

    // ==================== CARD DATA ====================
    const CARD_DATA = [
      { name: "Abomination", cost: 5, power: 9, series: 1, ability: "No ability." },
      { name: "Ant-Man", cost: 1, power: 1, series: 1, ability: "Ongoing: If your side of this location is full, +3 Power." },
      { name: "America Chavez", cost: 6, power: 9, series: 1, ability: "On Reveal: This always starts in your deck, and is drawn on turn 6." },
      { name: "Angela", cost: 2, power: 0, series: 1, ability: "When you play a card here, +2 Power." },
      { name: "Armor", cost: 2, power: 3, series: 1, ability: "Ongoing: Cards at this location can't be destroyed." },
      { name: "Bishop", cost: 3, power: 1, series: 1, ability: "When you play a card, +1 Power." },
      { name: "Blue Marvel", cost: 5, power: 3, series: 1, ability: "Ongoing: Your other cards have +1 Power." },
      { name: "Cable", cost: 2, power: 2, series: 1, ability: "On Reveal: Draw a card from your opponent's deck." },
      { name: "Captain America", cost: 3, power: 3, series: 1, ability: "Ongoing: Your other cards at this location have +1 Power." },
      { name: "Carnage", cost: 2, power: 2, series: 1, ability: "On Reveal: Destroy your other cards here. +2 Power for each destroyed." },
      { name: "Colossus", cost: 2, power: 3, series: 1, ability: "Ongoing: Can't be destroyed, moved, or have its Power reduced." },
      { name: "Cosmo", cost: 3, power: 3, series: 1, ability: "Ongoing: On Reveal abilities won't happen at this location." },
      { name: "Cyclops", cost: 3, power: 4, series: 1, ability: "No ability." },
      { name: "Deathlok", cost: 3, power: 5, series: 1, ability: "On Reveal: Destroy your other cards at this location." },
      { name: "Elektra", cost: 1, power: 2, series: 1, ability: "On Reveal: Destroy a random enemy 1-Cost card at this location." },
      { name: "Enchantress", cost: 4, power: 5, series: 1, ability: "On Reveal: Remove the abilities from all Ongoing cards at this location." },
      { name: "Forge", cost: 2, power: 1, series: 1, ability: "On Reveal: Give the next card you play +2 Power." },
      { name: "Gamora", cost: 5, power: 7, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +5 Power." },
      { name: "Groot", cost: 3, power: 3, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power." },
      { name: "Hawkeye", cost: 1, power: 1, series: 1, ability: "On Reveal: If you play a card here next turn, +3 Power." },
      { name: "Hulk", cost: 6, power: 12, series: 1, ability: "No ability." },
      { name: "Human Torch", cost: 1, power: 2, series: 1, ability: "When this moves to a location, double its Power." },
      { name: "Iron Fist", cost: 1, power: 2, series: 1, ability: "On Reveal: After you play your next card, move it one location to the left." },
      { name: "Iron Man", cost: 5, power: 0, series: 1, ability: "Ongoing: Your total Power is doubled at this location." },
      { name: "Jessica Jones", cost: 4, power: 4, series: 1, ability: "On Reveal: If you don't play a card here next turn, +4 Power." },
      { name: "Klaw", cost: 5, power: 4, series: 1, ability: "Ongoing: The location to the right has +6 Power." },
      { name: "Korg", cost: 1, power: 1, series: 1, ability: "On Reveal: Shuffle a Rock into your opponent's deck." },
      { name: "Lady Sif", cost: 3, power: 4, series: 1, ability: "On Reveal: Discard the highest-cost card from your hand." },
      { name: "Lizard", cost: 2, power: 5, series: 1, ability: "Ongoing: -3 Power if your opponent has 4 cards here." },
      { name: "Mantis", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, draw a card from their deck." },
      { name: "Medusa", cost: 2, power: 2, series: 1, ability: "On Reveal: If this is at the middle location, +3 Power." },
      { name: "Mister Fantastic", cost: 3, power: 2, series: 1, ability: "Ongoing: Adjacent locations have +2 Power." },
      { name: "Mister Sinister", cost: 2, power: 2, series: 1, ability: "On Reveal: Add a Sinister Clone to this location with the same Power." },
      { name: "Moon Girl", cost: 4, power: 4, series: 1, ability: "On Reveal: Duplicate your hand." },
      { name: "Morph", cost: 3, power: 0, series: 1, ability: "On Reveal: Become a copy of a random card in your opponent's hand." },
      { name: "Multiple Man", cost: 2, power: 3, series: 1, ability: "When this moves, add a copy to the old location." },
      { name: "Namor", cost: 4, power: 5, series: 1, ability: "Ongoing: +5 Power if this is your only card here." },
      { name: "Nightcrawler", cost: 1, power: 2, series: 1, ability: "You can move this once." },
      { name: "Nova", cost: 1, power: 1, series: 1, ability: "When this is destroyed, give your cards +1 Power." },
      { name: "Odin", cost: 6, power: 8, series: 1, ability: "On Reveal: Activate the On Reveal abilities of your other cards at this location." },
      { name: "Onslaught", cost: 6, power: 7, series: 1, ability: "Ongoing: Double your other Ongoing effects at this location." },
      { name: "Punisher", cost: 3, power: 2, series: 1, ability: "Ongoing: +1 Power for each enemy card at this location." },
      { name: "Rocket Raccoon", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +2 Power." },
      { name: "Scarlet Witch", cost: 2, power: 3, series: 1, ability: "On Reveal: Replace this location with a random location." },
      { name: "Sentinel", cost: 2, power: 3, series: 1, ability: "On Reveal: Add another Sentinel to your hand." },
      { name: "Spectrum", cost: 6, power: 5, series: 1, ability: "On Reveal: Give your Ongoing cards +2 Power." },
      { name: "Spider-Woman", cost: 5, power: 7, series: 1, ability: "On Reveal: Afflict all enemy cards here with -1 Power." },
      { name: "Squirrel Girl", cost: 1, power: 1, series: 1, ability: "On Reveal: Add a 1-Power Squirrel to each other location." },
      { name: "Star-Lord", cost: 2, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power." },
      { name: "Strong Guy", cost: 4, power: 4, series: 1, ability: "Ongoing: If your hand is empty, +6 Power." },
      { name: "Sword Master", cost: 3, power: 6, series: 1, ability: "On Reveal: Discard a card from your hand." },
      { name: "The Thing", cost: 4, power: 6, series: 1, ability: "No ability." },
      { name: "White Queen", cost: 4, power: 6, series: 1, ability: "On Reveal: Draw a copy of the highest-Cost card in your opponent's hand." },
      { name: "White Tiger", cost: 5, power: 1, series: 1, ability: "On Reveal: Add a 7-Power Tiger to another location." },
      { name: "Wolfsbane", cost: 3, power: 1, series: 1, ability: "On Reveal: +2 Power for each other card you have here." },
      { name: "Wolverine", cost: 2, power: 2, series: 1, ability: "When this is discarded or destroyed, regenerate it at a random location." },
      { name: "Yondu", cost: 1, power: 2, series: 1, ability: "On Reveal: Remove the top card of your opponent's deck." },
      { name: "Agent 13", cost: 1, power: 2, series: 2, ability: "On Reveal: Add a random card to your hand." },
      { name: "Bucky Barnes", cost: 2, power: 1, series: 2, ability: "When this is destroyed, create the Winter Soldier in its place." },
      { name: "Cloak", cost: 2, power: 4, series: 2, ability: "On Reveal: Next turn, both players can move cards to this location." },
      { name: "Ebony Maw", cost: 1, power: 7, series: 2, ability: "You can't play cards here after turn 3." },
      { name: "Hobgoblin", cost: 5, power: -8, series: 2, ability: "On Reveal: Switch sides." },
      { name: "Iceman", cost: 1, power: 2, series: 2, ability: "On Reveal: Give a random card in your opponent's hand +1 Cost." },
      { name: "Killmonger", cost: 3, power: 3, series: 2, ability: "On Reveal: Destroy ALL 1-Cost cards." },
      { name: "Leech", cost: 5, power: 3, series: 2, ability: "On Reveal: Remove the abilities from all cards in your opponent's hand." },
      { name: "Morbius", cost: 2, power: 0, series: 2, ability: "Ongoing: +2 Power for each card you've discarded this game." },
      { name: "Nakia", cost: 3, power: 3, series: 2, ability: "On Reveal: Give the 2 leftmost cards in your hand +2 Power." },
      { name: "Okoye", cost: 2, power: 2, series: 2, ability: "On Reveal: Give every card in your deck +1 Power." },
      { name: "Rhino", cost: 3, power: 3, series: 2, ability: "On Reveal: Remove the ability from this location." },
      { name: "Sabretooth", cost: 3, power: 4, series: 2, ability: "When this is destroyed, return it to your hand. It costs 0." },
      { name: "Sandman", cost: 5, power: 4, series: 2, ability: "Ongoing: Players can only play 1 card a turn." },
      { name: "Scorpion", cost: 2, power: 2, series: 2, ability: "On Reveal: Afflict cards in your opponent's hand with -1 Power." },
      { name: "Shang-Chi", cost: 4, power: 3, series: 2, ability: "On Reveal: Destroy all enemy cards at this location that have 9 or more Power." },
      { name: "Shocker", cost: 2, power: 3, series: 2, ability: "No ability." },
      { name: "Storm", cost: 3, power: 2, series: 2, ability: "On Reveal: Flood this location. Next turn it's destroyed." },
      { name: "Sunspot", cost: 1, power: 1, series: 2, ability: "At the end of each turn, gain +1 Power for each unspent Energy." },
      { name: "Swarm", cost: 2, power: 3, series: 2, ability: "When this is discarded, add two 0-cost copies to your hand." },
      { name: "The Collector", cost: 2, power: 2, series: 2, ability: "When a card enters your hand (except from your deck), +1 Power." },
      { name: "The Infinaut", cost: 6, power: 20, series: 2, ability: "If you played a card last turn, you can't play this." },
      { name: "Vulture", cost: 3, power: 3, series: 2, ability: "When a card moves away from here, +5 Power." },
      { name: "Warpath", cost: 4, power: 5, series: 2, ability: "Ongoing: If any of your locations are empty, +4 Power." },
      { name: "Absorbing Man", cost: 4, power: 4, series: 3, ability: "On Reveal: If the last card you played has an On Reveal, copy its ability." },
      { name: "Aero", cost: 5, power: 8, series: 3, ability: "On Reveal: Move all enemy cards played this turn to this location." },
      { name: "Black Panther", cost: 5, power: 4, series: 3, ability: "On Reveal: Double this card's Power." },
      { name: "Brood", cost: 3, power: 2, series: 3, ability: "On Reveal: Add 2 Broodlings to this location with the same Power." },
      { name: "Cerebro", cost: 3, power: 0, series: 3, ability: "Ongoing: Your highest Power cards get +2 Power." },
      { name: "Colleen Wing", cost: 2, power: 4, series: 3, ability: "On Reveal: Discard the lowest-cost card from your hand." },
      { name: "Darkhawk", cost: 4, power: 1, series: 3, ability: "Ongoing: +2 Power for each card in your opponent's deck." },
      { name: "Deadpool", cost: 1, power: 1, series: 3, ability: "When this is destroyed, return it to your hand with double the Power." },
      { name: "Death", cost: 9, power: 12, series: 3, ability: "Costs 1 less for each card destroyed this game." },
      { name: "Destroyer", cost: 6, power: 16, series: 3, ability: "On Reveal: Destroy your other cards." },
      { name: "Doctor Doom", cost: 6, power: 5, series: 3, ability: "On Reveal: Add a 5-Power Doombot to each other location." },
      { name: "Dracula", cost: 4, power: 0, series: 3, ability: "At the end of the game, discard a card from your hand. This has its Power." },
      { name: "Electro", cost: 3, power: 2, series: 3, ability: "On Reveal: +1 Max Energy. Ongoing: You can only play 1 card a turn." },
      { name: "Ghost Rider", cost: 4, power: 3, series: 3, ability: "On Reveal: Bring back one of your discarded cards to this location." },
      { name: "Hela", cost: 6, power: 6, series: 3, ability: "On Reveal: Play all cards you discarded from your hand to random locations." },
      { name: "Hit-Monkey", cost: 3, power: 2, series: 3, ability: "On Reveal: Gain +2 Power for each other card you played this turn." },
      { name: "Jane Foster", cost: 5, power: 8, series: 3, ability: "On Reveal: Draw all cards that cost 0 from your deck." },
      { name: "Jeff", cost: 2, power: 3, series: 3, ability: "You can move this once. Nothing can stop you from moving or playing this." },
      { name: "Knull", cost: 6, power: 0, series: 3, ability: "Ongoing: Has the combined Power of all cards destroyed this game." },
      { name: "Leader", cost: 6, power: 4, series: 3, ability: "On Reveal: Copy all cards your opponent played this turn, but on your side." },
      { name: "Lockjaw", cost: 3, power: 2, series: 3, ability: "When you play a card here, swap it with a card from your deck." },
      { name: "Luke Cage", cost: 2, power: 1, series: 3, ability: "Ongoing: Your cards can't have their Power reduced." },
      { name: "Magik", cost: 5, power: 3, series: 3, ability: "On Reveal: Change this location to 'Limbo'." },
      { name: "Magneto", cost: 6, power: 12, series: 3, ability: "On Reveal: Move all opposing 3 and 4-Cost cards to this location." },
      { name: "Mystique", cost: 3, power: 0, series: 3, ability: "On Reveal: If the last card you played has an Ongoing ability, this card gains it." },
      { name: "Patriot", cost: 3, power: 1, series: 3, ability: "Ongoing: Your cards with no abilities have +2 Power." },
      { name: "Sera", cost: 5, power: 4, series: 3, ability: "Ongoing: Cards in your hand cost 1 less. (minimum 1)" },
      { name: "She-Hulk", cost: 6, power: 10, series: 3, ability: "Costs 1 less for each unspent Energy last turn." },
      { name: "Silver Surfer", cost: 3, power: 0, series: 3, ability: "On Reveal: Give your other 3-Cost cards +3 Power." },
      { name: "Spider-Man", cost: 4, power: 3, series: 3, ability: "On Reveal: Your opponent can't play cards at this location next turn." },
      { name: "Ultron", cost: 6, power: 8, series: 3, ability: "On Reveal: Create 4 Drones at each other location." },
      { name: "Venom", cost: 3, power: 1, series: 3, ability: "On Reveal: Destroy your other cards at this location. Add their Power to this card." },
      { name: "Vision", cost: 5, power: 7, series: 3, ability: "You can move this each turn." },
      { name: "Wave", cost: 3, power: 3, series: 3, ability: "On Reveal: All cards cost 4 until the end of next turn." },
      { name: "Wong", cost: 4, power: 2, series: 3, ability: "Ongoing: Your On Reveal abilities at this location happen twice." },
      { name: "Zabu", cost: 3, power: 2, series: 3, ability: "Ongoing: Your 4-Cost cards cost 2 less. (minimum 1)" },
      { name: "Zero", cost: 1, power: 3, series: 3, ability: "On Reveal: Remove the abilities on the next card you play." },
      { name: "Galactus", cost: 6, power: 3, series: 4, ability: "On Reveal: If this is your only card here, destroy all other locations." },
      { name: "High Evolutionary", cost: 4, power: 4, series: 4, ability: "At the start of the game, unlock the abilities of your cards with no abilities." },
      { name: "Shuri", cost: 4, power: 2, series: 4, ability: "On Reveal: Double the Power of the next card you play." },
      { name: "Thanos", cost: 6, power: 8, series: 4, ability: "At the start of the game, shuffle the six Infinity Stones into your deck." },
      { name: "Annihilus", cost: 5, power: 8, series: 4, ability: "On Reveal: Cards with negative Power switch sides. Then, destroy those cards." },
      { name: "Attuma", cost: 4, power: 10, series: 4, ability: "At the end of each turn, if you have another card here, destroy this." },
      { name: "Black Cat", cost: 3, power: 6, series: 4, ability: "If this is in your hand at the end of the turn, discard it." },
      { name: "Elsa Bloodstone", cost: 2, power: 3, series: 4, ability: "After a card enters your hand (not from your deck), give it +2 Power." },
      { name: "Ghost Spider", cost: 1, power: 2, series: 4, ability: "After you play a card here, move one of your other cards from here to another location." },
      { name: "M'Baku", cost: 1, power: 2, series: 4, ability: "At the end of the game, if this is in your deck, it jumps out." },
      { name: "Maria Hill", cost: 2, power: 3, series: 4, ability: "On Reveal: Add a 1-Cost card to your hand." },
      { name: "Mirage", cost: 2, power: 2, series: 4, ability: "On Reveal: Copy the text from a random card in your opponent's hand." },
      { name: "Nick Fury", cost: 4, power: 6, series: 4, ability: "On Reveal: Add 3 random 6-Cost cards to your hand." },
      { name: "Omega Red", cost: 4, power: 5, series: 4, ability: "Ongoing: If you're winning here, +4 Power to other locations." },
      { name: "Orka", cost: 6, power: 11, series: 4, ability: "Ongoing: If this is your only card here, +5 Power." },
      { name: "Sauron", cost: 3, power: 3, series: 4, ability: "On Reveal: Remove the abilities from all Ongoing cards in your hand and deck." },
      { name: "Shanna", cost: 4, power: 2, series: 4, ability: "On Reveal: Add a random 1-Cost card to each location." },
      { name: "Spider-Ham", cost: 1, power: 1, series: 4, ability: "On Reveal: Transform the highest-Cost card in your opponent's hand into a Pig." },
      { name: "Super Skrull", cost: 4, power: 2, series: 4, ability: "Ongoing: Has the Ongoing abilities of all enemy cards." },
      { name: "Titania", cost: 1, power: 5, series: 4, ability: "When any card is played at this location, this switches sides." },
      { name: "Agony", cost: 1, power: 3, series: 4, ability: "When you play a card here, merge this into it." },
      { name: "Misery", cost: 4, power: 6, series: 4, ability: "On Reveal: Repeat the On Reveal of your other cards here, then destroy them." },
      { name: "Negasonic Teenage Warhead", cost: 3, power: 4, series: 4, ability: "After an enemy card is played here, destroy it and this." },
      { name: "Stegron", cost: 4, power: 5, series: 4, ability: "On Reveal: Move an enemy card from here to another location." },
      { name: "Kang", cost: 5, power: 0, series: 5, ability: "On Reveal: Look at what your opponent did, then restart the turn." },
      { name: "Adam Warlock", cost: 2, power: 0, series: 3, ability: "At the end of each turn, if you're winning here, draw a card." },
      { name: "Agent Coulson", cost: 3, power: 4, series: 3, ability: "On Reveal: Add a random 4-Cost and 5-Cost card to your hand." },
      { name: "Arnim Zola", cost: 6, power: 0, series: 3, ability: "On Reveal: Destroy a random friendly card here. Add copies to other locations." },
      { name: "Baron Mordo", cost: 2, power: 3, series: 3, ability: "On Reveal: Your opponent draws a card. Set its Cost to 6." },
      { name: "Black Bolt", cost: 5, power: 7, series: 3, ability: "On Reveal: Your opponent must discard the lowest-Cost card from their hand." },
      { name: "Beast", cost: 2, power: 2, series: 3, ability: "On Reveal: Return your other cards at this location to your hand. They cost 1 less." },
      { name: "Blade", cost: 1, power: 3, series: 3, ability: "On Reveal: Discard a card from your hand." },
      { name: "Captain Marvel", cost: 4, power: 6, series: 3, ability: "At the end of the game, move to a location that wins you the game." },
      { name: "Crystal", cost: 3, power: 3, series: 3, ability: "On Reveal: If this is at the middle location, shuffle your hand into your deck and draw 3 cards." },
      { name: "Dagger", cost: 2, power: 1, series: 3, ability: "When this moves to a location, +3 Power for each card your opponent has there." },
      { name: "Doc Ock", cost: 5, power: 10, series: 3, ability: "On Reveal: Pull 4 random cards from your opponent's hand to their side of this location." },
      { name: "Goose", cost: 2, power: 2, series: 3, ability: "Ongoing: Nobody can play cards that cost 4, 5, or 6 at this location." },
      { name: "Green Goblin", cost: 3, power: -3, series: 3, ability: "On Reveal: Switch sides." },
      { name: "Hell Cow", cost: 4, power: 6, series: 3, ability: "On Reveal: Discard 2 cards from your hand." },
      { name: "Invisible Woman", cost: 2, power: 2, series: 3, ability: "Ongoing: Cards you play here are not revealed until the game ends." },
      { name: "Kingpin", cost: 3, power: 4, series: 3, ability: "When a card moves here on turn 6, destroy it." },
      { name: "Maximus", cost: 3, power: 7, series: 3, ability: "On Reveal: Your opponent draws 2 cards." },
      { name: "Mojo", cost: 2, power: 2, series: 3, ability: "Ongoing: If both players have 4 cards at this location, +6 Power." },
      { name: "Mole Man", cost: 4, power: 6, series: 3, ability: "On Reveal: Draw a Rock to your hand." },
      { name: "Moon Knight", cost: 3, power: 3, series: 3, ability: "On Reveal: Discard a card from each player's hand." },
      { name: "Mysterio", cost: 2, power: 4, series: 3, ability: "As you play this, play Illusions to other locations. Disguised as Mysterios." },
      { name: "Nebula", cost: 1, power: 2, series: 3, ability: "Each turn your opponent doesn't play a card here, +2 Power." },
      { name: "Polaris", cost: 3, power: 5, series: 3, ability: "On Reveal: Move an enemy 1 or 2-Cost card to this location." },
      { name: "Quinjet", cost: 1, power: 2, series: 3, ability: "Ongoing: Cards that didn't start in your deck cost 1 less." },
      { name: "Rescue", cost: 4, power: 5, series: 3, ability: "On Reveal: If you play a card here next turn, +5 Power." },
      { name: "Rock Slide", cost: 4, power: 6, series: 3, ability: "On Reveal: Shuffle 2 Rocks into your opponent's deck." },
      { name: "Rogue", cost: 3, power: 1, series: 3, ability: "On Reveal: Steal the text from an enemy Ongoing card here." },
      { name: "Ronan", cost: 5, power: 3, series: 3, ability: "Ongoing: +2 Power for each card in your opponent's hand." },
      { name: "Thor", cost: 4, power: 4, series: 3, ability: "On Reveal: Shuffle Mjolnir into your deck." },
      { name: "Typhoid Mary", cost: 4, power: 10, series: 3, ability: "Ongoing: Your other cards have -1 Power." },
      { name: "Wasp", cost: 0, power: 1, series: 3, ability: "No ability." },
      { name: "Yellow Jacket", cost: 0, power: 2, series: 3, ability: "On Reveal: Afflict your other cards at this location with -1 Power." },
      { name: "Alioth", cost: 6, power: 5, series: 5, ability: "On Reveal: Remove the abilities from all unrevealed enemy cards here." },
      { name: "Mobius M. Mobius", cost: 3, power: 3, series: 5, ability: "Ongoing: Your cards can't cost more. Your opponent's cards can't cost less." },
      { name: "Loki", cost: 4, power: 5, series: 5, ability: "On Reveal: Replace your hand with cards from your opponent's deck. Give them -1 Cost." },
      { name: "Blob", cost: 6, power: 0, series: 5, ability: "On Reveal: Merge your deck into this. Ongoing: Can't be moved." },
      { name: "The Living Tribunal", cost: 6, power: 9, series: 5, ability: "Ongoing: Split your total Power evenly among all locations." },
      { name: "Werewolf By Night", cost: 4, power: 1, series: 5, ability: "After you play a card, move there and +2 Power for each card on your side." },
      { name: "Phoenix Force", cost: 4, power: 5, series: 5, ability: "On Reveal: Revive one of your destroyed cards, then merge with it." },
      { name: "Silk", cost: 2, power: 5, series: 3, ability: "When any card is played at this location, this moves away from there." },
      { name: "Miles Morales", cost: 1, power: 5, series: 3, ability: "If a card moved last turn, this costs 1 less." },
      { name: "Ghost", cost: 1, power: 2, series: 3, ability: "Ongoing: Your cards are always revealed last." },
      { name: "Hazmat", cost: 2, power: 1, series: 3, ability: "On Reveal: Afflict all other cards with -1 Power." },
      { name: "Black Knight", cost: 1, power: 2, series: 3, ability: "After you discard a card, add the Ebony Blade to your hand." },
      { name: "Hellcow", cost: 4, power: 6, series: 3, ability: "On Reveal: Discard 2 cards from your hand." },
      { name: "Juggernaut", cost: 3, power: 3, series: 3, ability: "On Reveal: Move all enemy cards here away. (move order based on card play order)" },
      { name: "Falcon", cost: 2, power: 3, series: 3, ability: "On Reveal: Return your 1-Cost cards to your hand." },
      { name: "Heimdall", cost: 6, power: 8, series: 3, ability: "On Reveal: Move your other cards one location to the left." },
      { name: "Kitty Pryde", cost: 1, power: 0, series: 5, ability: "When this returns to your hand, +2 Power. Returns at the start of each turn." },
      { name: "Cannonball", cost: 5, power: 7, series: 5, ability: "On Reveal: Move away enemy cards that have less Power than this." },
      { name: "Black Swan", cost: 2, power: 3, series: 5, ability: "On Reveal: Until the end of next turn, your 1-Cost cards cost 0." },
      { name: "Hope Summers", cost: 3, power: 2, series: 5, ability: "After you play a card here, you get +1 Energy next turn." },
      { name: "Ms. Marvel", cost: 4, power: 4, series: 5, ability: "Ongoing: Your adjacent locations where you play only one card each have +5 Power." },
      { name: "Silk", cost: 2, power: 5, series: 3, ability: "When any card is played at this location, this moves away from there." },
      { name: "Gwenpool", cost: 2, power: 2, series: 5, ability: "On Reveal: Merge top deck card into this. On Reveal abilities activate." },
      { name: "Nico Minoru", cost: 1, power: 2, series: 5, ability: "On Reveal: After you play your next card, shuffle spells into your deck." },
      { name: "Mockingbird", cost: 2, power: 5, series: 5, ability: "Costs 1 less for each card you've moved." },
      { name: "Daken", cost: 3, power: 4, series: 5, ability: "On Reveal: Add the Muramasa Shard to your hand." },
      { name: "X-23", cost: 1, power: 2, series: 5, ability: "When this is destroyed, add a copy to a random location and your hand." },
      { name: "Nocturne", cost: 1, power: 3, series: 5, ability: "After turn 4, you can move this once. On Reveal: Transform this location." },
      { name: "Red Hulk", cost: 6, power: 10, series: 5, ability: "Costs 1 less for each unspent Energy at the end of your turn." },
      { name: "Howard the Duck", cost: 1, power: 2, series: 5, ability: "Ongoing: You can see the top card of your deck." },
      { name: "Bast", cost: 1, power: 1, series: 5, ability: "On Reveal: Set the Power of all cards in your hand to 3." },
      { name: "Jean Grey", cost: 3, power: 3, series: 5, ability: "Ongoing: Your opponent must play their first card each turn here." },
      { name: "Sebastian Shaw", cost: 4, power: 4, series: 5, ability: "When your cards are destroyed, +2 Power." },
      { name: "Dazzler", cost: 4, power: 4, series: 5, ability: "Ongoing: +2 Power for each location you have 4 cards at." },
      { name: "Iron Lad", cost: 4, power: 6, series: 5, ability: "On Reveal: Copy the text of your deck's top card." },
      { name: "Nimrod", cost: 5, power: 5, series: 5, ability: "When this is destroyed, add a copy to each other location." },
      { name: "Valkyrie", cost: 5, power: 3, series: 5, ability: "On Reveal: Set ALL cards at this location to 3 Power." },
      { name: "Lady Deathstrike", cost: 5, power: 4, series: 5, ability: "On Reveal: Destroy cards here with less Power than this." },
      { name: "Copycat", cost: 3, power: 4, series: 5, ability: "On Reveal: Steal the text from your opponent's deck's bottom card." },
      { name: "Grand Master", cost: 2, power: 0, series: 5, ability: "On Reveal: Move another card to this location, then activate its On Reveal." },
      { name: "Gladiator", cost: 3, power: 8, series: 5, ability: "On Reveal: If your opponent has more cards here than you, afflict this with -6 Power." },
      { name: "Snowguard", cost: 1, power: 2, series: 5, ability: "Has +5 Power if you played the effect matching this location's zone last turn." },
      { name: "Ajax", cost: 2, power: 1, series: 5, ability: "Ongoing: +2 Power for each afflicted card anywhere." },
      { name: "Surtur", cost: 3, power: 3, series: 5, ability: "Game Start: Give your Demons +3 Power." },
      { name: "Ravonna Renslayer", cost: 2, power: 3, series: 5, ability: "Ongoing: Your cards with 1 or less Power cost 1 less." },
      { name: "Selene", cost: 2, power: 2, series: 5, ability: "On Reveal: Give cards in your hand with negative Power +5 Power." },
      { name: "Caiera", cost: 3, power: 4, series: 5, ability: "Ongoing: Your 6-Cost cards can't be destroyed." },
      { name: "Hercules", cost: 4, power: 7, series: 5, ability: "At the end of turn 7, move to a location that wins you the game." },
      { name: "Frigga", cost: 5, power: 6, series: 5, ability: "On Reveal: Choose one of 3 cards to draw." },
      { name: "Gilgamesh", cost: 5, power: 9, series: 5, ability: "Ongoing: Your other cards here with increased Power have +2 Power." },
      { name: "Malekith", cost: 5, power: 7, series: 5, ability: "On Reveal: Give +2 Power to your cards that moved from here this game." },
      { name: "Wiccan", cost: 4, power: 7, series: 5, ability: "On Reveal: If you spent all your Energy last turn, gain +2 Max Energy this turn." },
      { name: "Sage", cost: 3, power: 0, series: 5, ability: "On Reveal: +2 Power for each different card Cost among your other cards here." },
      { name: "Emperor Hulkling", cost: 6, power: 11, series: 5, ability: "Game Start: Become a random card with +1 Cost and +2 Power." },
      { name: "Man-Thing", cost: 4, power: 5, series: 5, ability: "On Reveal: Afflict each card played here next turn with -2 Power." },
      { name: "Arcade", cost: 3, power: 3, series: 5, ability: "On Reveal: Shuffle the lowest-Power enemy card here into their deck." },
      { name: "Cassandra Nova", cost: 4, power: 4, series: 5, ability: "On Reveal: Afflict cards in your opponent's deck with -1 Power." },
      { name: "Scarlet Spider", cost: 4, power: 5, series: 5, ability: "When this moves, add a clone with its Power and abilities to the old location." },
      { name: "Toxin", cost: 2, power: 1, series: 5, ability: "After each turn, return this to your hand and +1 Power." },
      { name: "Cull Obsidian", cost: 4, power: 10, series: 5, ability: "Can only be played at locations where you have a card." },
      { name: "Scorn", cost: 1, power: 2, series: 5, ability: "When you discard this, return it to your hand with +2 Power." },
      { name: "Phastos", cost: 3, power: 4, series: 5, ability: "On Reveal: Give each card in your hand a random Ability." },
      { name: "MODOK", cost: 5, power: 8, series: 5, ability: "On Reveal: Discard your hand." },
      { name: "Martyr", cost: 4, power: 6, series: 5, ability: "On Reveal: All cards here lose their abilities." },
      { name: "Echo", cost: 1, power: 2, series: 5, ability: "Ongoing: Negate the Ongoing abilities of the first enemy card played here." },
      { name: "Shadow King", cost: 4, power: 3, series: 5, ability: "On Reveal: Set all cards here to their base Power." },
      { name: "High Evolutionary", cost: 4, power: 4, series: 4, ability: "Game Start: Unlock the abilities of your cards with no abilities." },
      { name: "Thena", cost: 2, power: 1, series: 5, ability: "After each card is played, +2 Power." },
      { name: "Loki", cost: 4, power: 5, series: 5, ability: "On Reveal: Replace your hand with cards from your opponent's deck, give them -1 Cost." },
      { name: "Pixie", cost: 2, power: 1, series: 5, ability: "On Reveal: Shuffle your deck. Swap Costs of each card with one drawn." },
      { name: "Corvus Glaive", cost: 3, power: 3, series: 5, ability: "Game Start: If Proxima Midnight is in your deck, they give each other +2 Power." },
      { name: "Proxima Midnight", cost: 1, power: 2, series: 5, ability: "On Reveal: You can't play cards at this location next turn." },
      { name: "Silver Sable", cost: 2, power: 4, series: 5, ability: "On Reveal: Steal 2 Power from the top card of your opponent's deck." },
      { name: "Shou-Lao", cost: 4, power: 4, series: 5, ability: "On Reveal: Add an Iron Fist to your hand that adds a copy of this to your deck." },
      { name: "Iron Fist's Return", cost: 2, power: 2, series: 5, ability: "On Reveal: Add a Shou-Lao to your deck with doubled Power." },
      { name: "Agent Venom", cost: 2, power: 5, series: 5, ability: "On Reveal: Set the Power of all cards in your deck to 3." },
      { name: "Hulkbuster", cost: 2, power: 4, series: 3, ability: "On Reveal: Merge this card with a random card at this location." },
      { name: "Kate Bishop", cost: 1, power: 2, series: 5, ability: "On Reveal: Add 2 different Arrows to your hand." },
      { name: "Stature", cost: 4, power: 7, series: 5, ability: "Costs 1 if your opponent discarded a card from their hand this game." },
      { name: "Sentry", cost: 4, power: 10, series: 3, ability: "On Reveal: Add a -10 Power Void to the right location." },
      { name: "Shang-Chi", cost: 4, power: 3, series: 2, ability: "On Reveal: Destroy all enemy cards at this location that have 9 or more Power." },
      { name: "Luke Cage", cost: 2, power: 1, series: 3, ability: "Ongoing: Your cards can't have their Power reduced." },
      { name: "Cosmo", cost: 3, power: 3, series: 1, ability: "Ongoing: On Reveal abilities won't happen at this location." },
      { name: "Armor", cost: 2, power: 3, series: 1, ability: "Ongoing: Cards at this location can't be destroyed." }
    ];

    // Merge embedded cards with any cached cards from API
    const getCachedCards = () => {
      try {
        const cached = localStorage.getItem('snap_card_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          // Use cache if less than 7 days old
          if (Date.now() - timestamp < 7 * 24 * 60 * 60 * 1000 && data?.length > 0) {
            return data;
          }
        }
      } catch (e) { console.log('Cache read error:', e); }
      return [];
    };

    const uniqueCards = (() => {
      const cachedCards = getCachedCards();
      const baseCards = cachedCards.length > CARD_DATA.length ? cachedCards : CARD_DATA;
      // Dedupe by name
      return baseCards.reduce((acc, card) => {
        if (!acc.find(c => c.name === card.name)) acc.push(card);
        return acc;
      }, []);
    })();

    // ==================== SNAPAPOULOUS PERSONA ====================
    const SNAPAPOULOUS_PERSONA = {
      name: "Snapapoulous",
      role: "Marvel Snap Tactical Advisor",
      personality: {
        tone: "Confident, knowledgeable, encouraging",
        style: "Direct tactical guidance with clear reasoning",
        voice: "Like a seasoned hero mentoring a new Avenger"
      },
      expertise: [
        "Deck building and optimization",
        "Meta analysis and counter-strategies",
        "Probability and statistics",
        "Snap/retreat decision making",
        "Card synergies and combos"
      ],
      principles: [
        "The 8-Cube Mandate: Play for high-value wins when the odds favor you",
        "Retreat is not defeat: Preserving cubes is a winning strategy",
        "Adapt or fall: The meta shifts constantly, flexibility is power",
        "Know your outs: Always calculate the probability before snapping"
      ]
    };

    // ==================== AI PROVIDER MANAGER ====================
    const AIProviders = {
      'gemini-oauth': {
        id: 'gemini-oauth',
        name: 'Google (Gemini)',
        description: 'Sign in with Google - easiest option',
        authType: 'oauth',
        models: ['gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3-flash-preview', 'gemini-3-pro-preview', 'gemini-2.5-flash-lite'],
        defaultModel: 'gemini-2.5-flash',
        primary: true
      },
      'gemini': {
        id: 'gemini',
        name: 'Gemini (API Key)',
        description: 'Use your own Gemini API key',
        authType: 'api_key',
        models: ['gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3-flash-preview', 'gemini-3-pro-preview', 'gemini-2.5-flash-lite'],
        defaultModel: 'gemini-2.5-flash'
      },
      'groq': {
        id: 'groq',
        name: 'Groq',
        description: 'Fast inference, free tier available',
        authType: 'api_key',
        models: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
        defaultModel: 'llama-3.3-70b-versatile'
      },
      'claude': {
        id: 'claude',
        name: 'Claude (Anthropic)',
        description: 'Premium AI assistant',
        authType: 'api_key',
        models: ['claude-sonnet-4-20250514', 'claude-haiku-4-5-20251001'],
        defaultModel: 'claude-sonnet-4-20250514'
      },
      'openai': {
        id: 'openai',
        name: 'OpenAI (GPT)',
        description: 'ChatGPT models',
        authType: 'api_key',
        models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo'],
        defaultModel: 'gpt-4o-mini'
      },
      'local': {
        id: 'local',
        name: 'Local Models',
        description: 'Ollama, LM Studio, vLLM, or any OpenAI-compatible endpoint',
        authType: 'none',
        models: [],
        defaultModel: '',
        advanced: true
      }
    };

    // Build system prompt with user context
    const buildSystemPrompt = (collection, matches) => {
      const totalWins = matches.filter(m => m.result === 'WIN').length;
      const totalGames = matches.length;
      const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      return `You are ${SNAPAPOULOUS_PERSONA.name}, a ${SNAPAPOULOUS_PERSONA.role}.

PERSONALITY:
- Tone: ${SNAPAPOULOUS_PERSONA.personality.tone}
- Style: ${SNAPAPOULOUS_PERSONA.personality.style}
- Voice: ${SNAPAPOULOUS_PERSONA.personality.voice}

YOUR EXPERTISE:
${SNAPAPOULOUS_PERSONA.expertise.map(e => `- ${e}`).join('\n')}

GUIDING PRINCIPLES:
${SNAPAPOULOUS_PERSONA.principles.map(p => `- ${p}`).join('\n')}

USER CONTEXT:
- Collection: ${collection.owned.length} cards owned out of ~250 total
- Total Games Played: ${totalGames}
- Win Rate: ${winRate}%
- Net Cubes: ${netCubes >= 0 ? '+' : ''}${netCubes}

CURRENT META (January 2026):
- Top Archetypes: Destroy, Bounce, High Evo, Discard, Move
- Strong Cards: Knull, Death, Angela, Hit-Monkey, Silver Surfer

Respond with practical, actionable Marvel Snap advice. Be concise but thorough. Reference Marvel lore when relevant. Use card game terminology naturally.`;
    };

    // API call functions for each provider
    const callGeminiOAuth = async (messages, model) => {
      // Get access token (will refresh if expired)
      const accessToken = await getGoogleAccessToken();

      if (!accessToken) {
        throw new Error('Not signed in to Google. Please sign in first.');
      }

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            contents: messages.map(m => ({
              role: m.role === 'assistant' ? 'model' : 'user',
              parts: [{ text: m.content }]
            })),
            generationConfig: {
              maxOutputTokens: 1024,
              temperature: 0.7
            }
          })
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        if (response.status === 401) {
          // Token invalid - clear it
          localStorage.removeItem('snap_google_access_token');
          localStorage.removeItem('snap_google_token_expiry');
          throw new Error('Google session expired. Please sign in again.');
        }

        throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
      }

      const data = await response.json();

      if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
        throw new Error('Invalid response from Gemini API');
      }

      return data.candidates[0].content.parts[0].text;
    };

    const callGeminiAPIKey = async (messages, model, apiKey) => {
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: messages.map(m => ({
              role: m.role === 'assistant' ? 'model' : 'user',
              parts: [{ text: m.content }]
            }))
          })
        }
      );
      if (!response.ok) throw new Error(`Gemini API error: ${response.status}`);
      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    };

    const callGroq = async (messages, model, apiKey) => {
      const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 1024 })
      });
      if (!response.ok) throw new Error(`Groq error: ${response.status}`);
      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response';
    };

    const callClaude = async (messages, model, apiKey) => {
      const systemMsg = messages.find(m => m.role === 'system');
      const otherMsgs = messages.filter(m => m.role !== 'system');

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'Content-Type': 'application/json',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model,
          max_tokens: 1024,
          system: systemMsg?.content || '',
          messages: otherMsgs
        })
      });
      if (!response.ok) throw new Error(`Claude error: ${response.status}`);
      const data = await response.json();
      return data.content?.[0]?.text || 'No response';
    };

    const callOpenAI = async (messages, model, apiKey) => {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 1024 })
      });
      if (!response.ok) throw new Error(`OpenAI error: ${response.status}`);
      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response';
    };

    const callLocal = async (messages, model, endpoint) => {
      const response = await fetch(`${endpoint}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model, messages, stream: false })
      });
      if (!response.ok) throw new Error(`Local error: ${response.status}`);
      const data = await response.json();
      return data.message?.content || 'No response';
    };

    // ==================== LOG PARSER ====================
    const LogParser = {
      parsePlayerLog(logContent) {
        const matches = [];
        const lines = logContent.split('\n');

        let currentTimestamp = null;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Extract timestamp if present
          const tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\]/);
          if (tsMatch) {
            currentTimestamp = tsMatch[1];
          }

          // Look for game result patterns in the log
          if (line.includes('GameResult') || line.includes('MatchComplete') ||
              line.includes('BattleResult') || line.includes('GameOutcome') ||
              line.includes('"Result"') || line.includes('CubesDelta')) {
            try {
              // Try to find JSON object in the line
              const jsonMatch = line.match(/\{[^{}]*\}/);
              if (jsonMatch) {
                const data = JSON.parse(jsonMatch[0]);

                const result = this.normalizeResult(data.Result || data.GameOutcome || data.Outcome);
                const cubes = parseInt(data.CubesDelta || data.Cubes || data.cubes || 0);

                if (result && cubes !== 0) {
                  matches.push({
                    id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                    timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                    result: result,
                    cubes: Math.abs(cubes),
                    deckId: data.DeckId || data.DeckName || null,
                    opponent: data.OpponentName || null,
                    snapped: this.parseSnapState(data),
                    source: 'log_import',
                    notes: ''
                  });
                }
              }
            } catch (e) {
              // Not valid JSON, continue scanning
            }
          }

          // Alternative pattern: look for win/loss with cube values
          const simpleMatch = line.match(/(WIN|LOSS|VICTORY|DEFEAT|RETREAT)[^\d]*(\d+)\s*cube/i);
          if (simpleMatch && !matches.find(m => m.timestamp === currentTimestamp)) {
            const result = this.normalizeResult(simpleMatch[1]);
            const cubes = parseInt(simpleMatch[2]);
            if (result && cubes > 0) {
              matches.push({
                id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                result: result,
                cubes: cubes,
                deckId: null,
                opponent: null,
                snapped: 'NONE',
                source: 'log_import',
                notes: ''
              });
            }
          }
        }

        const unique = this.deduplicateMatches(matches);

        return {
          matches: unique,
          parseDate: new Date().toISOString(),
          rawLineCount: lines.length,
          matchCount: unique.length
        };
      },

      normalizeResult(result) {
        if (!result) return null;
        const r = String(result).toUpperCase();
        if (r.includes('WIN') || r === 'VICTORY') return 'WIN';
        if (r.includes('LOSS') || r.includes('LOSE') || r === 'DEFEAT') return 'LOSS';
        if (r.includes('RETREAT')) return 'LOSS';
        return null;
      },

      parseSnapState(data) {
        if (data.PlayerSnapped && data.OpponentSnapped) return 'BOTH';
        if (data.PlayerSnapped) return 'PLAYER';
        if (data.OpponentSnapped) return 'OPPONENT';
        return 'NONE';
      },

      deduplicateMatches(matches) {
        const seen = new Set();
        return matches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      },

      mergeWithExisting(newMatches, existingMatches) {
        const existingKeys = new Set(
          existingMatches.map(m => `${m.timestamp}-${m.result}-${m.cubes}`)
        );

        const toAdd = newMatches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          return !existingKeys.has(key);
        });

        return {
          added: toAdd,
          skipped: newMatches.length - toAdd.length,
          merged: [...existingMatches, ...toAdd].sort((a, b) =>
            new Date(b.timestamp) - new Date(a.timestamp)
          )
        };
      }
    };

    // ==================== GAME DATA PARSER (Phase 5) ====================
    const GameDataParser = {
      /**
       * Parse CollectionState.json for owned cards
       */
      parseCollection(json) {
        const cards = new Set();

        // Helper to recursively find all CardDefId values
        const findCards = (obj) => {
          if (!obj || typeof obj !== 'object') return;

          if (obj.CardDefId && typeof obj.CardDefId === 'string') {
            // Filter out tokens/created cards (usually have special naming)
            if (!obj.CardDefId.includes('Token') &&
                !obj.CardDefId.includes('Stone') &&
                !obj.CardDefId.includes('Shard') &&
                !obj.CardDefId.startsWith('_')) {
              cards.add(obj.CardDefId);
            }
          }

          // Recurse into arrays and objects
          if (Array.isArray(obj)) {
            obj.forEach(findCards);
          } else {
            Object.values(obj).forEach(findCards);
          }
        };

        findCards(json);

        return {
          type: 'collection',
          cards: Array.from(cards).sort(),
          count: cards.size,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse ProfileState.json for stats and card performance
       */
      parseProfile(json) {
        const account = json?.ServerState?.Account;
        if (!account) return null;

        // Parse card stats (net cubes per card)
        const cardStats = account.CardStats || {};
        const cardPerformance = Object.entries(cardStats)
          .map(([card, netCubes]) => ({ card, netCubes }))
          .sort((a, b) => b.netCubes - a.netCubes);

        // Parse wallet
        const wallet = json?.ServerState?.Wallet || {};
        const currencies = wallet.Currencies || {};

        const wins = account.Wins || 0;
        const losses = account.Losses || 0;

        return {
          type: 'profile',
          player: {
            name: account.Name || 'Unknown',
            tag: account.Tag || 0,
            snapId: `${account.Name || 'Unknown'}#${account.Tag || 0}`
          },
          stats: {
            wins: wins,
            losses: losses,
            ties: account.Ties || 0,
            totalGames: wins + losses + (account.Ties || 0),
            winRate: wins > 0 ? ((wins / (wins + losses)) * 100).toFixed(1) : '0.0',
            snaps: account.Snaps || 0,
            concedes: account.Concedes || 0,
            opponentConcedes: account.OpponentConcedes || 0
          },
          cardPerformance: {
            top10: cardPerformance.filter(c => c.netCubes > 0).slice(0, 10),
            bottom10: cardPerformance.filter(c => c.netCubes < 0).slice(-10).reverse(),
            all: cardPerformance
          },
          currencies: {
            credits: currencies.Credits?.TotalAmount || 0,
            gold: currencies.Gold?.TotalAmount || 0,
            tokens: currencies.CollectorsToken?.TotalAmount || 0
          },
          lastLogin: account.LastLogin,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse CharacterMasteryState.json for mastery levels
       */
      parseMastery(json) {
        const progress = json?.ServerState?.CharacterMasteryProgress?.CharacterProgressData;
        if (!progress) return null;

        const masteryData = Object.entries(progress)
          .map(([card, data]) => ({
            card,
            experience: data.Experience || 0,
            level: parseInt(data.LastClaimedLevel) || 1,
            levelCap: parseInt(data.LevelCap) || 30
          }))
          .sort((a, b) => b.level - a.level || b.experience - a.experience);

        return {
          type: 'mastery',
          cards: masteryData,
          totalCards: masteryData.length,
          avgLevel: masteryData.length > 0 ? (masteryData.reduce((sum, c) => sum + c.level, 0) / masteryData.length).toFixed(1) : '0',
          maxedCards: masteryData.filter(c => c.level >= c.levelCap).length,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse BattlePassState.json for season pass progress
       */
      parseBattlePass(json) {
        const battlePass = json?.ServerState?.BattlePass;
        if (!battlePass) return null;

        return {
          type: 'battlePass',
          season: battlePass.BattlePassDefId || 'Unknown',
          level: battlePass.Level || 0,
          xp: battlePass.Xp || 0,
          claimedLevels: battlePass.LevelsClaimed || [],
          parseDate: new Date().toISOString()
        };
      }
    };

    // ==================== INDEXEDDB HELPER (Phase 5) ====================
    const openSyncDB = () => {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('SnapSyncDB', 1);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          const db = request.result;
          resolve({
            get: (store, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readonly');
              const req = tx.objectStore(store).get(key);
              req.onsuccess = () => res(req.result);
              req.onerror = () => rej(req.error);
            }),
            put: (store, value, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readwrite');
              const req = tx.objectStore(store).put(value, key);
              req.onsuccess = () => res();
              req.onerror = () => rej(req.error);
            }),
            delete: (store, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readwrite');
              const req = tx.objectStore(store).delete(key);
              req.onsuccess = () => res();
              req.onerror = () => rej(req.error);
            })
          });
        };

        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('settings')) {
            db.createObjectStore('settings');
          }
        };
      });
    };

    // Auto-import all data without preview (for linked folder sync)
    const autoImportAll = (data) => {
      const timestamp = new Date().toISOString();
      const results = [];

      if (data.collection) {
        const existing = JSON.parse(localStorage.getItem('snap_collection') || '{"owned":[]}');
        const merged = [...new Set([...existing.owned, ...data.collection.cards])];
        localStorage.setItem('snap_collection', JSON.stringify({
          owned: merged,
          lastUpdated: timestamp,
          source: 'LinkedFolder'
        }));
        results.push(`Collection: ${merged.length} cards`);
      }

      if (data.profile) {
        localStorage.setItem('snap_profile_stats', JSON.stringify({
          ...data.profile.stats,
          snapId: data.profile.player.snapId,
          currencies: data.profile.currencies,
          importedAt: timestamp
        }));
        results.push(`Stats: ${data.profile.stats.winRate}% win rate`);

        // Card performance
        if (data.profile.cardPerformance) {
          const performanceMap = {};
          data.profile.cardPerformance.all.forEach(({ card, netCubes }) => {
            performanceMap[card] = { netCubes };
          });
          localStorage.setItem('snap_card_performance', JSON.stringify({
            cards: performanceMap,
            importedAt: timestamp
          }));
          results.push(`Card Performance: ${data.profile.cardPerformance.all.length} cards`);
        }
      }

      if (data.mastery) {
        localStorage.setItem('snap_mastery', JSON.stringify({
          cards: data.mastery.cards,
          importedAt: timestamp
        }));
        results.push(`Mastery: ${data.mastery.totalCards} cards`);
      }

      return results;
    };

    // ==================== COLLECTION INFERRER ====================
    const CollectionInferrer = {
      inferFromMatches(matches) {
        const usedCards = new Set();
        for (const match of matches) {
          if (match.deckCards && Array.isArray(match.deckCards)) {
            match.deckCards.forEach(card => usedCards.add(card));
          }
        }
        return Array.from(usedCards);
      },

      mergeWithCollection(inferredCards, existingCollection) {
        const existing = new Set(existingCollection.owned || []);
        let addedCount = 0;

        for (const card of inferredCards) {
          if (!existing.has(card)) {
            existing.add(card);
            addedCount++;
          }
        }

        return {
          owned: Array.from(existing),
          addedCount,
          lastUpdated: new Date().toISOString()
        };
      }
    };

    // ==================== VAULT MANAGER ====================
    const VaultManager = {
      exportFullVault(collection, matches, settings) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const totalGames = matches.length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          version: '1.0',
          exportDate: new Date().toISOString(),
          collection: collection,
          matches: matches,
          settings: settings,
          stats: {
            totalGames,
            wins: totalWins,
            losses: totalGames - totalWins,
            winRate: totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0,
            netCubes
          }
        };
      },

      generateSyncData(collection, matches) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          v: 1,
          c: collection.owned || [],
          s: {
            wins: totalWins,
            losses: matches.length - totalWins,
            cubes: netCubes
          }
        };
      },

      compressForQR(syncData) {
        try {
          return LZString.compressToEncodedURIComponent(JSON.stringify(syncData));
        } catch (e) {
          console.error('Compression failed:', e);
          return null;
        }
      },

      decompressFromQR(compressed) {
        try {
          const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
          return JSON.parse(decompressed);
        } catch (e) {
          console.error('Decompression failed:', e);
          return null;
        }
      }
    };

    // ==================== LOG ERROR MESSAGES ====================
    const LogErrors = {
      NO_MATCHES: 'No match data found. Make sure this is the Player.log file from Marvel Snap.',
      PARSE_FAILED: 'Could not parse log file. The game may have updated its format.',
      FILE_TOO_LARGE: 'File is too large (>50MB). Try using a more recent log file.',
      INVALID_FORMAT: 'This doesn\'t appear to be a Marvel Snap log file.',
      READ_ERROR: 'Could not read the file. Please try again.'
    };

    // ==================== UTILITY FUNCTIONS ====================
    const getSeriesBorderClass = (series) => `series-border-${series}`;

    const loadFromStorage = (key, defaultValue) => {
      try {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      } catch { return defaultValue; }
    };

    const saveToStorage = (key, value) => {
      try { localStorage.setItem(key, JSON.stringify(value)); }
      catch (e) { console.warn('Storage error:', e); }
    };

    const generateId = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });

    const formatDate = (dateString) => new Date(dateString).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
    });

    // ==================== COMPONENTS ====================

    // Navigation Bar
    const NavBar = ({ activeTab, setActiveTab }) => {
      const tabs = [
        { id: 'dashboard', label: 'Home', icon: '' },
        { id: 'ai', label: 'AI', icon: '' },
        { id: 'collection', label: 'Cards', icon: '' },
        { id: 'decks', label: 'Decks', icon: '' },
        { id: 'calculator', label: 'Calc', icon: '' },
        { id: 'settings', label: 'More', icon: '' }
      ];
      return (
        <nav className="fixed bottom-0 left-0 right-0 bg-marvel-black border-t-4 border-marvel-red z-50">
          <div className="flex justify-around items-center h-16 max-w-lg mx-auto">
            {tabs.map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)}
                className={`flex flex-col items-center justify-center w-full h-full transition-colors ${
                  activeTab === tab.id ? 'text-marvel-red tab-active' : 'text-gray-400 hover:text-white'
                }`}>
                <span className="text-xl">{tab.icon}</span>
                <span className="text-xs mt-1 font-medium">{tab.label}</span>
              </button>
            ))}
          </div>
        </nav>
      );
    };

    // Header
    const Header = ({ title }) => (
      <header className="bg-marvel-red halftone py-4 px-4 shadow-comic mb-4">
        <h1 className="text-2xl font-comic text-white text-center tracking-wider">{title}</h1>
      </header>
    );

    // Dashboard Component
    const Dashboard = ({ collection, matches, onQuickMatch }) => {
      const [importedStats, setImportedStats] = useState(null);

      // Load imported stats on mount and when data updates
      useEffect(() => {
        const loadImportedStats = () => {
          const stats = loadFromStorage('snap_profile_stats', null);
          setImportedStats(stats);
        };
        loadImportedStats();
        window.addEventListener('snap-data-updated', loadImportedStats);
        return () => window.removeEventListener('snap-data-updated', loadImportedStats);
      }, []);

      const totalCards = uniqueCards.length;
      // Only count cards that exist in our database
      const ownedInDatabase = collection.owned.filter(name => uniqueCards.some(c => c.name === name)).length;
      const completionPercent = Math.min(100, Math.round((ownedInDatabase / totalCards) * 100));
      const today = new Date().toDateString();
      const todayMatches = matches.filter(m => new Date(m.timestamp).toDateString() === today);
      const todayCubes = todayMatches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);
      const totalWins = matches.filter(m => m.result === 'WIN').length;
      const totalGames = matches.length;
      const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      // Use imported stats if available, otherwise use local tracking
      const displayStats = importedStats ? {
        wins: importedStats.wins,
        losses: importedStats.losses,
        totalGames: importedStats.totalGames || (importedStats.wins + importedStats.losses),
        winRate: importedStats.winRate,
        hasImported: true,
        snapId: importedStats.snapId
      } : {
        wins: totalWins,
        losses: totalGames - totalWins,
        totalGames: totalGames,
        winRate: winRate,
        hasImported: false,
        snapId: null
      };

      const getStreak = () => {
        if (matches.length === 0) return { count: 0, type: 'none' };
        const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        const firstResult = sorted[0].result;
        let count = 0;
        for (const match of sorted) {
          if (match.result === firstResult) count++;
          else break;
        }
        return { count, type: firstResult };
      };
      const streak = getStreak();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAPAPOULOUS PRIME" />
          {/* Lifetime Stats (from imported data) */}
          {displayStats.hasImported && (
            <div className="bg-gray-800 rounded-lg p-3 mb-4 panel-border border-l-4 border-marvel-blue">
              <div className="flex items-center justify-between mb-2">
                <span className="text-xs uppercase text-gray-400">Lifetime Stats</span>
                <span className="text-xs px-2 py-0.5 bg-marvel-blue/30 text-marvel-blue rounded">From Game</span>
              </div>
              <div className="grid grid-cols-4 gap-2 text-center">
                <div>
                  <div className="text-lg font-bold text-white">{displayStats.totalGames.toLocaleString()}</div>
                  <div className="text-xs text-gray-500">Games</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-green-400">{displayStats.wins.toLocaleString()}</div>
                  <div className="text-xs text-gray-500">Wins</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-red-400">{displayStats.losses.toLocaleString()}</div>
                  <div className="text-xs text-gray-500">Losses</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-marvel-gold">{displayStats.winRate}%</div>
                  <div className="text-xs text-gray-500">Win Rate</div>
                </div>
              </div>
              {displayStats.snapId && (
                <div className="text-xs text-gray-500 text-right mt-2">{displayStats.snapId}</div>
              )}
            </div>
          )}

          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-red panel-border">
              <div className="text-gray-400 text-xs uppercase">Collection</div>
              <div className="text-2xl font-comic text-white">{completionPercent}%</div>
              <div className="text-sm text-gray-400">{ownedCount}/{totalCards} cards</div>
            </div>
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-gold panel-border">
              <div className="text-gray-400 text-xs uppercase">{displayStats.hasImported ? 'Session' : 'Win Rate'}</div>
              <div className="text-2xl font-comic text-white">{winRate}%</div>
              <div className="text-sm text-gray-400">{totalWins}/{totalGames} {displayStats.hasImported ? 'tracked' : 'games'}</div>
            </div>
          </div>
          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-blue panel-border">
              <div className="text-gray-400 text-xs uppercase">Net Cubes</div>
              <div className={`text-2xl font-comic ${netCubes >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {netCubes >= 0 ? '+' : ''}{netCubes}
              </div>
              <div className="text-sm text-gray-400">Today: {todayCubes >= 0 ? '+' : ''}{todayCubes}</div>
            </div>
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-series-3 panel-border">
              <div className="text-gray-400 text-xs uppercase">Streak</div>
              <div className={`text-2xl font-comic ${streak.type === 'WIN' ? 'text-green-400' : streak.type === 'LOSS' ? 'text-red-400' : 'text-gray-400'}`}>
                {streak.count} {streak.type === 'WIN' ? 'W' : streak.type === 'LOSS' ? 'L' : '-'}
              </div>
              <div className="text-sm text-gray-400">Current</div>
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h2 className="text-lg font-comic text-marvel-gold mb-3">Quick Match</h2>
            <div className="mb-3">
              <div className="text-sm text-green-400 mb-2">WIN</div>
              <div className="flex gap-2">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`win-${cubes}`} onClick={() => onQuickMatch('WIN', cubes)}
                    className="flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded shadow-comic-sm active:shadow-none active:translate-x-0.5 active:translate-y-0.5 transition-all">
                    +{cubes}
                  </button>
                ))}
              </div>
            </div>
            <div>
              <div className="text-sm text-red-400 mb-2">LOSS</div>
              <div className="flex gap-2">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`loss-${cubes}`} onClick={() => onQuickMatch('LOSS', cubes)}
                    className="flex-1 bg-red-600 hover:bg-red-500 text-white font-bold py-3 rounded shadow-comic-sm active:shadow-none active:translate-x-0.5 active:translate-y-0.5 transition-all">
                    -{cubes}
                  </button>
                ))}
              </div>
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <h2 className="text-lg font-comic text-marvel-gold mb-3">Recent Matches</h2>
            {matches.length === 0 ? (
              <p className="text-gray-400 text-center py-4">No matches recorded yet</p>
            ) : (
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {[...matches].reverse().slice(0, 5).map(match => (
                  <div key={match.id} className={`flex items-center justify-between p-2 rounded ${
                    match.result === 'WIN' ? 'bg-green-900/30' : 'bg-red-900/30'
                  }`}>
                    <span className={`font-bold ${match.result === 'WIN' ? 'text-green-400' : 'text-red-400'}`}>
                      {match.result === 'WIN' ? '+' : '-'}{match.cubes} cubes
                    </span>
                    <span className="text-gray-400 text-sm">{formatDate(match.timestamp)}</span>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    };

    // AI Chat Component
    const AIChat = ({ collection, matches, aiConfig, setActiveTab }) => {
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);
      const messagesEndRef = useRef(null);

      const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      };

      useEffect(() => {
        scrollToBottom();
      }, [messages]);

      useEffect(() => {
        if (messages.length === 0) {
          setMessages([{
            id: generateId(),
            role: 'assistant',
            content: "Ready to climb the ranks? I'm Snapapoulous, your Marvel Snap tactical advisor. Ask me about deck building, meta matchups, snap decisions, or anything else about the game!"
          }]);
        }
      }, []);

      const isConfigured = () => {
        if (!aiConfig.provider) return false;
        if (aiConfig.provider === 'gemini-oauth') return isGoogleTokenValid();
        if (aiConfig.provider === 'local') return !!aiConfig.localEndpoint;
        return !!aiConfig.apiKeys?.[aiConfig.provider];
      };

      const sendMessage = async () => {
        if (!input.trim() || isLoading) return;
        if (!isConfigured()) {
          setError('Please configure an AI provider in Settings first.');
          return;
        }

        const userMessage = { id: generateId(), role: 'user', content: input.trim() };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);
        setError(null);

        try {
          const systemPrompt = buildSystemPrompt(collection, matches);
          const apiMessages = [
            { role: 'system', content: systemPrompt },
            ...messages.filter(m => m.role !== 'assistant' || messages.indexOf(m) > 0).map(m => ({
              role: m.role, content: m.content
            })),
            { role: 'user', content: userMessage.content }
          ];

          let response;
          const model = aiConfig.model || AIProviders[aiConfig.provider]?.defaultModel;

          switch (aiConfig.provider) {
            case 'gemini-oauth':
              response = await callGeminiOAuth(apiMessages.filter(m => m.role !== 'system'), model);
              break;
            case 'gemini':
              response = await callGeminiAPIKey(apiMessages.filter(m => m.role !== 'system'), model, aiConfig.apiKeys?.gemini);
              break;
            case 'groq':
              response = await callGroq(apiMessages, model, aiConfig.apiKeys?.groq);
              break;
            case 'claude':
              response = await callClaude(apiMessages, model, aiConfig.apiKeys?.claude);
              break;
            case 'openai':
              response = await callOpenAI(apiMessages, model, aiConfig.apiKeys?.openai);
              break;
            case 'local':
              response = await callLocal(apiMessages, model, aiConfig.localEndpoint);
              break;
            default:
              throw new Error('Unknown provider');
          }

          setMessages(prev => [...prev, {
            id: generateId(),
            role: 'assistant',
            content: response
          }]);
        } catch (err) {
          setError(err.message || 'Failed to get response');
          console.error('AI error:', err);
        } finally {
          setIsLoading(false);
        }
      };

      const quickPrompts = [
        "Analyze my win rate",
        "Best deck for climbing?",
        "When should I snap?",
        "Counter Destroy decks"
      ];

      return (
        <div className="flex flex-col h-[calc(100vh-4rem)] pb-16">
          <Header title="SNAPAPOULOUS AI" />

          {!isConfigured() && (
            <div className="mx-4 mb-4 bg-yellow-900/50 border border-yellow-600 rounded-lg p-4">
              <p className="text-yellow-200 text-sm mb-2">AI not configured yet!</p>
              <button onClick={() => setActiveTab('settings')}
                className="bg-marvel-gold text-black px-4 py-2 rounded font-medium hover:bg-yellow-400">
                Configure AI Provider
              </button>
            </div>
          )}

          <div className="flex-1 overflow-y-auto px-4 space-y-4">
            {messages.map(msg => (
              <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                <div className={`max-w-[85%] p-3 chat-bubble ${
                  msg.role === 'user'
                    ? 'bg-marvel-blue text-white chat-bubble-user'
                    : 'bg-gray-700 text-white chat-bubble-ai'
                }`}>
                  <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                </div>
              </div>
            ))}

            {isLoading && (
              <div className="flex justify-start">
                <div className="bg-gray-700 p-4 rounded-lg chat-bubble chat-bubble-ai">
                  <div className="flex gap-1">
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                  </div>
                </div>
              </div>
            )}

            {error && (
              <div className="bg-red-900/50 border border-red-500 rounded-lg p-3">
                <p className="text-red-300 text-sm">{error}</p>
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>

          {messages.length <= 1 && (
            <div className="px-4 py-2">
              <div className="flex flex-wrap gap-2">
                {quickPrompts.map(prompt => (
                  <button key={prompt} onClick={() => setInput(prompt)}
                    className="bg-gray-700 text-gray-300 text-xs px-3 py-1.5 rounded-full hover:bg-gray-600">
                    {prompt}
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="p-4 bg-gray-900 border-t border-gray-700">
            <div className="flex gap-2">
              <input type="text" value={input} onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && sendMessage()}
                placeholder="Ask Snapapoulous..."
                disabled={isLoading}
                className="flex-1 bg-gray-800 text-white rounded-lg px-4 py-3 border-2 border-gray-700 focus:border-marvel-red focus:outline-none disabled:opacity-50"
              />
              <button onClick={sendMessage} disabled={isLoading || !input.trim()}
                className="bg-marvel-red text-white px-6 py-3 rounded-lg font-medium hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed shadow-comic-sm">
                Send
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Collection Component
    const Collection = ({ collection, setCollection }) => {
      const [search, setSearch] = useState('');
      const [seriesFilter, setSeriesFilter] = useState('all');
      const [ownedFilter, setOwnedFilter] = useState('all');
      const [selectedCard, setSelectedCard] = useState(null);

      const handleClearAll = () => {
        if (window.confirm('Are you sure you want to clear your entire collection? This cannot be undone.')) {
          setCollection({ owned: [], lastUpdated: new Date().toISOString() });
        }
      };

      const filteredCards = useMemo(() => {
        return uniqueCards.filter(card => {
          if (search && !card.name.toLowerCase().includes(search.toLowerCase())) return false;
          if (seriesFilter !== 'all' && card.series !== parseInt(seriesFilter)) return false;
          const isOwned = collection.owned.includes(card.name);
          if (ownedFilter === 'owned' && !isOwned) return false;
          if (ownedFilter === 'missing' && isOwned) return false;
          return true;
        });
      }, [search, seriesFilter, ownedFilter, collection.owned]);

      const toggleCard = (cardName) => {
        setCollection(prev => {
          const isOwned = prev.owned.includes(cardName);
          return {
            owned: isOwned ? prev.owned.filter(c => c !== cardName) : [...prev.owned, cardName],
            lastUpdated: new Date().toISOString()
          };
        });
      };

      const markAllSeries = (series) => {
        const seriesCards = uniqueCards.filter(c => c.series === series).map(c => c.name);
        setCollection(prev => ({
          owned: [...new Set([...prev.owned, ...seriesCards])],
          lastUpdated: new Date().toISOString()
        }));
      };

      // Only count cards that exist in our database
      const ownedInDatabase = collection.owned.filter(name => uniqueCards.some(c => c.name === name)).length;
      const completionPercent = Math.min(100, Math.round((ownedInDatabase / uniqueCards.length) * 100));

      return (
        <div className="px-4 pb-20">
          <Header title="COLLECTION" />
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between mb-2">
              <span className="text-white font-medium">Completion</span>
              <span className="text-marvel-gold font-bold">{completionPercent}%</span>
            </div>
            <div className="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
              <div className="bg-gradient-to-r from-marvel-red to-marvel-gold h-full transition-all duration-500"
                style={{ width: `${completionPercent}%` }} />
            </div>
            <div className="text-center text-sm text-gray-400 mt-2">
              {ownedInDatabase} / {uniqueCards.length} cards owned
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <input type="text" placeholder="Search cards..." value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-3 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
            <div className="flex gap-2 mb-3">
              <select value={seriesFilter} onChange={(e) => setSeriesFilter(e.target.value)}
                className="flex-1 bg-gray-700 text-white rounded px-2 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none">
                <option value="all">All Series</option>
                <option value="1">Series 1</option>
                <option value="2">Series 2</option>
                <option value="3">Series 3</option>
                <option value="4">Series 4</option>
                <option value="5">Series 5</option>
              </select>
              <select value={ownedFilter} onChange={(e) => setOwnedFilter(e.target.value)}
                className="flex-1 bg-gray-700 text-white rounded px-2 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none">
                <option value="all">All Cards</option>
                <option value="owned">Owned</option>
                <option value="missing">Missing</option>
              </select>
            </div>
            <div className="flex gap-2 flex-wrap">
              <button onClick={() => markAllSeries(1)} className="bg-series-1 text-white text-xs px-2 py-1 rounded hover:opacity-80">Own S1</button>
              <button onClick={() => markAllSeries(2)} className="bg-series-2 text-white text-xs px-2 py-1 rounded hover:opacity-80">Own S2</button>
              <button onClick={handleClearAll}
                className="bg-red-600 text-white text-xs px-2 py-1 rounded hover:opacity-80 ml-auto">Clear All</button>
            </div>
          </div>
          <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
            {filteredCards.map(card => {
              const isOwned = collection.owned.includes(card.name);
              return (
                <div key={card.name} className={`relative p-2 rounded-lg border-3 transition-all card-hover ${getSeriesBorderClass(card.series)} ${
                    isOwned ? 'bg-gray-700 border-opacity-100' : 'bg-gray-900 border-opacity-30 opacity-50'
                  }`} style={{ borderWidth: '3px' }}>
                  <button onClick={() => toggleCard(card.name)} className="w-full h-full">
                    <div className="absolute top-1 left-1 w-5 h-5 bg-marvel-blue rounded-full flex items-center justify-center text-xs font-bold text-white">{card.cost}</div>
                    <div className="absolute top-1 right-1 w-5 h-5 bg-marvel-red rounded-full flex items-center justify-center text-xs font-bold text-white">{card.power}</div>
                    <div className="mt-6 text-xs text-white text-center truncate">{card.name}</div>
                    {isOwned && (
                      <div className="absolute -top-1 -right-1 w-4 h-4 bg-green-500 rounded-full flex items-center justify-center">
                        <span className="text-white text-xs"></span>
                      </div>
                    )}
                  </button>
                  <button onClick={(e) => { e.stopPropagation(); setSelectedCard(card); }}
                    className="absolute bottom-1 right-1 w-5 h-5 bg-gray-600 hover:bg-marvel-gold rounded-full flex items-center justify-center text-xs text-white z-10"
                    title="View card details">i</button>
                </div>
              );
            })}
          </div>
          {filteredCards.length === 0 && <div className="text-center text-gray-400 py-8">No cards found</div>}

          {/* Card Detail Modal */}
          {selectedCard && (
            <div className="fixed inset-0 bg-black bg-opacity-80 z-50 flex items-center justify-center p-4" onClick={() => setSelectedCard(null)}>
              <div className="bg-gray-800 rounded-lg panel-border max-w-sm w-full p-6" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-start mb-4">
                  <h3 className="text-xl font-comic text-white">{selectedCard.name}</h3>
                  <button onClick={() => setSelectedCard(null)} className="text-gray-400 hover:text-white text-xl">&times;</button>
                </div>
                <div className="flex gap-4 mb-4">
                  <div className="flex items-center gap-2">
                    <span className="w-8 h-8 bg-marvel-blue rounded-full flex items-center justify-center font-bold text-white">{selectedCard.cost}</span>
                    <span className="text-gray-400 text-sm">Cost</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="w-8 h-8 bg-marvel-red rounded-full flex items-center justify-center font-bold text-white">{selectedCard.power}</span>
                    <span className="text-gray-400 text-sm">Power</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className={`w-8 h-8 rounded-full flex items-center justify-center font-bold text-white ${
                      selectedCard.series === 1 ? 'bg-series-1' : selectedCard.series === 2 ? 'bg-series-2' :
                      selectedCard.series === 3 ? 'bg-series-3' : selectedCard.series === 4 ? 'bg-series-4' : 'bg-series-5'
                    }`}>{selectedCard.series}</span>
                    <span className="text-gray-400 text-sm">Series</span>
                  </div>
                </div>
                <div className="bg-gray-700 rounded-lg p-4">
                  <p className="text-gray-300 text-sm leading-relaxed">{selectedCard.ability || 'No ability text available.'}</p>
                </div>
                <div className="mt-4 flex gap-2">
                  <button onClick={() => { toggleCard(selectedCard.name); setSelectedCard(null); }}
                    className={`flex-1 py-2 rounded font-medium ${
                      collection.owned.includes(selectedCard.name)
                        ? 'bg-red-600 hover:bg-red-700 text-white'
                        : 'bg-green-600 hover:bg-green-700 text-white'
                    }`}>
                    {collection.owned.includes(selectedCard.name) ? 'Remove from Collection' : 'Add to Collection'}
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    // ==================== DECKS COMPONENT ====================
    const Decks = ({ decks, setDecks, collection }) => {
      const [view, setView] = useState('list'); // list, create, edit, import
      const [editingDeck, setEditingDeck] = useState(null);
      const [deckName, setDeckName] = useState('');
      const [selectedCards, setSelectedCards] = useState([]);
      const [importCode, setImportCode] = useState('');
      const [importUrl, setImportUrl] = useState('');
      const [importError, setImportError] = useState('');
      const [searchCard, setSearchCard] = useState('');

      const startNewDeck = () => {
        setDeckName('');
        setSelectedCards([]);
        setEditingDeck(null);
        setView('create');
      };

      const editDeck = (deck) => {
        setDeckName(deck.name);
        setSelectedCards([...deck.cards]);
        setEditingDeck(deck.id);
        setView('create');
      };

      const toggleCardInDeck = (cardName) => {
        if (selectedCards.includes(cardName)) {
          setSelectedCards(prev => prev.filter(c => c !== cardName));
        } else if (selectedCards.length < 12) {
          setSelectedCards(prev => [...prev, cardName]);
        }
      };

      const saveDeck = () => {
        if (!deckName.trim() || selectedCards.length !== 12) {
          alert('Please name your deck and select exactly 12 cards.');
          return;
        }
        const newDeck = {
          id: editingDeck || generateId(),
          name: deckName.trim(),
          cards: selectedCards,
          createdAt: editingDeck ? decks.find(d => d.id === editingDeck)?.createdAt : new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        if (editingDeck) {
          setDecks(prev => prev.map(d => d.id === editingDeck ? newDeck : d));
        } else {
          setDecks(prev => [...prev, newDeck]);
        }
        setView('list');
        setEditingDeck(null);
      };

      const deleteDeck = (id) => {
        if (window.confirm('Delete this deck?')) {
          setDecks(prev => prev.filter(d => d.id !== id));
        }
      };

      // Decode deck code (base64 encoded card list)
      const decodeDeckCode = (code) => {
        try {
          const decoded = atob(code.trim());
          const cardNames = decoded.split(',').map(s => s.trim()).filter(Boolean);
          if (cardNames.length !== 12) throw new Error('Deck must have 12 cards');
          // Verify cards exist
          cardNames.forEach(name => {
            if (!uniqueCards.find(c => c.name.toLowerCase() === name.toLowerCase())) {
              throw new Error(`Unknown card: ${name}`);
            }
          });
          return cardNames.map(name => uniqueCards.find(c => c.name.toLowerCase() === name.toLowerCase()).name);
        } catch (e) {
          throw new Error('Invalid deck code: ' + e.message);
        }
      };

      // Import from MarvelSnapZone URL
      const importFromUrl = async () => {
        setImportError('');
        try {
          // Extract deck name and cards from URL
          // URL format: https://marvelsnapzone.com/decks/deck-name/
          const url = importUrl.trim();
          if (!url.includes('marvelsnapzone.com') && !url.includes('untapped.gg')) {
            throw new Error('Please enter a MarvelSnapZone or Untapped.gg deck URL');
          }

          // For demonstration, we'll parse the URL manually
          // In production, you'd fetch the page and parse the card list
          setImportError('URL import coming soon! For now, please use a deck code.');
        } catch (e) {
          setImportError(e.message);
        }
      };

      const importFromCode = () => {
        setImportError('');
        try {
          const cards = decodeDeckCode(importCode);
          setSelectedCards(cards);
          setDeckName('Imported Deck');
          setView('create');
        } catch (e) {
          setImportError(e.message);
        }
      };

      // Calculate deck stats
      const getDeckStats = (cardNames) => {
        const cards = cardNames.map(name => uniqueCards.find(c => c.name === name)).filter(Boolean);
        const avgCost = cards.length > 0 ? (cards.reduce((sum, c) => sum + c.cost, 0) / cards.length).toFixed(1) : 0;
        const totalPower = cards.reduce((sum, c) => sum + c.power, 0);
        const ownedCount = cardNames.filter(name => collection.owned.includes(name)).length;
        const curve = [0, 0, 0, 0, 0, 0, 0]; // 0-6+ cost
        cards.forEach(c => { curve[Math.min(c.cost, 6)]++; });
        return { avgCost, totalPower, ownedCount, curve, cards };
      };

      const filteredCards = useMemo(() => {
        if (!searchCard) return uniqueCards;
        return uniqueCards.filter(c => c.name.toLowerCase().includes(searchCard.toLowerCase()));
      }, [searchCard]);

      // List View
      if (view === 'list') {
        return (
          <div className="px-4 pb-20">
            <Header title="MY DECKS" />
            <div className="flex gap-2 mb-4">
              <button onClick={startNewDeck}
                className="flex-1 bg-marvel-red text-white py-3 rounded-lg font-comic hover:opacity-80 panel-border">
                + Create Deck
              </button>
              <button onClick={() => setView('import')}
                className="flex-1 bg-series-3 text-white py-3 rounded-lg font-comic hover:opacity-80 panel-border">
                Import Deck
              </button>
            </div>
            {decks.length === 0 ? (
              <div className="text-center text-gray-400 py-12">
                <p className="text-lg mb-2">No decks yet</p>
                <p className="text-sm">Create a deck or import one from MarvelSnapZone</p>
              </div>
            ) : (
              <div className="space-y-3">
                {decks.map(deck => {
                  const stats = getDeckStats(deck.cards);
                  return (
                    <div key={deck.id} className="bg-gray-800 rounded-lg p-4 panel-border">
                      <div className="flex justify-between items-start mb-2">
                        <h3 className="text-lg font-comic text-white">{deck.name}</h3>
                        <div className="flex gap-2">
                          <button onClick={() => editDeck(deck)} className="text-marvel-blue hover:text-white text-sm">Edit</button>
                          <button onClick={() => deleteDeck(deck.id)} className="text-red-500 hover:text-red-400 text-sm">Delete</button>
                        </div>
                      </div>
                      <div className="flex gap-4 text-sm text-gray-400 mb-3">
                        <span>Avg Cost: <span className="text-marvel-blue">{stats.avgCost}</span></span>
                        <span>Total Power: <span className="text-marvel-red">{stats.totalPower}</span></span>
                        <span>Owned: <span className={stats.ownedCount === 12 ? 'text-green-500' : 'text-yellow-500'}>{stats.ownedCount}/12</span></span>
                      </div>
                      {/* Mana Curve */}
                      <div className="flex gap-1 items-end h-8 mb-3">
                        {stats.curve.map((count, cost) => (
                          <div key={cost} className="flex-1 flex flex-col items-center">
                            <div className="bg-marvel-blue w-full rounded-t" style={{ height: count * 8 + 'px' }}></div>
                            <span className="text-xs text-gray-500">{cost}{cost === 6 ? '+' : ''}</span>
                          </div>
                        ))}
                      </div>
                      {/* Card Pills */}
                      <div className="flex flex-wrap gap-1">
                        {deck.cards.map(cardName => {
                          const card = uniqueCards.find(c => c.name === cardName);
                          const owned = collection.owned.includes(cardName);
                          return (
                            <span key={cardName} className={`text-xs px-2 py-1 rounded-full ${owned ? 'bg-gray-700 text-white' : 'bg-red-900 text-red-300'}`}>
                              {card?.cost || '?'}/{cardName}
                            </span>
                          );
                        })}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        );
      }

      // Import View
      if (view === 'import') {
        return (
          <div className="px-4 pb-20">
            <Header title="IMPORT DECK" />
            <button onClick={() => setView('list')} className="text-marvel-blue mb-4">&larr; Back to Decks</button>

            <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
              <h3 className="text-lg font-comic text-marvel-gold mb-3">Import from Deck Code</h3>
              <p className="text-gray-400 text-sm mb-2">Paste a base64 encoded deck code</p>
              <input type="text" placeholder="Paste deck code here..."
                value={importCode} onChange={(e) => setImportCode(e.target.value)}
                className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              <button onClick={importFromCode}
                className="w-full bg-marvel-red text-white py-2 rounded hover:opacity-80">
                Import from Code
              </button>
            </div>

            <div className="bg-gray-800 rounded-lg p-4 panel-border">
              <h3 className="text-lg font-comic text-marvel-gold mb-3">Import from URL</h3>
              <p className="text-gray-400 text-sm mb-2">Paste a MarvelSnapZone or Untapped.gg deck URL</p>
              <input type="text" placeholder="https://marvelsnapzone.com/decks/..."
                value={importUrl} onChange={(e) => setImportUrl(e.target.value)}
                className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              <button onClick={importFromUrl}
                className="w-full bg-series-3 text-white py-2 rounded hover:opacity-80">
                Import from URL
              </button>
            </div>

            {importError && (
              <div className="mt-4 bg-red-900 text-red-300 p-3 rounded-lg">{importError}</div>
            )}
          </div>
        );
      }

      // Create/Edit View
      return (
        <div className="px-4 pb-20">
          <Header title={editingDeck ? 'EDIT DECK' : 'CREATE DECK'} />
          <button onClick={() => setView('list')} className="text-marvel-blue mb-4">&larr; Back to Decks</button>

          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <input type="text" placeholder="Deck name..."
              value={deckName} onChange={(e) => setDeckName(e.target.value)}
              className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-3 border-2 border-gray-600 focus:border-marvel-red focus:outline-none text-lg font-comic" />
            <div className="flex justify-between items-center">
              <span className="text-gray-400">Cards: <span className={selectedCards.length === 12 ? 'text-green-500' : 'text-yellow-500'}>{selectedCards.length}/12</span></span>
              <button onClick={saveDeck} disabled={selectedCards.length !== 12 || !deckName.trim()}
                className="bg-marvel-red text-white px-4 py-2 rounded hover:opacity-80 disabled:opacity-50">
                Save Deck
              </button>
            </div>
          </div>

          {/* Selected Cards */}
          {selectedCards.length > 0 && (
            <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
              <h3 className="text-sm text-gray-400 mb-2">Selected Cards</h3>
              <div className="flex flex-wrap gap-1">
                {selectedCards.map(cardName => {
                  const card = uniqueCards.find(c => c.name === cardName);
                  return (
                    <button key={cardName} onClick={() => toggleCardInDeck(cardName)}
                      className="text-xs px-2 py-1 rounded-full bg-marvel-red text-white hover:bg-red-700">
                      {card?.cost || '?'}/{cardName} &times;
                    </button>
                  );
                })}
              </div>
              {selectedCards.length === 12 && (
                <div className="mt-3 pt-3 border-t border-gray-700">
                  <div className="flex gap-4 text-sm text-gray-400">
                    <span>Avg Cost: <span className="text-marvel-blue">{getDeckStats(selectedCards).avgCost}</span></span>
                    <span>Total Power: <span className="text-marvel-red">{getDeckStats(selectedCards).totalPower}</span></span>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Card Picker */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <input type="text" placeholder="Search cards..."
              value={searchCard} onChange={(e) => setSearchCard(e.target.value)}
              className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-3 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
            <div className="grid grid-cols-3 sm:grid-cols-4 gap-2 max-h-96 overflow-y-auto">
              {filteredCards.map(card => {
                const isSelected = selectedCards.includes(card.name);
                const isOwned = collection.owned.includes(card.name);
                return (
                  <button key={card.name} onClick={() => toggleCardInDeck(card.name)}
                    disabled={!isSelected && selectedCards.length >= 12}
                    className={`relative p-2 rounded-lg border-2 transition-all ${
                      isSelected ? 'border-marvel-red bg-gray-600' :
                      isOwned ? 'border-gray-600 bg-gray-700 hover:border-marvel-blue' :
                      'border-gray-700 bg-gray-800 opacity-60'
                    } disabled:opacity-30`}>
                    <div className="absolute top-0 left-0 w-4 h-4 bg-marvel-blue rounded-br flex items-center justify-center text-xs text-white">{card.cost}</div>
                    <div className="absolute top-0 right-0 w-4 h-4 bg-marvel-red rounded-bl flex items-center justify-center text-xs text-white">{card.power}</div>
                    <div className="mt-4 text-xs text-white text-center truncate">{card.name}</div>
                    {isSelected && (
                      <div className="absolute -top-1 -right-1 w-4 h-4 bg-green-500 rounded-full flex items-center justify-center">
                        <span className="text-white text-xs"></span>
                      </div>
                    )}
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      );
    };

    // Calculator Component
    const Calculator = () => {
      const [turn, setTurn] = useState(4);
      const [confidence, setConfidence] = useState(50);
      const [cardsToDraw, setCardsToDraw] = useState(1);
      const [copiesInDeck, setCopiesInDeck] = useState(1);

      const cardsSeen = Math.min(12, 3 + turn);

      const hypergeometric = (N, K, n) => {
        const factorial = (num) => { if (num <= 1) return 1; let r = 1; for (let i = 2; i <= num; i++) r *= i; return r; };
        const comb = (a, b) => { if (b > a) return 0; if (b === 0 || b === a) return 1; return factorial(a) / (factorial(b) * factorial(a - b)); };
        return 1 - (comb(N - K, n) / comb(N, n));
      };

      const drawProbability = hypergeometric(12, copiesInDeck, cardsToDraw) * 100;

      const getRecommendation = () => {
        const turnRiskFactor = turn <= 3 ? 0.9 : turn <= 5 ? 1.0 : 1.1;
        const adj = confidence / turnRiskFactor;
        if (adj >= 70) return { action: 'SNAP', bgColor: 'bg-green-600', animate: true };
        if (adj >= 45) return { action: 'HOLD', bgColor: 'bg-yellow-600', animate: false };
        return { action: 'RETREAT', bgColor: 'bg-red-600', animate: false };
      };
      const rec = getRecommendation();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAP CALCULATOR" />
          <div className={`${rec.bgColor} rounded-lg p-6 panel-border mb-4 text-center ${rec.animate ? 'pulse-snap' : ''}`}>
            <div className="text-4xl font-comic text-white mb-2">{rec.action}</div>
            <div className="text-white/80">
              {rec.action === 'SNAP' && 'The odds favor you. Make your move!'}
              {rec.action === 'HOLD' && 'Wait for more information.'}
              {rec.action === 'RETREAT' && 'Live to fight another match.'}
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Current Turn</span>
              <span className="text-marvel-gold font-bold text-xl">{turn}</span>
            </div>
            <input type="range" min="1" max="7" value={turn} onChange={(e) => setTurn(parseInt(e.target.value))} className="w-full" />
            <div className="text-center text-sm text-gray-400 mt-2">Cards seen: {cardsSeen}/12</div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Win Confidence</span>
              <span className={`font-bold text-xl ${confidence >= 70 ? 'text-green-400' : confidence >= 45 ? 'text-yellow-400' : 'text-red-400'}`}>{confidence}%</span>
            </div>
            <input type="range" min="0" max="100" value={confidence} onChange={(e) => setConfidence(parseInt(e.target.value))} className="w-full" />
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Draw Probability</h3>
            <div className="grid grid-cols-2 gap-3 mb-4">
              <div>
                <label className="text-sm text-gray-400">Cards to Draw</label>
                <input type="number" min="1" max="12" value={cardsToDraw}
                  onChange={(e) => setCardsToDraw(Math.max(1, Math.min(12, parseInt(e.target.value) || 1)))}
                  className="w-full bg-gray-700 text-white rounded px-3 py-2 mt-1 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              </div>
              <div>
                <label className="text-sm text-gray-400">Copies in Deck</label>
                <input type="number" min="1" max="4" value={copiesInDeck}
                  onChange={(e) => setCopiesInDeck(Math.max(1, Math.min(4, parseInt(e.target.value) || 1)))}
                  className="w-full bg-gray-700 text-white rounded px-3 py-2 mt-1 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              </div>
            </div>
            <div className="bg-gray-700 rounded-lg p-4 text-center">
              <div className="text-gray-400 text-sm mb-1">Probability of drawing at least 1:</div>
              <div className={`text-3xl font-comic ${drawProbability >= 70 ? 'text-green-400' : drawProbability >= 40 ? 'text-yellow-400' : 'text-red-400'}`}>
                {drawProbability.toFixed(1)}%
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Log Preview Modal Component
    const LogPreviewModal = ({ matches, skippedCount, onConfirm, onCancel }) => {
      const wins = matches.filter(m => m.result === 'WIN').length;
      const losses = matches.filter(m => m.result === 'LOSS').length;
      const totalCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-comic text-marvel-gold mb-4 text-center">Log Analysis Complete</h3>

            <div className="grid grid-cols-2 gap-3 mb-4">
              <div className="bg-gray-700 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">{matches.length}</div>
                <div className="text-xs text-gray-400">New Matches</div>
              </div>
              <div className="bg-gray-700 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-gray-400">{skippedCount}</div>
                <div className="text-xs text-gray-400">Duplicates Skipped</div>
              </div>
              <div className="bg-green-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-green-400">{wins}</div>
                <div className="text-xs text-gray-400">Wins</div>
              </div>
              <div className="bg-red-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-red-400">{losses}</div>
                <div className="text-xs text-gray-400">Losses</div>
              </div>
            </div>

            <div className="bg-gray-700 rounded-lg p-3 mb-4 text-center">
              <div className="text-xs text-gray-400 mb-1">Net Cubes from Import</div>
              <div className={`text-2xl font-bold ${totalCubes >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {totalCubes >= 0 ? '+' : ''}{totalCubes}
              </div>
            </div>

            {matches.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-300 mb-2">Preview (Recent 5):</h4>
                <div className="space-y-1 max-h-32 overflow-y-auto">
                  {matches.slice(0, 5).map((m, i) => (
                    <div key={i} className={`flex items-center justify-between p-2 rounded text-sm ${
                      m.result === 'WIN' ? 'bg-green-900/30' : 'bg-red-900/30'
                    }`}>
                      <span className={m.result === 'WIN' ? 'text-green-400' : 'text-red-400'}>{m.result}</span>
                      <span className="text-white">{m.result === 'WIN' ? '+' : '-'}{m.cubes}</span>
                      <span className="text-gray-400 text-xs">{formatDate(m.timestamp)}</span>
                    </div>
                  ))}
                  {matches.length > 5 && (
                    <div className="text-center text-gray-400 text-xs py-1">...and {matches.length - 5} more</div>
                  )}
                </div>
              </div>
            )}

            <div className="flex gap-2">
              <button onClick={() => onConfirm(matches)}
                className="flex-1 bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import {matches.length} Matches
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-gray-600 text-white py-3 rounded-lg font-medium hover:bg-gray-500">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Sync Confirm Modal Component
    const SyncConfirmModal = ({ syncData, onConfirm, onCancel }) => {
      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-comic text-marvel-gold mb-4 text-center">Sync Data Received</h3>

            <div className="bg-gray-700 rounded-lg p-4 mb-4">
              <div className="text-center mb-3">
                <div className="text-3xl font-bold text-marvel-blue">{syncData.c?.length || 0}</div>
                <div className="text-sm text-gray-400">Cards in Collection</div>
              </div>
              {syncData.s && (
                <div className="grid grid-cols-3 gap-2 text-center text-sm">
                  <div>
                    <div className="text-green-400 font-bold">{syncData.s.wins || 0}</div>
                    <div className="text-gray-400 text-xs">Wins</div>
                  </div>
                  <div>
                    <div className="text-red-400 font-bold">{syncData.s.losses || 0}</div>
                    <div className="text-gray-400 text-xs">Losses</div>
                  </div>
                  <div>
                    <div className={`font-bold ${(syncData.s.cubes || 0) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                      {(syncData.s.cubes || 0) >= 0 ? '+' : ''}{syncData.s.cubes || 0}
                    </div>
                    <div className="text-gray-400 text-xs">Cubes</div>
                  </div>
                </div>
              )}
            </div>

            <p className="text-gray-400 text-sm mb-4 text-center">
              This will merge the synced collection with your current data.
            </p>

            <div className="flex gap-2">
              <button onClick={onConfirm}
                className="flex-1 bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import Collection
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-gray-600 text-white py-3 rounded-lg font-medium hover:bg-gray-500">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Phase 5: Toast notification helper
    const showToast = (message) => {
      const existing = document.querySelector('.toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.remove(), 3500);
    };

    // Phase 5: Linked Folder Sync Component (Chrome/Edge only)
    const LinkedFolderSync = ({ onSyncComplete }) => {
      const [folderHandle, setFolderHandle] = useState(null);
      const [isLinked, setIsLinked] = useState(false);
      const [lastSync, setLastSync] = useState(null);
      const [syncing, setSyncing] = useState(false);
      const [error, setError] = useState(null);

      // Check if File System Access API is supported
      const isSupported = typeof window !== 'undefined' && 'showDirectoryPicker' in window;

      // On mount, try to restore saved folder handle
      useEffect(() => {
        restoreFolderHandle();
      }, []);

      async function restoreFolderHandle() {
        try {
          const db = await openSyncDB();
          const handle = await db.get('settings', 'folderHandle');
          if (handle) {
            const permission = await handle.queryPermission({ mode: 'read' });
            if (permission === 'granted') {
              setFolderHandle(handle);
              setIsLinked(true);
              const syncTime = await db.get('settings', 'lastSyncTime');
              if (syncTime) setLastSync(new Date(syncTime));
            }
          }
        } catch (err) {
          console.log('No saved folder handle or permission expired');
        }
      }

      async function handleLinkFolder() {
        try {
          setError(null);

          const handle = await window.showDirectoryPicker({
            id: 'snap-nvprod',
            mode: 'read',
            startIn: 'desktop'
          });

          // Verify it looks like the right folder
          const files = [];
          for await (const entry of handle.values()) {
            files.push(entry.name);
          }

          const expectedFiles = ['CollectionState.json', 'ProfileState.json'];
          const hasExpectedFiles = expectedFiles.some(f => files.includes(f));

          if (!hasExpectedFiles) {
            setError("This doesn't look like the nvprod folder. Please select the folder containing CollectionState.json");
            return;
          }

          const db = await openSyncDB();
          await db.put('settings', handle, 'folderHandle');

          setFolderHandle(handle);
          setIsLinked(true);

          await syncFromFolder(handle);
        } catch (err) {
          if (err.name === 'AbortError') return;
          setError(`Failed to link folder: ${err.message}`);
        }
      }

      async function handleUnlink() {
        try {
          const db = await openSyncDB();
          await db.delete('settings', 'folderHandle');
          await db.delete('settings', 'lastSyncTime');

          setFolderHandle(null);
          setIsLinked(false);
          setLastSync(null);
        } catch (err) {
          console.error('Failed to unlink:', err);
        }
      }

      async function syncFromFolder(handle = folderHandle) {
        if (!handle) return;

        setSyncing(true);
        setError(null);

        try {
          const permission = await handle.requestPermission({ mode: 'read' });
          if (permission !== 'granted') {
            setError('Permission denied. Please re-link the folder.');
            setIsLinked(false);
            return;
          }

          const results = {
            collection: null,
            profile: null,
            mastery: null,
            battlePass: null
          };

          const fileMap = {
            'CollectionState.json': 'collection',
            'ProfileState.json': 'profile',
            'CharacterMasteryState.json': 'mastery',
            'BattlePassState.json': 'battlePass'
          };

          for (const [filename, key] of Object.entries(fileMap)) {
            try {
              const fileHandle = await handle.getFileHandle(filename);
              const file = await fileHandle.getFile();
              const content = await file.text();
              const json = JSON.parse(content);

              switch (key) {
                case 'collection':
                  results.collection = GameDataParser.parseCollection(json);
                  break;
                case 'profile':
                  results.profile = GameDataParser.parseProfile(json);
                  break;
                case 'mastery':
                  results.mastery = GameDataParser.parseMastery(json);
                  break;
                case 'battlePass':
                  results.battlePass = GameDataParser.parseBattlePass(json);
                  break;
              }
            } catch (err) {
              console.log(`Could not read ${filename}:`, err.message);
            }
          }

          const importResults = autoImportAll(results);

          const now = new Date();
          const db = await openSyncDB();
          await db.put('settings', now.toISOString(), 'lastSyncTime');
          setLastSync(now);

          showToast(`Sync complete!\n${importResults.map(r => ' ' + r).join('\n')}`);

          if (onSyncComplete) onSyncComplete();
          window.dispatchEvent(new Event('snap-data-updated'));
        } catch (err) {
          setError(`Sync failed: ${err.message}`);
        } finally {
          setSyncing(false);
        }
      }

      if (!isSupported) {
        return (
          <div className="linked-folder-section" style={{ opacity: 0.7 }}>
            <h4>Link Game Folder</h4>
            <div className="not-supported-msg">
              Folder linking requires Chrome or Edge browser.
              <br />
              Use drag & drop below instead.
            </div>
          </div>
        );
      }

      return (
        <div className="linked-folder-section">
          <h4>Link Game Folder</h4>
          <p className="description">
            Link your game data folder once, then sync with one click anytime.
          </p>

          {!isLinked ? (
            <div>
              <button className="link-folder-btn" onClick={handleLinkFolder}>
                Select nvprod Folder
              </button>
              <p style={{ fontSize: '0.75em', color: '#888', marginTop: '8px' }}>
                Navigate to:<br />
                <code style={{ background: '#1A1A1A', padding: '2px 6px', borderRadius: '4px', color: '#FFC107' }}>
                  %AppData%\LocalLow\Second Dinner\SNAP\Standalone\States\nvprod
                </code>
              </p>
            </div>
          ) : (
            <div className="linked-status">
              <div className="status-row">
                <span className="status-badge linked">Folder Linked</span>
                <button className="unlink-btn" onClick={handleUnlink}>Unlink</button>
              </div>

              <button className="sync-btn" onClick={() => syncFromFolder()} disabled={syncing}>
                {syncing ? 'Syncing...' : 'Sync Now'}
              </button>

              {lastSync && (
                <p className="last-sync">
                  Last synced: {lastSync.toLocaleString()}
                </p>
              )}
            </div>
          )}

          {error && (
            <div style={{ marginTop: '10px', padding: '10px', background: 'rgba(239,68,68,0.2)', borderRadius: '8px', color: '#ef4444', fontSize: '0.85em' }}>
              {error}
            </div>
          )}
        </div>
      );
    };

    // Phase 5: JSON Sync Preview Modal
    const JSONSyncPreviewModal = ({ data, onConfirm, onCancel }) => {
      const [selectedImports, setSelectedImports] = useState({
        collection: !!data.collection,
        stats: !!data.profile,
        cardPerformance: !!data.profile?.cardPerformance,
        mastery: !!data.mastery
      });

      return (
        <div className="modal-overlay">
          <div className="modal sync-preview-modal" style={{ padding: '20px' }}>
            <h3 style={{ margin: '0 0 16px 0', color: '#FFC107', fontFamily: 'Impact, sans-serif' }}>
              Game Data Found!
            </h3>

            {/* Collection Preview */}
            {data.collection && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.collection}
                    onChange={(e) => setSelectedImports(s => ({...s, collection: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Collection</span>
                </label>
                <div className="preview-stats-grid" style={{ gridTemplateColumns: '1fr' }}>
                  <div className="preview-stat">
                    <span className="value">{data.collection.count}</span>
                    <span className="label">cards found</span>
                  </div>
                </div>
              </div>
            )}

            {/* Profile Stats Preview */}
            {data.profile && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.stats}
                    onChange={(e) => setSelectedImports(s => ({...s, stats: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Lifetime Stats</span>
                </label>
                <div className="preview-stats-grid">
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.totalGames.toLocaleString()}</span>
                    <span className="label">Total Games</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value" style={{ color: '#22c55e' }}>{data.profile.stats.winRate}%</span>
                    <span className="label">Win Rate</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.wins.toLocaleString()}</span>
                    <span className="label">Wins</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.snaps.toLocaleString()}</span>
                    <span className="label">Snaps</span>
                  </div>
                </div>
              </div>
            )}

            {/* Card Performance Preview */}
            {data.profile?.cardPerformance && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.cardPerformance}
                    onChange={(e) => setSelectedImports(s => ({...s, cardPerformance: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Card Performance</span>
                </label>
                <div className="card-performance-preview">
                  <div>
                    <h5 style={{ margin: '0 0 6px 0', fontSize: '0.8em', color: '#22c55e' }}>Best</h5>
                    {data.profile.cardPerformance.top10.slice(0, 3).map((c, i) => (
                      <div key={i} className="card-stat positive">
                        <span className="card-name">{c.card}</span>
                        <span className="cubes">+{c.netCubes}</span>
                      </div>
                    ))}
                  </div>
                  <div>
                    <h5 style={{ margin: '0 0 6px 0', fontSize: '0.8em', color: '#ef4444' }}>Worst</h5>
                    {data.profile.cardPerformance.bottom10.slice(0, 3).map((c, i) => (
                      <div key={i} className="card-stat negative">
                        <span className="card-name">{c.card}</span>
                        <span className="cubes">{c.netCubes}</span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* Mastery Preview */}
            {data.mastery && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.mastery}
                    onChange={(e) => setSelectedImports(s => ({...s, mastery: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Character Mastery</span>
                </label>
                <div className="preview-stats-grid" style={{ gridTemplateColumns: 'repeat(3, 1fr)' }}>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.totalCards}</span>
                    <span className="label">Cards</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.avgLevel}</span>
                    <span className="label">Avg Level</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.maxedCards}</span>
                    <span className="label">Maxed</span>
                  </div>
                </div>
              </div>
            )}

            <div style={{ display: 'flex', gap: '10px', marginTop: '16px' }}>
              <button
                onClick={() => onConfirm(data, selectedImports)}
                style={{ flex: 1, padding: '12px', background: '#006EC7', color: 'white', border: 'none', borderRadius: '8px', fontWeight: 'bold', cursor: 'pointer' }}
              >
                Import Selected
              </button>
              <button
                onClick={onCancel}
                style={{ flex: 1, padding: '12px', background: '#4B5563', color: 'white', border: 'none', borderRadius: '8px', cursor: 'pointer' }}
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Phase 5: Drag & Drop JSON Sync Component
    const DragDropJSONSync = ({ onDataParsed }) => {
      const [dragOver, setDragOver] = useState(false);
      const [processing, setProcessing] = useState(false);
      const fileInputRef = useRef(null);

      const handleFileDrop = async (e) => {
        e.preventDefault();
        setDragOver(false);
        const files = Array.from(e.dataTransfer?.files || []);
        if (files.length > 0) processFiles(files);
      };

      const handleFileSelect = (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length > 0) processFiles(files);
      };

      const processFiles = async (files) => {
        setProcessing(true);

        const results = {
          collection: null,
          profile: null,
          mastery: null,
          battlePass: null
        };

        for (const file of files) {
          try {
            const content = await file.text();
            const json = JSON.parse(content);

            if (file.name === 'CollectionState.json' || file.name.includes('Collection')) {
              results.collection = GameDataParser.parseCollection(json);
            } else if (file.name === 'ProfileState.json' || file.name.includes('Profile')) {
              results.profile = GameDataParser.parseProfile(json);
            } else if (file.name === 'CharacterMasteryState.json' || file.name.includes('Mastery')) {
              results.mastery = GameDataParser.parseMastery(json);
            } else if (file.name === 'BattlePassState.json' || file.name.includes('BattlePass')) {
              results.battlePass = GameDataParser.parseBattlePass(json);
            } else {
              // Try to detect file type from content
              if (json?.ServerState?.CardInventory) {
                results.collection = GameDataParser.parseCollection(json);
              } else if (json?.ServerState?.Account) {
                results.profile = GameDataParser.parseProfile(json);
              } else if (json?.ServerState?.CharacterMasteryProgress) {
                results.mastery = GameDataParser.parseMastery(json);
              } else if (json?.ServerState?.BattlePass) {
                results.battlePass = GameDataParser.parseBattlePass(json);
              }
            }
          } catch (err) {
            console.error(`Failed to parse ${file.name}:`, err);
          }
        }

        setProcessing(false);

        if (Object.values(results).some(v => v !== null)) {
          onDataParsed(results);
        } else {
          showToast('No valid game data found in the selected files');
        }
      };

      return (
        <div className="drag-drop-section">
          <h4>Drag & Drop Files</h4>
          <p className="description">Works in all browsers</p>

          <div
            className={`drop-zone-json ${dragOver ? 'drag-over' : ''}`}
            onDrop={handleFileDrop}
            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
            onDragLeave={() => setDragOver(false)}
            onClick={() => fileInputRef.current?.click()}
          >
            {processing ? (
              <div>
                <div className="spinner" style={{ margin: '0 auto 10px' }}></div>
                <span>Processing files...</span>
              </div>
            ) : (
              <>
                <span style={{ fontSize: '2.5em', display: 'block', marginBottom: '8px' }}></span>
                <p style={{ margin: '0 0 8px 0', fontWeight: 'bold' }}>Drop JSON files here</p>
                <p style={{ margin: 0, fontSize: '0.85em', color: '#888' }}>
                  CollectionState.json, ProfileState.json, etc.
                </p>
                <code>%AppData%\LocalLow\Second Dinner\SNAP\Standalone\States\nvprod\</code>
              </>
            )}
          </div>

          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileSelect}
            accept=".json"
            multiple
            style={{ display: 'none' }}
          />

          <div style={{ marginTop: '12px', padding: '10px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
            <p style={{ margin: '0 0 6px 0', fontSize: '0.85em', fontWeight: 'bold', color: '#FFC107' }}>Supported Files:</p>
            <ul style={{ margin: 0, paddingLeft: '18px', fontSize: '0.8em', color: '#aaa' }}>
              <li><strong>CollectionState.json</strong> - Your card collection</li>
              <li><strong>ProfileState.json</strong> - Lifetime stats & card performance</li>
              <li><strong>CharacterMasteryState.json</strong> - Card mastery levels</li>
              <li><strong>BattlePassState.json</strong> - Season pass progress</li>
            </ul>
            <p style={{ margin: '8px 0 0 0', fontSize: '0.8em', color: '#006EC7' }}>
              Tip: Select all 4 files and drop them together!
            </p>
          </div>
        </div>
      );
    };

    // Phase 5: Card Performance View (Analytics Tab)
    const CardPerformanceView = () => {
      const [performanceData, setPerformanceData] = useState(null);
      const [profileStats, setProfileStats] = useState(null);
      const [sortBy, setSortBy] = useState('netCubes');
      const [filterType, setFilterType] = useState('all');

      useEffect(() => {
        loadData();
        window.addEventListener('snap-data-updated', loadData);
        return () => window.removeEventListener('snap-data-updated', loadData);
      }, []);

      const loadData = () => {
        const perfData = loadFromStorage('snap_card_performance', null);
        const stats = loadFromStorage('snap_profile_stats', null);
        setPerformanceData(perfData);
        setProfileStats(stats);
      };

      if (!performanceData && !profileStats) {
        return (
          <div className="px-4 pb-20">
            <Header title="ANALYTICS" />
            <div className="import-prompt" style={{ padding: '40px 20px' }}>
              <p style={{ fontSize: '1.1em', marginBottom: '12px' }}>No game data imported yet.</p>
              <p style={{ fontSize: '0.9em' }}>
                Import your game files from<br />
                <a href="#" onClick={(e) => { e.preventDefault(); }}>Settings &rarr; PC Game Data Sync</a>
              </p>
            </div>
          </div>
        );
      }

      const cards = performanceData ? Object.entries(performanceData.cards)
        .map(([card, data]) => ({ card, ...data }))
        .filter(c => {
          if (filterType === 'positive') return c.netCubes > 0;
          if (filterType === 'negative') return c.netCubes < 0;
          return true;
        })
        .sort((a, b) => {
          if (sortBy === 'name') return a.card.localeCompare(b.card);
          return b.netCubes - a.netCubes;
        }) : [];

      const totalPositive = cards.filter(c => c.netCubes > 0).reduce((sum, c) => sum + c.netCubes, 0);
      const totalNegative = cards.filter(c => c.netCubes < 0).reduce((sum, c) => sum + c.netCubes, 0);

      return (
        <div className="px-4 pb-20">
          <Header title="ANALYTICS" />

          {/* Lifetime Stats */}
          {profileStats && (
            <div className="stats-section">
              <h3>Lifetime Stats</h3>
              <div className="stats-grid">
                <div className="stat-card">
                  <span className="stat-value">{(profileStats.totalGames || profileStats.wins + profileStats.losses).toLocaleString()}</span>
                  <span className="stat-label">Total Games</span>
                </div>
                <div className="stat-card highlight">
                  <span className="stat-value">{profileStats.winRate}%</span>
                  <span className="stat-label">Win Rate</span>
                </div>
                <div className="stat-card positive">
                  <span className="stat-value">{(profileStats.wins || 0).toLocaleString()}</span>
                  <span className="stat-label">Wins</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value">{(profileStats.snaps || 0).toLocaleString()}</span>
                  <span className="stat-label">Snaps</span>
                </div>
              </div>
              {profileStats.snapId && (
                <p className="data-source">
                  {profileStats.snapId}  Imported {new Date(profileStats.importedAt || Date.now()).toLocaleDateString()}
                </p>
              )}
            </div>
          )}

          {/* Currency Stats */}
          {profileStats?.currencies && (
            <div className="stats-section">
              <h3>Currencies</h3>
              <div className="stats-grid" style={{ gridTemplateColumns: 'repeat(3, 1fr)' }}>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#22c55e' }}>{(profileStats.currencies.credits || 0).toLocaleString()}</span>
                  <span className="stat-label">Credits</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#FFC107' }}>{(profileStats.currencies.gold || 0).toLocaleString()}</span>
                  <span className="stat-label">Gold</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#8B5CF6' }}>{(profileStats.currencies.tokens || 0).toLocaleString()}</span>
                  <span className="stat-label">Tokens</span>
                </div>
              </div>
            </div>
          )}

          {/* Card Performance */}
          {performanceData && cards.length > 0 && (
            <>
              <div className="stats-section" style={{ padding: '12px 16px' }}>
                <h3 style={{ marginBottom: '8px' }}>Card Performance</h3>
                <p style={{ margin: 0, fontSize: '0.8em', color: '#888' }}>Net cubes earned/lost per card (lifetime)</p>

                <div className="performance-summary" style={{ marginTop: '12px' }}>
                  <div className="summary-stat positive">
                    <span className="label">Gained</span>
                    <span className="value">+{totalPositive.toLocaleString()}</span>
                  </div>
                  <div className="summary-stat negative">
                    <span className="label">Lost</span>
                    <span className="value">{totalNegative.toLocaleString()}</span>
                  </div>
                  <div className="summary-stat net">
                    <span className="label">Net</span>
                    <span className="value">{(totalPositive + totalNegative).toLocaleString()}</span>
                  </div>
                </div>

                <div style={{ display: 'flex', gap: '8px', marginBottom: '12px' }}>
                  <select
                    value={filterType}
                    onChange={(e) => setFilterType(e.target.value)}
                    style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
                  >
                    <option value="all">All Cards ({Object.keys(performanceData.cards).length})</option>
                    <option value="positive">Winners Only</option>
                    <option value="negative">Losers Only</option>
                  </select>
                  <select
                    value={sortBy}
                    onChange={(e) => setSortBy(e.target.value)}
                    style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
                  >
                    <option value="netCubes">By Cubes</option>
                    <option value="name">By Name</option>
                  </select>
                </div>

                <div style={{ maxHeight: '350px', overflowY: 'auto' }}>
                  {cards.map((card, i) => (
                    <div
                      key={card.card}
                      className={`performance-card ${card.netCubes >= 0 ? 'positive' : 'negative'}`}
                    >
                      <span className="rank">#{i + 1}</span>
                      <span className="card-name">{card.card}</span>
                      <span className="net-cubes">
                        {card.netCubes >= 0 ? '+' : ''}{card.netCubes}
                      </span>
                    </div>
                  ))}
                </div>
              </div>

              <p style={{ textAlign: 'center', fontSize: '0.75em', color: '#666' }}>
                Data from: {new Date(performanceData.importedAt).toLocaleDateString()}
              </p>
            </>
          )}
        </div>
      );
    };

    // Settings Component
    const Settings = ({ settings, setSettings, collection, matches, setCollection, setMatches, aiConfig, setAiConfig, decks, setDecks }) => {
      const [showImport, setShowImport] = useState(false);
      const [importData, setImportData] = useState('');
      const [showAdvanced, setShowAdvanced] = useState(false);
      const [testStatus, setTestStatus] = useState({});
      const [rapidApiKey, setRapidApiKey] = useState(loadFromStorage('snap_rapidapi_key', ''));
      const [isRefreshingCards, setIsRefreshingCards] = useState(false);

      // Phase 4: Log Ingestor state
      const [isDragOver, setIsDragOver] = useState(false);
      const [isProcessingLog, setIsProcessingLog] = useState(false);
      const [logError, setLogError] = useState(null);
      const [showLogPreview, setShowLogPreview] = useState(false);
      const [parsedMatches, setParsedMatches] = useState([]);
      const [skippedCount, setSkippedCount] = useState(0);
      const fileInputRef = useRef(null);

      // Phase 4: QR Sync state
      const [qrDataUrl, setQrDataUrl] = useState(null);
      const [qrError, setQrError] = useState(null);

      // Phase 5: JSON Sync state
      const [showJSONSyncPreview, setShowJSONSyncPreview] = useState(false);
      const [jsonSyncData, setJSONSyncData] = useState(null);

      // Google OAuth 2.0 state
      const [googleSignedIn, setGoogleSignedIn] = useState(isGoogleTokenValid());

      // Google OAuth initialization
      useEffect(() => {
        // Initialize OAuth 2.0 token client
        const initOAuth = () => {
          if (window.google?.accounts?.oauth2) {
            initGoogleOAuth((accessToken) => {
              // Token received callback
              setGoogleSignedIn(true);
              setAiConfig(prev => ({
                ...prev,
                provider: 'gemini-oauth',
                model: AIProviders['gemini-oauth'].defaultModel
              }));
              setTestStatus(prev => ({ ...prev, 'gemini-oauth': 'success' }));
              showToast('Signed in with Google');
            });
          }
        };

        // Try to init now, or wait for script to load
        if (window.google?.accounts?.oauth2) {
          initOAuth();
        } else {
          const checkGoogle = setInterval(() => {
            if (window.google?.accounts?.oauth2) {
              clearInterval(checkGoogle);
              initOAuth();
            }
          }, 500);
          // Stop checking after 10 seconds
          setTimeout(() => clearInterval(checkGoogle), 10000);
        }

        // Check if we have a valid token
        if (isGoogleTokenValid()) {
          setGoogleSignedIn(true);
        }
      }, []);

      const handleGoogleSignIn = async () => {
        try {
          await requestGoogleAccessToken();
          setGoogleSignedIn(true);
          setAiConfig(prev => ({
            ...prev,
            provider: 'gemini-oauth',
            model: AIProviders['gemini-oauth'].defaultModel
          }));
          setTestStatus(prev => ({ ...prev, 'gemini-oauth': 'success' }));
        } catch (err) {
          if (err.message !== 'popup_closed') {
            showToast('Google sign-in failed: ' + err.message);
          }
        }
      };

      const handleGoogleSignOut = () => {
        signOutGoogle();
        setGoogleSignedIn(false);
        setAiConfig(prev => ({ ...prev, provider: '' }));
        setTestStatus(prev => ({ ...prev, 'gemini-oauth': null }));
        showToast('Signed out from Google');
      };

      const setApiKey = (provider, key) => {
        setAiConfig(prev => ({
          ...prev,
          apiKeys: { ...prev.apiKeys, [provider]: key }
        }));
      };

      const selectProvider = (providerId) => {
        const provider = AIProviders[providerId];
        setAiConfig(prev => ({
          ...prev,
          provider: providerId,
          model: provider.defaultModel
        }));
      };

      const testConnection = async (providerId) => {
        setTestStatus(prev => ({ ...prev, [providerId]: 'testing' }));
        try {
          const testMessages = [{ role: 'user', content: 'Say "Connection successful!" in 5 words or less.' }];
          const model = aiConfig.model || AIProviders[providerId]?.defaultModel;

          switch (providerId) {
            case 'gemini-oauth':
              if (!isGoogleTokenValid()) {
                throw new Error('Please sign in with Google first');
              }
              await callGeminiOAuth(testMessages, model);
              break;
            case 'gemini':
              await callGeminiAPIKey(testMessages, model, aiConfig.apiKeys?.gemini);
              break;
            case 'groq':
              await callGroq(testMessages, model, aiConfig.apiKeys?.groq);
              break;
            case 'claude':
              await callClaude(testMessages, model, aiConfig.apiKeys?.claude);
              break;
            case 'openai':
              await callOpenAI(testMessages, model, aiConfig.apiKeys?.openai);
              break;
            case 'local':
              await callLocal(testMessages, model, aiConfig.localEndpoint);
              break;
          }
          setTestStatus(prev => ({ ...prev, [providerId]: 'success' }));
        } catch (err) {
          console.error('Test failed:', err);
          setTestStatus(prev => ({ ...prev, [providerId]: 'error' }));
        }
      };

      const refreshCardData = async () => {
        setIsRefreshingCards(true);
        try {
          // Try marvelsnap.io API first (353+ cards)
          let normalizedCards = [];
          try {
            const response = await fetch('https://marvelsnap.io/api/search.php?database&limit=500');
            if (response.ok) {
              const data = await response.json();
              normalizedCards = (data || []).filter(c => c.type === 'Character').map(card => ({
                name: card.name,
                cost: parseInt(card.cost) || 0,
                power: parseInt(card.power) || 0,
                ability: card.ability || '',
                series: card.pool?.includes('Pool 1') || card.pool?.includes('Starter') ? 1 :
                        card.pool?.includes('Pool 2') ? 2 :
                        card.pool?.includes('Pool 3') ? 3 :
                        card.pool?.includes('Series 4') ? 4 : 5
              }));
            }
          } catch (e) {
            console.log('marvelsnap.io failed, trying MarvelSnapZone...');
          }

          // Fallback to MarvelSnapZone if marvelsnap.io fails
          if (normalizedCards.length === 0) {
            const response = await fetch('https://marvelsnapzone.com/getinfo/?searchtype=cards&searchcardstype=true');
            if (!response.ok) throw new Error('Both APIs failed');
            const data = await response.json();
            normalizedCards = (data.success?.cards || []).map(card => ({
              name: card.name,
              cost: parseInt(card.cost) || 0,
              power: parseInt(card.power) || 0,
              ability: card.ability || card.description || '',
              series: parseInt(card.source?.match(/Series (\d)/)?.[1]) || 3
            }));
          }

          if (normalizedCards.length > 0) {
            saveToStorage('snap_card_cache', { data: normalizedCards, timestamp: Date.now() });
            alert(`Card data refreshed! ${normalizedCards.length} cards loaded.`);
            window.location.reload(); // Reload to apply new card data
          } else {
            throw new Error('No cards returned from API');
          }
        } catch (err) {
          alert('Failed to refresh cards: ' + err.message + '. Using built-in card database.');
        } finally {
          setIsRefreshingCards(false);
        }
      };

      // Phase 4: Log file handlers
      const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
      };

      const handleLogDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
        const file = e.dataTransfer?.files[0];
        if (file) processLogFile(file);
      };

      const handleFileSelect = (e) => {
        const file = e.target.files?.[0];
        if (file) processLogFile(file);
      };

      const processLogFile = (file) => {
        setLogError(null);

        // Validate file
        if (!file.name.endsWith('.log') && !file.name.endsWith('.txt')) {
          setLogError('Please select a .log or .txt file');
          return;
        }

        // Size check (50MB limit)
        if (file.size > 50 * 1024 * 1024) {
          setLogError(LogErrors.FILE_TOO_LARGE);
          return;
        }

        setIsProcessingLog(true);

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const content = event.target.result;
            const parsed = LogParser.parsePlayerLog(content);

            if (parsed.matches.length === 0) {
              setLogError(LogErrors.NO_MATCHES);
              setIsProcessingLog(false);
              return;
            }

            // Check for duplicates against existing data
            const merged = LogParser.mergeWithExisting(parsed.matches, matches);

            setParsedMatches(merged.added);
            setSkippedCount(merged.skipped);
            setShowLogPreview(true);
            setIsProcessingLog(false);
          } catch (err) {
            console.error('Log parse error:', err);
            setLogError(LogErrors.PARSE_FAILED);
            setIsProcessingLog(false);
          }
        };

        reader.onerror = () => {
          setLogError(LogErrors.READ_ERROR);
          setIsProcessingLog(false);
        };

        reader.readAsText(file);
      };

      const handleLogImport = (matchesToImport) => {
        setMatches(prev => [...prev, ...matchesToImport].sort((a, b) =>
          new Date(b.timestamp) - new Date(a.timestamp)
        ));
        setShowLogPreview(false);
        setParsedMatches([]);
        alert(`Successfully imported ${matchesToImport.length} matches!`);
      };

      // Phase 5: JSON Sync Confirm Handler
      const handleJSONSyncConfirm = (data, selectedImports) => {
        const timestamp = new Date().toISOString();
        const syncLog = [];

        // Import Collection
        if (selectedImports.collection && data.collection) {
          const existingCollection = JSON.parse(localStorage.getItem('snap_collection') || '{"owned":[]}');
          const mergedCards = [...new Set([...existingCollection.owned, ...data.collection.cards])];

          const newCollection = {
            owned: mergedCards,
            lastUpdated: timestamp,
            source: 'JSONImport'
          };
          localStorage.setItem('snap_collection', JSON.stringify(newCollection));
          setCollection(newCollection);

          syncLog.push(`Collection: ${mergedCards.length} cards`);
        }

        // Import Profile Stats
        if (selectedImports.stats && data.profile) {
          localStorage.setItem('snap_profile_stats', JSON.stringify({
            ...data.profile.stats,
            snapId: data.profile.player.snapId,
            currencies: data.profile.currencies,
            importedAt: timestamp,
            source: 'ProfileState.json'
          }));

          syncLog.push(`Stats: ${data.profile.stats.totalGames.toLocaleString()} games`);
        }

        // Import Card Performance
        if (selectedImports.cardPerformance && data.profile?.cardPerformance) {
          const performanceMap = {};
          data.profile.cardPerformance.all.forEach(({ card, netCubes }) => {
            performanceMap[card] = { netCubes };
          });

          localStorage.setItem('snap_card_performance', JSON.stringify({
            cards: performanceMap,
            importedAt: timestamp,
            source: 'ProfileState.json'
          }));

          syncLog.push(`Card Performance: ${data.profile.cardPerformance.all.length} cards tracked`);
        }

        // Import Mastery
        if (selectedImports.mastery && data.mastery) {
          localStorage.setItem('snap_mastery', JSON.stringify({
            cards: data.mastery.cards,
            importedAt: timestamp,
            source: 'CharacterMasteryState.json'
          }));

          syncLog.push(`Mastery: ${data.mastery.totalCards} cards`);
        }

        // Update sync history
        const syncHistory = JSON.parse(localStorage.getItem('snap_sync_history') || '[]');
        syncHistory.unshift({
          date: timestamp,
          imported: syncLog
        });
        localStorage.setItem('snap_sync_history', JSON.stringify(syncHistory.slice(0, 10)));

        setShowJSONSyncPreview(false);
        setJSONSyncData(null);

        showToast(`Sync Complete!\n${syncLog.map(r => ' ' + r).join('\n')}`);
        window.dispatchEvent(new Event('snap-data-updated'));
      };

      // Phase 4: QR Code generation
      const generateSyncQR = async () => {
        setQrError(null);
        setQrDataUrl(null);

        try {
          const syncData = VaultManager.generateSyncData(collection, matches);
          const compressed = VaultManager.compressForQR(syncData);

          if (!compressed) {
            setQrError('Failed to compress data');
            return;
          }

          // QR codes have size limits (~2.5KB for reliable scanning)
          if (compressed.length > 2500) {
            setQrError('Collection too large for QR sync. Use file export instead.');
            return;
          }

          const syncUrl = `https://platano78.github.io/Marvel-Snap-Tactics-/?sync=${compressed}`;

          // Generate QR code using the QRCode library
          const dataUrl = await QRCode.toDataURL(syncUrl, {
            width: 200,
            margin: 2,
            color: { dark: '#1A1A1A', light: '#FFFFFF' }
          });

          setQrDataUrl(dataUrl);
        } catch (err) {
          console.error('QR generation error:', err);
          setQrError('Failed to generate QR code');
        }
      };

      // Phase 4: Vault export
      const exportVault = () => {
        const vault = VaultManager.exportFullVault(collection, matches, settings);
        const blob = new Blob([JSON.stringify(vault, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `snapapoulous-vault-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      };

      const handleExport = (type) => {
        let data, filename;
        if (type === 'all') {
          data = { collection, matches, decks, settings, aiConfig: { ...aiConfig, apiKeys: {}, googleToken: null } };
          filename = `snapapoulous-backup-${new Date().toISOString().split('T')[0]}.json`;
        } else if (type === 'collection') {
          data = collection;
          filename = `snap-collection-${new Date().toISOString().split('T')[0]}.json`;
        } else if (type === 'decks') {
          data = decks;
          filename = `snap-decks-${new Date().toISOString().split('T')[0]}.json`;
        } else {
          data = matches;
          filename = `snap-matches-${new Date().toISOString().split('T')[0]}.json`;
        }
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
      };

      const handleImport = () => {
        try {
          const data = JSON.parse(importData);
          if (data.collection && data.matches) {
            setCollection(data.collection);
            setMatches(data.matches);
            if (data.decks) setDecks(data.decks);
            if (data.settings) setSettings(data.settings);
            alert('Data imported successfully!');
          } else if (data.owned) {
            setCollection(data);
            alert('Collection imported!');
          } else if (Array.isArray(data) && data[0]?.cards) {
            setDecks(data);
            alert('Decks imported!');
          } else if (Array.isArray(data)) {
            setMatches(data);
            alert('Matches imported!');
          } else {
            alert('Unrecognized format');
          }
          setShowImport(false);
          setImportData('');
        } catch { alert('Invalid JSON'); }
      };

      const StatusBadge = ({ status }) => {
        if (!status) return null;
        if (status === 'testing') return <span className="text-yellow-400 text-xs">Testing...</span>;
        if (status === 'success') return <span className="text-green-400 text-xs">Connected</span>;
        return <span className="text-red-400 text-xs">Failed</span>;
      };

      const mainProviders = Object.values(AIProviders).filter(p => !p.advanced);
      const advancedProviders = Object.values(AIProviders).filter(p => p.advanced);

      return (
        <div className="px-4 pb-20">
          <Header title="SETTINGS" />

          {/* App Info */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex items-center gap-3">
              <div className="w-12 h-12 bg-marvel-red rounded-lg flex items-center justify-center">
                <span className="text-2xl font-comic text-white">S</span>
              </div>
              <div>
                <div className="text-white font-bold">Snapapoulous Prime</div>
                <div className="text-gray-400 text-sm">v2.2.2 - Card Database Fix</div>
              </div>
            </div>
          </div>

          {/* PC Game Data Sync - Phase 5 */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4 pc-sync-section">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">PC Game Data Sync</h3>
            <p className="text-gray-400 text-sm mb-4">
              Import your collection, stats, and card performance directly from game files.
            </p>

            {/* Method 1: Linked Folder (Chrome/Edge) */}
            <LinkedFolderSync onSyncComplete={() => {
              setCollection(loadFromStorage('snap_collection', { owned: [], lastUpdated: new Date().toISOString() }));
            }} />

            <div className="sync-divider">
              <span>or</span>
            </div>

            {/* Method 2: Drag & Drop JSON (All Browsers) */}
            <DragDropJSONSync onDataParsed={(data) => {
              setJSONSyncData(data);
              setShowJSONSyncPreview(true);
            }} />
          </div>

          {/* Legacy Log Sync (Player.log) */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Match Log Import</h3>
            <p className="text-gray-400 text-sm mb-4">
              Import match history from Player.log (legacy method).
            </p>

            <div
              className={`drop-zone ${isDragOver ? 'drag-over' : ''}`}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onDrop={handleLogDrop}
              onClick={() => fileInputRef.current?.click()}
            >
              {isProcessingLog ? (
                <div className="flex flex-col items-center">
                  <div className="spinner mb-2"></div>
                  <span className="text-gray-300">Analyzing Player.log...</span>
                  <span className="text-gray-500 text-xs mt-1">This may take a moment for large files</span>
                </div>
              ) : (
                <>
                  <span className="drop-icon"></span>
                  <span className="text-gray-300">Drop Player.log here or click to browse</span>
                  <span className="file-path">
                    Windows: %AppData%\LocalLow\Second Dinner\SNAP\...\Player.log
                  </span>
                </>
              )}
            </div>
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileSelect}
              accept=".log,.txt"
              className="hidden"
            />

            {logError && (
              <div className="mt-3 bg-red-900/50 border border-red-500 rounded-lg p-3">
                <p className="text-red-300 text-sm">{logError}</p>
              </div>
            )}
          </div>

          {/* QR Sync - Phase 4 */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Cross-Device Sync</h3>
            <p className="text-gray-400 text-sm mb-4">
              Generate a QR code to quickly sync your collection to another device.
            </p>

            <button
              onClick={generateSyncQR}
              className="w-full bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600 mb-3"
            >
               Generate Sync QR Code
            </button>

            {qrError && (
              <div className="bg-red-900/50 border border-red-500 rounded-lg p-3 mb-3">
                <p className="text-red-300 text-sm">{qrError}</p>
              </div>
            )}

            {qrDataUrl && (
              <div className="text-center">
                <div className="qr-container inline-block mb-2">
                  <img src={qrDataUrl} alt="Sync QR Code" />
                </div>
                <p className="text-gray-400 text-xs">Scan with your phone camera to sync collection</p>
              </div>
            )}
          </div>

          {/* AI Provider Configuration */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-4">AI Provider</h3>

            {/* Google OAuth - Primary */}
            <div className="mb-4 p-4 bg-gray-700 rounded-lg border-2 border-marvel-blue">
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2">
                  <span className="text-white font-medium">Google (Gemini)</span>
                  <span className="bg-marvel-blue text-white text-xs px-2 py-0.5 rounded">Recommended</span>
                </div>
                <StatusBadge status={testStatus['gemini-oauth']} />
              </div>
              <p className="text-gray-400 text-sm mb-3">One-click sign in, no API key needed</p>

              {googleSignedIn ? (
                <div className="flex gap-2">
                  <button onClick={() => selectProvider('gemini-oauth')}
                    className={`flex-1 py-2 rounded font-medium ${aiConfig.provider === 'gemini-oauth' ? 'bg-marvel-blue text-white' : 'bg-gray-600 text-gray-300'}`}>
                    {aiConfig.provider === 'gemini-oauth' ? 'Selected' : 'Use This'}
                  </button>
                  <button onClick={() => testConnection('gemini-oauth')}
                    className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-500">Test</button>
                  <button onClick={handleGoogleSignOut}
                    className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-500">Sign Out</button>
                </div>
              ) : (
                <div>
                  <button onClick={handleGoogleSignIn}
                    className="w-full bg-white text-gray-800 py-3 rounded-lg font-medium flex items-center justify-center gap-2 hover:bg-gray-100">
                    <svg className="w-5 h-5" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Continue with Google
                  </button>
                </div>
              )}
            </div>

            {/* API Key Providers */}
            {mainProviders.filter(p => p.id !== 'gemini-oauth').map(provider => (
              <div key={provider.id} className="mb-3 p-3 bg-gray-700 rounded-lg">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-white font-medium">{provider.name}</span>
                  <StatusBadge status={testStatus[provider.id]} />
                </div>
                <p className="text-gray-400 text-xs mb-2">{provider.description}</p>
                <div className="flex gap-2">
                  <input type="password" placeholder="API Key..."
                    value={aiConfig.apiKeys?.[provider.id] || ''}
                    onChange={(e) => setApiKey(provider.id, e.target.value)}
                    className="flex-1 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                  <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                    disabled={!aiConfig.apiKeys?.[provider.id]}
                    className="bg-marvel-blue text-white px-3 py-2 rounded text-sm hover:bg-blue-600 disabled:opacity-50">
                    Test
                  </button>
                </div>
                {aiConfig.provider === provider.id && (
                  <div className="mt-2">
                    <select value={aiConfig.model || provider.defaultModel}
                      onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                      className="w-full bg-gray-600 text-white rounded px-2 py-1 text-sm border border-gray-500">
                      {provider.models.map(m => <option key={m} value={m}>{m}</option>)}
                    </select>
                  </div>
                )}
              </div>
            ))}

            {/* Advanced Section */}
            <button onClick={() => setShowAdvanced(!showAdvanced)}
              className="w-full flex items-center justify-between py-2 text-gray-400 hover:text-white">
              <span className="text-sm">Advanced Options</span>
              <span>{showAdvanced ? '' : ''}</span>
            </button>

            {showAdvanced && (
              <div className="mt-3 space-y-3">
                {advancedProviders.map(provider => (
                  <div key={provider.id} className="p-3 bg-gray-700 rounded-lg">
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-white font-medium">{provider.name}</span>
                      <StatusBadge status={testStatus[provider.id]} />
                    </div>
                    <p className="text-gray-400 text-xs mb-2">{provider.description}</p>
                    <div className="flex gap-2">
                      <input type="text"
                        placeholder="http://localhost:11434"
                        value={aiConfig.localEndpoint || ''}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, localEndpoint: e.target.value }))}
                        className="flex-1 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                      <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                        className="bg-gray-600 text-white px-3 py-2 rounded text-sm hover:bg-gray-500">Test</button>
                    </div>
                    <p className="text-gray-500 text-xs mt-1">Common ports: Ollama (11434), LM Studio (1234), vLLM (8000)</p>
                    {aiConfig.provider === provider.id && (
                      <input type="text" placeholder="Model name..."
                        value={aiConfig.model || ''}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                        className="w-full mt-2 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                    )}
                  </div>
                ))}
              </div>
            )}

            {/* Current Selection */}
            {aiConfig.provider && (
              <div className="mt-4 p-3 bg-green-900/30 border border-green-600 rounded-lg">
                <div className="text-green-400 text-sm">
                  Active: <strong>{AIProviders[aiConfig.provider]?.name}</strong>
                  {aiConfig.model && <span className="text-green-300"> ({aiConfig.model})</span>}
                </div>
              </div>
            )}
          </div>

          {/* Card Database */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Card Database</h3>
            <p className="text-gray-400 text-sm mb-3">Fetch latest card data from MarvelSnapZone. No API key required.</p>
            <button onClick={refreshCardData} disabled={isRefreshingCards}
              className="w-full bg-series-3 text-white py-2 rounded hover:opacity-80 disabled:opacity-50">
              {isRefreshingCards ? 'Refreshing...' : 'Refresh Card Data'}
            </button>
            <p className="text-gray-500 text-xs mt-2">
              Data source: <a href="https://marvelsnapzone.com" target="_blank" className="text-marvel-blue hover:underline">MarvelSnapZone</a>
            </p>
          </div>

          {/* Export/Import */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Export Data</h3>
            <div className="space-y-2 mb-4">
              <button onClick={exportVault} className="w-full bg-marvel-gold text-black py-3 rounded-lg font-medium hover:bg-yellow-400 flex items-center justify-center gap-2">
                <span></span> Export Full Vault (Recommended)
              </button>
              <div className="grid grid-cols-4 gap-2">
                <button onClick={() => handleExport('all')} className="bg-marvel-blue text-white py-2 rounded text-sm hover:bg-blue-600">Backup</button>
                <button onClick={() => handleExport('collection')} className="bg-series-3 text-white py-2 rounded text-sm hover:opacity-80">Collection</button>
                <button onClick={() => handleExport('matches')} className="bg-series-2 text-white py-2 rounded text-sm hover:opacity-80">Matches</button>
                <button onClick={() => handleExport('decks')} className="bg-series-4 text-black py-2 rounded text-sm hover:opacity-80">Decks</button>
              </div>
            </div>

            <h3 className="text-lg font-comic text-marvel-gold mb-3">Import Data</h3>
            {!showImport ? (
              <button onClick={() => setShowImport(true)} className="w-full bg-gray-700 text-white py-2 rounded hover:bg-gray-600">
                Import from JSON
              </button>
            ) : (
              <div className="space-y-2">
                <textarea value={importData} onChange={(e) => setImportData(e.target.value)}
                  placeholder="Paste JSON data here..."
                  className="w-full h-24 bg-gray-700 text-white rounded px-3 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none text-sm" />
                <div className="flex gap-2">
                  <button onClick={handleImport} className="flex-1 bg-marvel-blue text-white py-2 rounded hover:bg-blue-600">Import</button>
                  <button onClick={() => { setShowImport(false); setImportData(''); }} className="flex-1 bg-gray-600 text-white py-2 rounded hover:bg-gray-500">Cancel</button>
                </div>
              </div>
            )}
          </div>

          {/* Danger Zone */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border border-red-500/50">
            <h3 className="text-lg font-comic text-red-400 mb-3">Danger Zone</h3>
            <button onClick={() => {
              if (confirm('Clear ALL data including AI settings?')) {
                localStorage.clear();
                setCollection({ owned: [], lastUpdated: new Date().toISOString() });
                setMatches([]);
                setDecks([]);
                setSettings({ theme: 'dark' });
                setAiConfig({ provider: '', model: '', apiKeys: {}, googleToken: null, localEndpoint: 'http://localhost:11434' });
                alert('All data cleared');
              }
            }} className="w-full bg-red-600 text-white py-2 rounded hover:bg-red-500">Clear All Data</button>
          </div>

          {/* Log Preview Modal */}
          {showLogPreview && (
            <LogPreviewModal
              matches={parsedMatches}
              skippedCount={skippedCount}
              onConfirm={handleLogImport}
              onCancel={() => { setShowLogPreview(false); setParsedMatches([]); }}
            />
          )}

          {/* JSON Sync Preview Modal - Phase 5 */}
          {showJSONSyncPreview && jsonSyncData && (
            <JSONSyncPreviewModal
              data={jsonSyncData}
              onConfirm={handleJSONSyncConfirm}
              onCancel={() => { setShowJSONSyncPreview(false); setJSONSyncData(null); }}
            />
          )}
        </div>
      );
    };

    // ==================== MAIN APP ====================
    const App = () => {
      const [activeTab, setActiveTab] = useState('dashboard');
      const [collection, setCollection] = useState(() => loadFromStorage('snap_collection', { owned: [], lastUpdated: new Date().toISOString() }));
      const [matches, setMatches] = useState(() => loadFromStorage('snap_matches', []));
      const [decks, setDecks] = useState(() => loadFromStorage('snap_decks', []));
      const [settings, setSettings] = useState(() => loadFromStorage('snap_settings', { theme: 'dark' }));
      const [aiConfig, setAiConfig] = useState(() => loadFromStorage('snap_ai_config', {
        provider: '',
        model: '',
        apiKeys: {},
        googleToken: null,
        localEndpoint: 'http://localhost:11434'
      }));

      // Phase 4: URL Sync state
      const [syncImportData, setSyncImportData] = useState(null);
      const [showSyncConfirm, setShowSyncConfirm] = useState(false);

      useEffect(() => { saveToStorage('snap_collection', collection); }, [collection]);
      useEffect(() => { saveToStorage('snap_matches', matches); }, [matches]);
      useEffect(() => { saveToStorage('snap_decks', decks); }, [decks]);
      useEffect(() => { saveToStorage('snap_settings', settings); }, [settings]);
      useEffect(() => { saveToStorage('snap_ai_config', aiConfig); }, [aiConfig]);

      // Phase 4: Check for sync parameter in URL on load
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const syncData = params.get('sync');

        if (syncData) {
          try {
            const data = VaultManager.decompressFromQR(syncData);

            if (data && data.v === 1 && data.c) {
              setSyncImportData(data);
              setShowSyncConfirm(true);

              // Clean URL
              window.history.replaceState({}, '', window.location.pathname);
            }
          } catch (e) {
            console.error('Invalid sync data:', e);
          }
        }
      }, []);

      const handleSyncImport = () => {
        if (syncImportData && syncImportData.c) {
          // Merge collections - add new cards without removing existing
          const existingOwned = new Set(collection.owned || []);
          syncImportData.c.forEach(card => existingOwned.add(card));

          setCollection({
            owned: Array.from(existingOwned),
            lastUpdated: new Date().toISOString()
          });

          setShowSyncConfirm(false);
          setSyncImportData(null);
          alert(`Synced ${syncImportData.c.length} cards to your collection!`);
        }
      };

      const handleQuickMatch = (result, cubes) => {
        setMatches(prev => [...prev, {
          id: generateId(),
          timestamp: new Date().toISOString(),
          result, cubes,
          opponent: '', deck: '', notes: '', snapped: 'NONE'
        }]);
      };

      useEffect(() => {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js')
            .then(reg => console.log('SW registered:', reg.scope))
            .catch(err => console.error('SW error:', err));
        }
      }, []);

      return (
        <div className="min-h-screen bg-marvel-black">
          {activeTab === 'dashboard' && <Dashboard collection={collection} matches={matches} onQuickMatch={handleQuickMatch} />}
          {activeTab === 'ai' && <AIChat collection={collection} matches={matches} aiConfig={aiConfig} setActiveTab={setActiveTab} />}
          {activeTab === 'collection' && <Collection collection={collection} setCollection={setCollection} />}
          {activeTab === 'decks' && <Decks decks={decks} setDecks={setDecks} collection={collection} />}
          {activeTab === 'calculator' && <Calculator />}
          {activeTab === 'settings' && <Settings settings={settings} setSettings={setSettings} collection={collection} matches={matches} setCollection={setCollection} setMatches={setMatches} aiConfig={aiConfig} setAiConfig={setAiConfig} decks={decks} setDecks={setDecks} />}
          <NavBar activeTab={activeTab} setActiveTab={setActiveTab} />

          {/* Phase 4: Sync Confirm Modal */}
          {showSyncConfirm && syncImportData && (
            <SyncConfirmModal
              syncData={syncImportData}
              onConfirm={handleSyncImport}
              onCancel={() => { setShowSyncConfirm(false); setSyncImportData(null); }}
            />
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
