<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#ED1D24">
  <meta name="description" content="Marvel Snap AI Companion & Tracker - Track your collection, log matches, and get tactical advice">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SnapPrime">

  <title>Snapapoulous Prime - Marvel Snap Companion</title>

  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="assets/icons/icon-192.png">
  <link rel="apple-touch-icon" href="assets/icons/icon-192.png">

  <!-- Google Identity Services for OAuth -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- QR Code Generation -->
  <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>

  <!-- LZ-String for compression (QR sync) -->
  <script src="https://unpkg.com/lz-string@1.5.0/libs/lz-string.min.js"></script>

  <!-- Tailwind Config -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'marvel-red': '#ED1D24',
            'marvel-blue': '#006EC7',
            'marvel-gold': '#FFC107',
            'marvel-black': '#1A1A1A',
            'marvel-white': '#FFFFFF',
            'series-1': '#6B7280',
            'series-2': '#22C55E',
            'series-3': '#8B5CF6',
            'series-4': '#EAB308',
            'series-5': '#EF4444',
            'spotlight': '#F97316',
          },
          fontFamily: {
            'comic': ['Impact', 'Arial Black', 'sans-serif'],
          },
          boxShadow: {
            'comic': '4px 4px 0px #1A1A1A',
            'comic-sm': '2px 2px 0px #1A1A1A',
          }
        }
      }
    }
  </script>

  <style>
    * { -webkit-tap-highlight-color: transparent; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1A1A1A;
      color: #FFFFFF;
      min-height: 100vh;
      overflow-x: hidden;
    }
    .panel-border { border: 3px solid #1A1A1A; box-shadow: 4px 4px 0px #1A1A1A; }
    .halftone { background-image: radial-gradient(circle, rgba(0,0,0,0.1) 1px, transparent 1px); background-size: 8px 8px; }
    .card-hover { transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; }
    .card-hover:active { transform: scale(0.98); }
    .series-border-1 { border-color: #6B7280; }
    .series-border-2 { border-color: #22C55E; }
    .series-border-3 { border-color: #8B5CF6; }
    .series-border-4 { border-color: #EAB308; }
    .series-border-5 { border-color: #EF4444; }
    .series-border-spotlight { border-color: #F97316; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #2D2D2D; }
    ::-webkit-scrollbar-thumb { background: #ED1D24; border-radius: 4px; }
    .tab-active { position: relative; }
    .tab-active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 3px; background: #ED1D24; }
    input[type="range"] { -webkit-appearance: none; background: #2D2D2D; border-radius: 4px; height: 8px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #ED1D24; border-radius: 50%; cursor: pointer; border: 2px solid #FFC107; }
    @keyframes pulse-snap { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .pulse-snap { animation: pulse-snap 0.5s ease-in-out infinite; }
    @keyframes typing { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
    .typing-dot { animation: typing 1.4s infinite; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    .chat-bubble { border-radius: 1rem; }
    .chat-bubble-user { border-bottom-right-radius: 0.25rem; }
    .chat-bubble-ai { border-bottom-left-radius: 0.25rem; }
    /* Drop Zone Styling */
    .drop-zone {
      border: 3px dashed #006EC7;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      background: rgba(0, 110, 199, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .drop-zone:hover, .drop-zone.drag-over {
      border-color: #ED1D24;
      background: rgba(237, 29, 36, 0.1);
      transform: scale(1.02);
    }
    .drop-zone .drop-icon { font-size: 3rem; display: block; margin-bottom: 1rem; }
    .drop-zone .file-path {
      display: block;
      margin-top: 0.5rem;
      font-size: 0.7rem;
      color: #006EC7;
      font-family: monospace;
      opacity: 0.7;
    }
    /* Modal Overlay */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 1rem;
    }
    .modal {
      background: #2D2D2D;
      border-radius: 12px;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 3px solid #1A1A1A;
      box-shadow: 4px 4px 0px #1A1A1A;
    }
    /* Spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #2D2D2D;
      border-top-color: #ED1D24;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* QR Code Container */
    .qr-container { background: white; padding: 1rem; border-radius: 8px; display: inline-block; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useRef } = React;

    // ==================== CONSTANTS ====================
    const GOOGLE_CLIENT_ID = '770573636629-tddodsck0vtmtqpdh7uj7dtevr07orn2.apps.googleusercontent.com';

    // ==================== CARD DATA ====================
    const CARD_DATA = [
      { name: "Abomination", cost: 5, power: 9, series: 1, ability: "No ability." },
      { name: "Ant-Man", cost: 1, power: 1, series: 1, ability: "Ongoing: If your side of this location is full, +3 Power." },
      { name: "America Chavez", cost: 6, power: 9, series: 1, ability: "On Reveal: This always starts in your deck, and is drawn on turn 6." },
      { name: "Angela", cost: 2, power: 0, series: 1, ability: "When you play a card here, +2 Power." },
      { name: "Armor", cost: 2, power: 3, series: 1, ability: "Ongoing: Cards at this location can't be destroyed." },
      { name: "Bishop", cost: 3, power: 1, series: 1, ability: "When you play a card, +1 Power." },
      { name: "Blue Marvel", cost: 5, power: 3, series: 1, ability: "Ongoing: Your other cards have +1 Power." },
      { name: "Cable", cost: 2, power: 2, series: 1, ability: "On Reveal: Draw a card from your opponent's deck." },
      { name: "Captain America", cost: 3, power: 3, series: 1, ability: "Ongoing: Your other cards at this location have +1 Power." },
      { name: "Carnage", cost: 2, power: 2, series: 1, ability: "On Reveal: Destroy your other cards here. +2 Power for each destroyed." },
      { name: "Colossus", cost: 2, power: 3, series: 1, ability: "Ongoing: Can't be destroyed, moved, or have its Power reduced." },
      { name: "Cosmo", cost: 3, power: 3, series: 1, ability: "Ongoing: On Reveal abilities won't happen at this location." },
      { name: "Cyclops", cost: 3, power: 4, series: 1, ability: "No ability." },
      { name: "Deathlok", cost: 3, power: 5, series: 1, ability: "On Reveal: Destroy your other cards at this location." },
      { name: "Elektra", cost: 1, power: 2, series: 1, ability: "On Reveal: Destroy a random enemy 1-Cost card at this location." },
      { name: "Enchantress", cost: 4, power: 5, series: 1, ability: "On Reveal: Remove the abilities from all Ongoing cards at this location." },
      { name: "Forge", cost: 2, power: 1, series: 1, ability: "On Reveal: Give the next card you play +2 Power." },
      { name: "Gamora", cost: 5, power: 7, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +5 Power." },
      { name: "Groot", cost: 3, power: 3, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power." },
      { name: "Hawkeye", cost: 1, power: 1, series: 1, ability: "On Reveal: If you play a card here next turn, +3 Power." },
      { name: "Hulk", cost: 6, power: 12, series: 1, ability: "No ability." },
      { name: "Human Torch", cost: 1, power: 2, series: 1, ability: "When this moves to a location, double its Power." },
      { name: "Iron Fist", cost: 1, power: 2, series: 1, ability: "On Reveal: After you play your next card, move it one location to the left." },
      { name: "Iron Man", cost: 5, power: 0, series: 1, ability: "Ongoing: Your total Power is doubled at this location." },
      { name: "Jessica Jones", cost: 4, power: 4, series: 1, ability: "On Reveal: If you don't play a card here next turn, +4 Power." },
      { name: "Klaw", cost: 5, power: 4, series: 1, ability: "Ongoing: The location to the right has +6 Power." },
      { name: "Korg", cost: 1, power: 1, series: 1, ability: "On Reveal: Shuffle a Rock into your opponent's deck." },
      { name: "Lady Sif", cost: 3, power: 4, series: 1, ability: "On Reveal: Discard the highest-cost card from your hand." },
      { name: "Lizard", cost: 2, power: 5, series: 1, ability: "Ongoing: -3 Power if your opponent has 4 cards here." },
      { name: "Mantis", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, draw a card from their deck." },
      { name: "Medusa", cost: 2, power: 2, series: 1, ability: "On Reveal: If this is at the middle location, +3 Power." },
      { name: "Mister Fantastic", cost: 3, power: 2, series: 1, ability: "Ongoing: Adjacent locations have +2 Power." },
      { name: "Mister Sinister", cost: 2, power: 2, series: 1, ability: "On Reveal: Add a Sinister Clone to this location with the same Power." },
      { name: "Moon Girl", cost: 4, power: 4, series: 1, ability: "On Reveal: Duplicate your hand." },
      { name: "Morph", cost: 3, power: 0, series: 1, ability: "On Reveal: Become a copy of a random card in your opponent's hand." },
      { name: "Multiple Man", cost: 2, power: 3, series: 1, ability: "When this moves, add a copy to the old location." },
      { name: "Namor", cost: 4, power: 5, series: 1, ability: "Ongoing: +5 Power if this is your only card here." },
      { name: "Nightcrawler", cost: 1, power: 2, series: 1, ability: "You can move this once." },
      { name: "Nova", cost: 1, power: 1, series: 1, ability: "When this is destroyed, give your cards +1 Power." },
      { name: "Odin", cost: 6, power: 8, series: 1, ability: "On Reveal: Activate the On Reveal abilities of your other cards at this location." },
      { name: "Onslaught", cost: 6, power: 7, series: 1, ability: "Ongoing: Double your other Ongoing effects at this location." },
      { name: "Punisher", cost: 3, power: 2, series: 1, ability: "Ongoing: +1 Power for each enemy card at this location." },
      { name: "Rocket Raccoon", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +2 Power." },
      { name: "Scarlet Witch", cost: 2, power: 3, series: 1, ability: "On Reveal: Replace this location with a random location." },
      { name: "Sentinel", cost: 2, power: 3, series: 1, ability: "On Reveal: Add another Sentinel to your hand." },
      { name: "Spectrum", cost: 6, power: 5, series: 1, ability: "On Reveal: Give your Ongoing cards +2 Power." },
      { name: "Spider-Woman", cost: 5, power: 7, series: 1, ability: "On Reveal: Afflict all enemy cards here with -1 Power." },
      { name: "Squirrel Girl", cost: 1, power: 1, series: 1, ability: "On Reveal: Add a 1-Power Squirrel to each other location." },
      { name: "Star-Lord", cost: 2, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power." },
      { name: "Strong Guy", cost: 4, power: 4, series: 1, ability: "Ongoing: If your hand is empty, +6 Power." },
      { name: "Sword Master", cost: 3, power: 6, series: 1, ability: "On Reveal: Discard a card from your hand." },
      { name: "The Thing", cost: 4, power: 6, series: 1, ability: "No ability." },
      { name: "White Queen", cost: 4, power: 6, series: 1, ability: "On Reveal: Draw a copy of the highest-Cost card in your opponent's hand." },
      { name: "White Tiger", cost: 5, power: 1, series: 1, ability: "On Reveal: Add a 7-Power Tiger to another location." },
      { name: "Wolfsbane", cost: 3, power: 1, series: 1, ability: "On Reveal: +2 Power for each other card you have here." },
      { name: "Wolverine", cost: 2, power: 2, series: 1, ability: "When this is discarded or destroyed, regenerate it at a random location." },
      { name: "Yondu", cost: 1, power: 2, series: 1, ability: "On Reveal: Remove the top card of your opponent's deck." },
      { name: "Agent 13", cost: 1, power: 2, series: 2, ability: "On Reveal: Add a random card to your hand." },
      { name: "Bucky Barnes", cost: 2, power: 1, series: 2, ability: "When this is destroyed, create the Winter Soldier in its place." },
      { name: "Cloak", cost: 2, power: 4, series: 2, ability: "On Reveal: Next turn, both players can move cards to this location." },
      { name: "Ebony Maw", cost: 1, power: 7, series: 2, ability: "You can't play cards here after turn 3." },
      { name: "Hobgoblin", cost: 5, power: -8, series: 2, ability: "On Reveal: Switch sides." },
      { name: "Iceman", cost: 1, power: 2, series: 2, ability: "On Reveal: Give a random card in your opponent's hand +1 Cost." },
      { name: "Killmonger", cost: 3, power: 3, series: 2, ability: "On Reveal: Destroy ALL 1-Cost cards." },
      { name: "Leech", cost: 5, power: 3, series: 2, ability: "On Reveal: Remove the abilities from all cards in your opponent's hand." },
      { name: "Morbius", cost: 2, power: 0, series: 2, ability: "Ongoing: +2 Power for each card you've discarded this game." },
      { name: "Nakia", cost: 3, power: 3, series: 2, ability: "On Reveal: Give the 2 leftmost cards in your hand +2 Power." },
      { name: "Okoye", cost: 2, power: 2, series: 2, ability: "On Reveal: Give every card in your deck +1 Power." },
      { name: "Rhino", cost: 3, power: 3, series: 2, ability: "On Reveal: Remove the ability from this location." },
      { name: "Sabretooth", cost: 3, power: 4, series: 2, ability: "When this is destroyed, return it to your hand. It costs 0." },
      { name: "Sandman", cost: 5, power: 4, series: 2, ability: "Ongoing: Players can only play 1 card a turn." },
      { name: "Scorpion", cost: 2, power: 2, series: 2, ability: "On Reveal: Afflict cards in your opponent's hand with -1 Power." },
      { name: "Shang-Chi", cost: 4, power: 3, series: 2, ability: "On Reveal: Destroy all enemy cards at this location that have 9 or more Power." },
      { name: "Shocker", cost: 2, power: 3, series: 2, ability: "No ability." },
      { name: "Storm", cost: 3, power: 2, series: 2, ability: "On Reveal: Flood this location. Next turn it's destroyed." },
      { name: "Sunspot", cost: 1, power: 1, series: 2, ability: "At the end of each turn, gain +1 Power for each unspent Energy." },
      { name: "Swarm", cost: 2, power: 3, series: 2, ability: "When this is discarded, add two 0-cost copies to your hand." },
      { name: "The Collector", cost: 2, power: 2, series: 2, ability: "When a card enters your hand (except from your deck), +1 Power." },
      { name: "The Infinaut", cost: 6, power: 20, series: 2, ability: "If you played a card last turn, you can't play this." },
      { name: "Vulture", cost: 3, power: 3, series: 2, ability: "When a card moves away from here, +5 Power." },
      { name: "Warpath", cost: 4, power: 5, series: 2, ability: "Ongoing: If any of your locations are empty, +4 Power." },
      { name: "Absorbing Man", cost: 4, power: 4, series: 3, ability: "On Reveal: If the last card you played has an On Reveal, copy its ability." },
      { name: "Aero", cost: 5, power: 8, series: 3, ability: "On Reveal: Move all enemy cards played this turn to this location." },
      { name: "Black Panther", cost: 5, power: 4, series: 3, ability: "On Reveal: Double this card's Power." },
      { name: "Brood", cost: 3, power: 2, series: 3, ability: "On Reveal: Add 2 Broodlings to this location with the same Power." },
      { name: "Cerebro", cost: 3, power: 0, series: 3, ability: "Ongoing: Your highest Power cards get +2 Power." },
      { name: "Colleen Wing", cost: 2, power: 4, series: 3, ability: "On Reveal: Discard the lowest-cost card from your hand." },
      { name: "Darkhawk", cost: 4, power: 1, series: 3, ability: "Ongoing: +2 Power for each card in your opponent's deck." },
      { name: "Deadpool", cost: 1, power: 1, series: 3, ability: "When this is destroyed, return it to your hand with double the Power." },
      { name: "Death", cost: 9, power: 12, series: 3, ability: "Costs 1 less for each card destroyed this game." },
      { name: "Destroyer", cost: 6, power: 16, series: 3, ability: "On Reveal: Destroy your other cards." },
      { name: "Doctor Doom", cost: 6, power: 5, series: 3, ability: "On Reveal: Add a 5-Power Doombot to each other location." },
      { name: "Dracula", cost: 4, power: 0, series: 3, ability: "At the end of the game, discard a card from your hand. This has its Power." },
      { name: "Electro", cost: 3, power: 2, series: 3, ability: "On Reveal: +1 Max Energy. Ongoing: You can only play 1 card a turn." },
      { name: "Ghost Rider", cost: 4, power: 3, series: 3, ability: "On Reveal: Bring back one of your discarded cards to this location." },
      { name: "Hela", cost: 6, power: 6, series: 3, ability: "On Reveal: Play all cards you discarded from your hand to random locations." },
      { name: "Hit-Monkey", cost: 3, power: 2, series: 3, ability: "On Reveal: Gain +2 Power for each other card you played this turn." },
      { name: "Jane Foster", cost: 5, power: 8, series: 3, ability: "On Reveal: Draw all cards that cost 0 from your deck." },
      { name: "Jeff", cost: 2, power: 3, series: 3, ability: "You can move this once. Nothing can stop you from moving or playing this." },
      { name: "Knull", cost: 6, power: 0, series: 3, ability: "Ongoing: Has the combined Power of all cards destroyed this game." },
      { name: "Leader", cost: 6, power: 4, series: 3, ability: "On Reveal: Copy all cards your opponent played this turn, but on your side." },
      { name: "Lockjaw", cost: 3, power: 2, series: 3, ability: "When you play a card here, swap it with a card from your deck." },
      { name: "Luke Cage", cost: 2, power: 1, series: 3, ability: "Ongoing: Your cards can't have their Power reduced." },
      { name: "Magik", cost: 5, power: 3, series: 3, ability: "On Reveal: Change this location to 'Limbo'." },
      { name: "Magneto", cost: 6, power: 12, series: 3, ability: "On Reveal: Move all opposing 3 and 4-Cost cards to this location." },
      { name: "Mystique", cost: 3, power: 0, series: 3, ability: "On Reveal: If the last card you played has an Ongoing ability, this card gains it." },
      { name: "Patriot", cost: 3, power: 1, series: 3, ability: "Ongoing: Your cards with no abilities have +2 Power." },
      { name: "Sera", cost: 5, power: 4, series: 3, ability: "Ongoing: Cards in your hand cost 1 less. (minimum 1)" },
      { name: "She-Hulk", cost: 6, power: 10, series: 3, ability: "Costs 1 less for each unspent Energy last turn." },
      { name: "Silver Surfer", cost: 3, power: 0, series: 3, ability: "On Reveal: Give your other 3-Cost cards +3 Power." },
      { name: "Spider-Man", cost: 4, power: 3, series: 3, ability: "On Reveal: Your opponent can't play cards at this location next turn." },
      { name: "Ultron", cost: 6, power: 8, series: 3, ability: "On Reveal: Create 4 Drones at each other location." },
      { name: "Venom", cost: 3, power: 1, series: 3, ability: "On Reveal: Destroy your other cards at this location. Add their Power to this card." },
      { name: "Vision", cost: 5, power: 7, series: 3, ability: "You can move this each turn." },
      { name: "Wave", cost: 3, power: 3, series: 3, ability: "On Reveal: All cards cost 4 until the end of next turn." },
      { name: "Wong", cost: 4, power: 2, series: 3, ability: "Ongoing: Your On Reveal abilities at this location happen twice." },
      { name: "Zabu", cost: 3, power: 2, series: 3, ability: "Ongoing: Your 4-Cost cards cost 2 less. (minimum 1)" },
      { name: "Zero", cost: 1, power: 3, series: 3, ability: "On Reveal: Remove the abilities on the next card you play." },
      { name: "Galactus", cost: 6, power: 3, series: 4, ability: "On Reveal: If this is your only card here, destroy all other locations." },
      { name: "High Evolutionary", cost: 4, power: 4, series: 4, ability: "At the start of the game, unlock the abilities of your cards with no abilities." },
      { name: "Shuri", cost: 4, power: 2, series: 4, ability: "On Reveal: Double the Power of the next card you play." },
      { name: "Thanos", cost: 6, power: 8, series: 4, ability: "At the start of the game, shuffle the six Infinity Stones into your deck." },
      { name: "Kang", cost: 5, power: 0, series: 5, ability: "On Reveal: Look at what your opponent did, then restart the turn." },
    ];

    const uniqueCards = CARD_DATA.reduce((acc, card) => {
      if (!acc.find(c => c.name === card.name)) acc.push(card);
      return acc;
    }, []);

    // ==================== SNAPAPOULOUS PERSONA ====================
    const SNAPAPOULOUS_PERSONA = {
      name: "Snapapoulous",
      role: "Marvel Snap Tactical Advisor",
      personality: {
        tone: "Confident, knowledgeable, encouraging",
        style: "Direct tactical guidance with clear reasoning",
        voice: "Like a seasoned hero mentoring a new Avenger"
      },
      expertise: [
        "Deck building and optimization",
        "Meta analysis and counter-strategies",
        "Probability and statistics",
        "Snap/retreat decision making",
        "Card synergies and combos"
      ],
      principles: [
        "The 8-Cube Mandate: Play for high-value wins when the odds favor you",
        "Retreat is not defeat: Preserving cubes is a winning strategy",
        "Adapt or fall: The meta shifts constantly, flexibility is power",
        "Know your outs: Always calculate the probability before snapping"
      ]
    };

    // ==================== AI PROVIDER MANAGER ====================
    const AIProviders = {
      'gemini-oauth': {
        id: 'gemini-oauth',
        name: 'Google (Gemini)',
        description: 'Sign in with Google - easiest option',
        authType: 'oauth',
        models: ['gemini-2.0-flash', 'gemini-1.5-flash', 'gemini-1.5-pro'],
        defaultModel: 'gemini-2.0-flash',
        primary: true
      },
      'gemini': {
        id: 'gemini',
        name: 'Gemini (API Key)',
        description: 'Use your own Gemini API key',
        authType: 'api_key',
        models: ['gemini-2.0-flash', 'gemini-1.5-flash', 'gemini-1.5-pro'],
        defaultModel: 'gemini-2.0-flash'
      },
      'groq': {
        id: 'groq',
        name: 'Groq',
        description: 'Fast inference, free tier available',
        authType: 'api_key',
        models: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
        defaultModel: 'llama-3.3-70b-versatile'
      },
      'claude': {
        id: 'claude',
        name: 'Claude (Anthropic)',
        description: 'Premium AI assistant',
        authType: 'api_key',
        models: ['claude-sonnet-4-20250514', 'claude-haiku-4-5-20251001'],
        defaultModel: 'claude-sonnet-4-20250514'
      },
      'openai': {
        id: 'openai',
        name: 'OpenAI (GPT)',
        description: 'ChatGPT models',
        authType: 'api_key',
        models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo'],
        defaultModel: 'gpt-4o-mini'
      },
      'local': {
        id: 'local',
        name: 'Local (Ollama)',
        description: 'Run models locally',
        authType: 'none',
        models: [],
        defaultModel: '',
        advanced: true
      },
      'mkg': {
        id: 'mkg',
        name: 'MKG Bridge',
        description: 'Custom OpenAI-compatible endpoint',
        authType: 'none',
        models: [],
        defaultModel: '',
        advanced: true
      }
    };

    // Build system prompt with user context
    const buildSystemPrompt = (collection, matches) => {
      const totalWins = matches.filter(m => m.result === 'WIN').length;
      const totalGames = matches.length;
      const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      return `You are ${SNAPAPOULOUS_PERSONA.name}, a ${SNAPAPOULOUS_PERSONA.role}.

PERSONALITY:
- Tone: ${SNAPAPOULOUS_PERSONA.personality.tone}
- Style: ${SNAPAPOULOUS_PERSONA.personality.style}
- Voice: ${SNAPAPOULOUS_PERSONA.personality.voice}

YOUR EXPERTISE:
${SNAPAPOULOUS_PERSONA.expertise.map(e => `- ${e}`).join('\n')}

GUIDING PRINCIPLES:
${SNAPAPOULOUS_PERSONA.principles.map(p => `- ${p}`).join('\n')}

USER CONTEXT:
- Collection: ${collection.owned.length} cards owned out of ~120 total
- Total Games Played: ${totalGames}
- Win Rate: ${winRate}%
- Net Cubes: ${netCubes >= 0 ? '+' : ''}${netCubes}

CURRENT META (January 2026):
- Top Archetypes: Destroy, Bounce, High Evo, Discard, Move
- Strong Cards: Knull, Death, Angela, Hit-Monkey, Silver Surfer

Respond with practical, actionable Marvel Snap advice. Be concise but thorough. Reference Marvel lore when relevant. Use card game terminology naturally.`;
    };

    // API call functions for each provider
    const callGeminiOAuth = async (messages, model, accessToken) => {
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            contents: messages.map(m => ({
              role: m.role === 'assistant' ? 'model' : 'user',
              parts: [{ text: m.content }]
            }))
          })
        }
      );
      if (!response.ok) throw new Error(`Gemini OAuth error: ${response.status}`);
      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    };

    const callGeminiAPIKey = async (messages, model, apiKey) => {
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: messages.map(m => ({
              role: m.role === 'assistant' ? 'model' : 'user',
              parts: [{ text: m.content }]
            }))
          })
        }
      );
      if (!response.ok) throw new Error(`Gemini API error: ${response.status}`);
      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    };

    const callGroq = async (messages, model, apiKey) => {
      const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 1024 })
      });
      if (!response.ok) throw new Error(`Groq error: ${response.status}`);
      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response';
    };

    const callClaude = async (messages, model, apiKey) => {
      const systemMsg = messages.find(m => m.role === 'system');
      const otherMsgs = messages.filter(m => m.role !== 'system');

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'Content-Type': 'application/json',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model,
          max_tokens: 1024,
          system: systemMsg?.content || '',
          messages: otherMsgs
        })
      });
      if (!response.ok) throw new Error(`Claude error: ${response.status}`);
      const data = await response.json();
      return data.content?.[0]?.text || 'No response';
    };

    const callOpenAI = async (messages, model, apiKey) => {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 1024 })
      });
      if (!response.ok) throw new Error(`OpenAI error: ${response.status}`);
      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response';
    };

    const callLocal = async (messages, model, endpoint) => {
      const response = await fetch(`${endpoint}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model, messages, stream: false })
      });
      if (!response.ok) throw new Error(`Local error: ${response.status}`);
      const data = await response.json();
      return data.message?.content || 'No response';
    };

    const callMKG = async (messages, model, endpoint) => {
      const response = await fetch(`${endpoint}/v1/chat/completions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model, messages })
      });
      if (!response.ok) throw new Error(`MKG error: ${response.status}`);
      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response';
    };

    // ==================== LOG PARSER ====================
    const LogParser = {
      parsePlayerLog(logContent) {
        const matches = [];
        const lines = logContent.split('\n');

        let currentTimestamp = null;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Extract timestamp if present
          const tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\]/);
          if (tsMatch) {
            currentTimestamp = tsMatch[1];
          }

          // Look for game result patterns in the log
          if (line.includes('GameResult') || line.includes('MatchComplete') ||
              line.includes('BattleResult') || line.includes('GameOutcome') ||
              line.includes('"Result"') || line.includes('CubesDelta')) {
            try {
              // Try to find JSON object in the line
              const jsonMatch = line.match(/\{[^{}]*\}/);
              if (jsonMatch) {
                const data = JSON.parse(jsonMatch[0]);

                const result = this.normalizeResult(data.Result || data.GameOutcome || data.Outcome);
                const cubes = parseInt(data.CubesDelta || data.Cubes || data.cubes || 0);

                if (result && cubes !== 0) {
                  matches.push({
                    id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                    timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                    result: result,
                    cubes: Math.abs(cubes),
                    deckId: data.DeckId || data.DeckName || null,
                    opponent: data.OpponentName || null,
                    snapped: this.parseSnapState(data),
                    source: 'log_import',
                    notes: ''
                  });
                }
              }
            } catch (e) {
              // Not valid JSON, continue scanning
            }
          }

          // Alternative pattern: look for win/loss with cube values
          const simpleMatch = line.match(/(WIN|LOSS|VICTORY|DEFEAT|RETREAT)[^\d]*(\d+)\s*cube/i);
          if (simpleMatch && !matches.find(m => m.timestamp === currentTimestamp)) {
            const result = this.normalizeResult(simpleMatch[1]);
            const cubes = parseInt(simpleMatch[2]);
            if (result && cubes > 0) {
              matches.push({
                id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                result: result,
                cubes: cubes,
                deckId: null,
                opponent: null,
                snapped: 'NONE',
                source: 'log_import',
                notes: ''
              });
            }
          }
        }

        const unique = this.deduplicateMatches(matches);

        return {
          matches: unique,
          parseDate: new Date().toISOString(),
          rawLineCount: lines.length,
          matchCount: unique.length
        };
      },

      normalizeResult(result) {
        if (!result) return null;
        const r = String(result).toUpperCase();
        if (r.includes('WIN') || r === 'VICTORY') return 'WIN';
        if (r.includes('LOSS') || r.includes('LOSE') || r === 'DEFEAT') return 'LOSS';
        if (r.includes('RETREAT')) return 'LOSS';
        return null;
      },

      parseSnapState(data) {
        if (data.PlayerSnapped && data.OpponentSnapped) return 'BOTH';
        if (data.PlayerSnapped) return 'PLAYER';
        if (data.OpponentSnapped) return 'OPPONENT';
        return 'NONE';
      },

      deduplicateMatches(matches) {
        const seen = new Set();
        return matches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      },

      mergeWithExisting(newMatches, existingMatches) {
        const existingKeys = new Set(
          existingMatches.map(m => `${m.timestamp}-${m.result}-${m.cubes}`)
        );

        const toAdd = newMatches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          return !existingKeys.has(key);
        });

        return {
          added: toAdd,
          skipped: newMatches.length - toAdd.length,
          merged: [...existingMatches, ...toAdd].sort((a, b) =>
            new Date(b.timestamp) - new Date(a.timestamp)
          )
        };
      }
    };

    // ==================== COLLECTION INFERRER ====================
    const CollectionInferrer = {
      inferFromMatches(matches) {
        const usedCards = new Set();
        for (const match of matches) {
          if (match.deckCards && Array.isArray(match.deckCards)) {
            match.deckCards.forEach(card => usedCards.add(card));
          }
        }
        return Array.from(usedCards);
      },

      mergeWithCollection(inferredCards, existingCollection) {
        const existing = new Set(existingCollection.owned || []);
        let addedCount = 0;

        for (const card of inferredCards) {
          if (!existing.has(card)) {
            existing.add(card);
            addedCount++;
          }
        }

        return {
          owned: Array.from(existing),
          addedCount,
          lastUpdated: new Date().toISOString()
        };
      }
    };

    // ==================== VAULT MANAGER ====================
    const VaultManager = {
      exportFullVault(collection, matches, settings) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const totalGames = matches.length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          version: '1.0',
          exportDate: new Date().toISOString(),
          collection: collection,
          matches: matches,
          settings: settings,
          stats: {
            totalGames,
            wins: totalWins,
            losses: totalGames - totalWins,
            winRate: totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0,
            netCubes
          }
        };
      },

      generateSyncData(collection, matches) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          v: 1,
          c: collection.owned || [],
          s: {
            wins: totalWins,
            losses: matches.length - totalWins,
            cubes: netCubes
          }
        };
      },

      compressForQR(syncData) {
        try {
          return LZString.compressToEncodedURIComponent(JSON.stringify(syncData));
        } catch (e) {
          console.error('Compression failed:', e);
          return null;
        }
      },

      decompressFromQR(compressed) {
        try {
          const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
          return JSON.parse(decompressed);
        } catch (e) {
          console.error('Decompression failed:', e);
          return null;
        }
      }
    };

    // ==================== LOG ERROR MESSAGES ====================
    const LogErrors = {
      NO_MATCHES: 'No match data found. Make sure this is the Player.log file from Marvel Snap.',
      PARSE_FAILED: 'Could not parse log file. The game may have updated its format.',
      FILE_TOO_LARGE: 'File is too large (>50MB). Try using a more recent log file.',
      INVALID_FORMAT: 'This doesn\'t appear to be a Marvel Snap log file.',
      READ_ERROR: 'Could not read the file. Please try again.'
    };

    // ==================== UTILITY FUNCTIONS ====================
    const getSeriesBorderClass = (series) => `series-border-${series}`;

    const loadFromStorage = (key, defaultValue) => {
      try {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      } catch { return defaultValue; }
    };

    const saveToStorage = (key, value) => {
      try { localStorage.setItem(key, JSON.stringify(value)); }
      catch (e) { console.warn('Storage error:', e); }
    };

    const generateId = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });

    const formatDate = (dateString) => new Date(dateString).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
    });

    // ==================== COMPONENTS ====================

    // Navigation Bar
    const NavBar = ({ activeTab, setActiveTab }) => {
      const tabs = [
        { id: 'dashboard', label: 'Home', icon: '‚ö°' },
        { id: 'ai', label: 'AI', icon: 'ü§ñ' },
        { id: 'collection', label: 'Cards', icon: 'üÉè' },
        { id: 'calculator', label: 'Calc', icon: 'üéØ' },
        { id: 'settings', label: 'Config', icon: '‚öôÔ∏è' }
      ];
      return (
        <nav className="fixed bottom-0 left-0 right-0 bg-marvel-black border-t-4 border-marvel-red z-50">
          <div className="flex justify-around items-center h-16 max-w-lg mx-auto">
            {tabs.map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)}
                className={`flex flex-col items-center justify-center w-full h-full transition-colors ${
                  activeTab === tab.id ? 'text-marvel-red tab-active' : 'text-gray-400 hover:text-white'
                }`}>
                <span className="text-xl">{tab.icon}</span>
                <span className="text-xs mt-1 font-medium">{tab.label}</span>
              </button>
            ))}
          </div>
        </nav>
      );
    };

    // Header
    const Header = ({ title }) => (
      <header className="bg-marvel-red halftone py-4 px-4 shadow-comic mb-4">
        <h1 className="text-2xl font-comic text-white text-center tracking-wider">{title}</h1>
      </header>
    );

    // Dashboard Component
    const Dashboard = ({ collection, matches, onQuickMatch }) => {
      const totalCards = uniqueCards.length;
      const ownedCount = collection.owned.length;
      const completionPercent = Math.round((ownedCount / totalCards) * 100);
      const today = new Date().toDateString();
      const todayMatches = matches.filter(m => new Date(m.timestamp).toDateString() === today);
      const todayCubes = todayMatches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);
      const totalWins = matches.filter(m => m.result === 'WIN').length;
      const totalGames = matches.length;
      const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      const getStreak = () => {
        if (matches.length === 0) return { count: 0, type: 'none' };
        const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        const firstResult = sorted[0].result;
        let count = 0;
        for (const match of sorted) {
          if (match.result === firstResult) count++;
          else break;
        }
        return { count, type: firstResult };
      };
      const streak = getStreak();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAPAPOULOUS PRIME" />
          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-red panel-border">
              <div className="text-gray-400 text-xs uppercase">Collection</div>
              <div className="text-2xl font-comic text-white">{completionPercent}%</div>
              <div className="text-sm text-gray-400">{ownedCount}/{totalCards} cards</div>
            </div>
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-gold panel-border">
              <div className="text-gray-400 text-xs uppercase">Win Rate</div>
              <div className="text-2xl font-comic text-white">{winRate}%</div>
              <div className="text-sm text-gray-400">{totalWins}/{totalGames} games</div>
            </div>
          </div>
          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-marvel-blue panel-border">
              <div className="text-gray-400 text-xs uppercase">Net Cubes</div>
              <div className={`text-2xl font-comic ${netCubes >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {netCubes >= 0 ? '+' : ''}{netCubes}
              </div>
              <div className="text-sm text-gray-400">Today: {todayCubes >= 0 ? '+' : ''}{todayCubes}</div>
            </div>
            <div className="bg-gray-800 rounded-lg p-3 border-l-4 border-series-3 panel-border">
              <div className="text-gray-400 text-xs uppercase">Streak</div>
              <div className={`text-2xl font-comic ${streak.type === 'WIN' ? 'text-green-400' : streak.type === 'LOSS' ? 'text-red-400' : 'text-gray-400'}`}>
                {streak.count} {streak.type === 'WIN' ? 'W' : streak.type === 'LOSS' ? 'L' : '-'}
              </div>
              <div className="text-sm text-gray-400">Current</div>
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h2 className="text-lg font-comic text-marvel-gold mb-3">Quick Match</h2>
            <div className="mb-3">
              <div className="text-sm text-green-400 mb-2">WIN</div>
              <div className="flex gap-2">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`win-${cubes}`} onClick={() => onQuickMatch('WIN', cubes)}
                    className="flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded shadow-comic-sm active:shadow-none active:translate-x-0.5 active:translate-y-0.5 transition-all">
                    +{cubes}
                  </button>
                ))}
              </div>
            </div>
            <div>
              <div className="text-sm text-red-400 mb-2">LOSS</div>
              <div className="flex gap-2">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`loss-${cubes}`} onClick={() => onQuickMatch('LOSS', cubes)}
                    className="flex-1 bg-red-600 hover:bg-red-500 text-white font-bold py-3 rounded shadow-comic-sm active:shadow-none active:translate-x-0.5 active:translate-y-0.5 transition-all">
                    -{cubes}
                  </button>
                ))}
              </div>
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <h2 className="text-lg font-comic text-marvel-gold mb-3">Recent Matches</h2>
            {matches.length === 0 ? (
              <p className="text-gray-400 text-center py-4">No matches recorded yet</p>
            ) : (
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {[...matches].reverse().slice(0, 5).map(match => (
                  <div key={match.id} className={`flex items-center justify-between p-2 rounded ${
                    match.result === 'WIN' ? 'bg-green-900/30' : 'bg-red-900/30'
                  }`}>
                    <span className={`font-bold ${match.result === 'WIN' ? 'text-green-400' : 'text-red-400'}`}>
                      {match.result === 'WIN' ? '+' : '-'}{match.cubes} cubes
                    </span>
                    <span className="text-gray-400 text-sm">{formatDate(match.timestamp)}</span>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    };

    // AI Chat Component
    const AIChat = ({ collection, matches, aiConfig, setActiveTab }) => {
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);
      const messagesEndRef = useRef(null);

      const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      };

      useEffect(() => {
        scrollToBottom();
      }, [messages]);

      useEffect(() => {
        if (messages.length === 0) {
          setMessages([{
            id: generateId(),
            role: 'assistant',
            content: "Ready to climb the ranks? I'm Snapapoulous, your Marvel Snap tactical advisor. Ask me about deck building, meta matchups, snap decisions, or anything else about the game!"
          }]);
        }
      }, []);

      const isConfigured = () => {
        if (!aiConfig.provider) return false;
        if (aiConfig.provider === 'gemini-oauth') return !!aiConfig.googleToken;
        if (aiConfig.provider === 'local') return !!aiConfig.localEndpoint;
        if (aiConfig.provider === 'mkg') return !!aiConfig.mkgEndpoint;
        return !!aiConfig.apiKeys?.[aiConfig.provider];
      };

      const sendMessage = async () => {
        if (!input.trim() || isLoading) return;
        if (!isConfigured()) {
          setError('Please configure an AI provider in Settings first.');
          return;
        }

        const userMessage = { id: generateId(), role: 'user', content: input.trim() };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);
        setError(null);

        try {
          const systemPrompt = buildSystemPrompt(collection, matches);
          const apiMessages = [
            { role: 'system', content: systemPrompt },
            ...messages.filter(m => m.role !== 'assistant' || messages.indexOf(m) > 0).map(m => ({
              role: m.role, content: m.content
            })),
            { role: 'user', content: userMessage.content }
          ];

          let response;
          const model = aiConfig.model || AIProviders[aiConfig.provider]?.defaultModel;

          switch (aiConfig.provider) {
            case 'gemini-oauth':
              response = await callGeminiOAuth(apiMessages.filter(m => m.role !== 'system'), model, aiConfig.googleToken);
              break;
            case 'gemini':
              response = await callGeminiAPIKey(apiMessages.filter(m => m.role !== 'system'), model, aiConfig.apiKeys?.gemini);
              break;
            case 'groq':
              response = await callGroq(apiMessages, model, aiConfig.apiKeys?.groq);
              break;
            case 'claude':
              response = await callClaude(apiMessages, model, aiConfig.apiKeys?.claude);
              break;
            case 'openai':
              response = await callOpenAI(apiMessages, model, aiConfig.apiKeys?.openai);
              break;
            case 'local':
              response = await callLocal(apiMessages, model, aiConfig.localEndpoint);
              break;
            case 'mkg':
              response = await callMKG(apiMessages, model, aiConfig.mkgEndpoint);
              break;
            default:
              throw new Error('Unknown provider');
          }

          setMessages(prev => [...prev, {
            id: generateId(),
            role: 'assistant',
            content: response
          }]);
        } catch (err) {
          setError(err.message || 'Failed to get response');
          console.error('AI error:', err);
        } finally {
          setIsLoading(false);
        }
      };

      const quickPrompts = [
        "Analyze my win rate",
        "Best deck for climbing?",
        "When should I snap?",
        "Counter Destroy decks"
      ];

      return (
        <div className="flex flex-col h-[calc(100vh-4rem)] pb-16">
          <Header title="SNAPAPOULOUS AI" />

          {!isConfigured() && (
            <div className="mx-4 mb-4 bg-yellow-900/50 border border-yellow-600 rounded-lg p-4">
              <p className="text-yellow-200 text-sm mb-2">AI not configured yet!</p>
              <button onClick={() => setActiveTab('settings')}
                className="bg-marvel-gold text-black px-4 py-2 rounded font-medium hover:bg-yellow-400">
                Configure AI Provider
              </button>
            </div>
          )}

          <div className="flex-1 overflow-y-auto px-4 space-y-4">
            {messages.map(msg => (
              <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                <div className={`max-w-[85%] p-3 chat-bubble ${
                  msg.role === 'user'
                    ? 'bg-marvel-blue text-white chat-bubble-user'
                    : 'bg-gray-700 text-white chat-bubble-ai'
                }`}>
                  <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                </div>
              </div>
            ))}

            {isLoading && (
              <div className="flex justify-start">
                <div className="bg-gray-700 p-4 rounded-lg chat-bubble chat-bubble-ai">
                  <div className="flex gap-1">
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-marvel-red rounded-full typing-dot"></span>
                  </div>
                </div>
              </div>
            )}

            {error && (
              <div className="bg-red-900/50 border border-red-500 rounded-lg p-3">
                <p className="text-red-300 text-sm">{error}</p>
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>

          {messages.length <= 1 && (
            <div className="px-4 py-2">
              <div className="flex flex-wrap gap-2">
                {quickPrompts.map(prompt => (
                  <button key={prompt} onClick={() => setInput(prompt)}
                    className="bg-gray-700 text-gray-300 text-xs px-3 py-1.5 rounded-full hover:bg-gray-600">
                    {prompt}
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="p-4 bg-gray-900 border-t border-gray-700">
            <div className="flex gap-2">
              <input type="text" value={input} onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && sendMessage()}
                placeholder="Ask Snapapoulous..."
                disabled={isLoading}
                className="flex-1 bg-gray-800 text-white rounded-lg px-4 py-3 border-2 border-gray-700 focus:border-marvel-red focus:outline-none disabled:opacity-50"
              />
              <button onClick={sendMessage} disabled={isLoading || !input.trim()}
                className="bg-marvel-red text-white px-6 py-3 rounded-lg font-medium hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed shadow-comic-sm">
                Send
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Collection Component
    const Collection = ({ collection, setCollection }) => {
      const [search, setSearch] = useState('');
      const [seriesFilter, setSeriesFilter] = useState('all');
      const [ownedFilter, setOwnedFilter] = useState('all');

      const filteredCards = useMemo(() => {
        return uniqueCards.filter(card => {
          if (search && !card.name.toLowerCase().includes(search.toLowerCase())) return false;
          if (seriesFilter !== 'all' && card.series !== parseInt(seriesFilter)) return false;
          const isOwned = collection.owned.includes(card.name);
          if (ownedFilter === 'owned' && !isOwned) return false;
          if (ownedFilter === 'missing' && isOwned) return false;
          return true;
        });
      }, [search, seriesFilter, ownedFilter, collection.owned]);

      const toggleCard = (cardName) => {
        setCollection(prev => {
          const isOwned = prev.owned.includes(cardName);
          return {
            owned: isOwned ? prev.owned.filter(c => c !== cardName) : [...prev.owned, cardName],
            lastUpdated: new Date().toISOString()
          };
        });
      };

      const markAllSeries = (series) => {
        const seriesCards = uniqueCards.filter(c => c.series === series).map(c => c.name);
        setCollection(prev => ({
          owned: [...new Set([...prev.owned, ...seriesCards])],
          lastUpdated: new Date().toISOString()
        }));
      };

      const completionPercent = Math.round((collection.owned.length / uniqueCards.length) * 100);

      return (
        <div className="px-4 pb-20">
          <Header title="COLLECTION" />
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between mb-2">
              <span className="text-white font-medium">Completion</span>
              <span className="text-marvel-gold font-bold">{completionPercent}%</span>
            </div>
            <div className="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
              <div className="bg-gradient-to-r from-marvel-red to-marvel-gold h-full transition-all duration-500"
                style={{ width: `${completionPercent}%` }} />
            </div>
            <div className="text-center text-sm text-gray-400 mt-2">
              {collection.owned.length} / {uniqueCards.length} cards owned
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <input type="text" placeholder="Search cards..." value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-3 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
            <div className="flex gap-2 mb-3">
              <select value={seriesFilter} onChange={(e) => setSeriesFilter(e.target.value)}
                className="flex-1 bg-gray-700 text-white rounded px-2 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none">
                <option value="all">All Series</option>
                <option value="1">Series 1</option>
                <option value="2">Series 2</option>
                <option value="3">Series 3</option>
                <option value="4">Series 4</option>
                <option value="5">Series 5</option>
              </select>
              <select value={ownedFilter} onChange={(e) => setOwnedFilter(e.target.value)}
                className="flex-1 bg-gray-700 text-white rounded px-2 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none">
                <option value="all">All Cards</option>
                <option value="owned">Owned</option>
                <option value="missing">Missing</option>
              </select>
            </div>
            <div className="flex gap-2 flex-wrap">
              <button onClick={() => markAllSeries(1)} className="bg-series-1 text-white text-xs px-2 py-1 rounded hover:opacity-80">Own S1</button>
              <button onClick={() => markAllSeries(2)} className="bg-series-2 text-white text-xs px-2 py-1 rounded hover:opacity-80">Own S2</button>
              <button onClick={() => setCollection({ owned: [], lastUpdated: new Date().toISOString() })}
                className="bg-red-600 text-white text-xs px-2 py-1 rounded hover:opacity-80 ml-auto">Clear All</button>
            </div>
          </div>
          <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
            {filteredCards.map(card => {
              const isOwned = collection.owned.includes(card.name);
              return (
                <button key={card.name} onClick={() => toggleCard(card.name)}
                  className={`relative p-2 rounded-lg border-3 transition-all card-hover ${getSeriesBorderClass(card.series)} ${
                    isOwned ? 'bg-gray-700 border-opacity-100' : 'bg-gray-900 border-opacity-30 opacity-50'
                  }`} style={{ borderWidth: '3px' }}>
                  <div className="absolute top-1 left-1 w-5 h-5 bg-marvel-blue rounded-full flex items-center justify-center text-xs font-bold text-white">{card.cost}</div>
                  <div className="absolute top-1 right-1 w-5 h-5 bg-marvel-red rounded-full flex items-center justify-center text-xs font-bold text-white">{card.power}</div>
                  <div className="mt-6 text-xs text-white text-center truncate">{card.name}</div>
                  {isOwned && (
                    <div className="absolute -top-1 -right-1 w-4 h-4 bg-green-500 rounded-full flex items-center justify-center">
                      <span className="text-white text-xs">‚úì</span>
                    </div>
                  )}
                </button>
              );
            })}
          </div>
          {filteredCards.length === 0 && <div className="text-center text-gray-400 py-8">No cards found</div>}
        </div>
      );
    };

    // Calculator Component
    const Calculator = () => {
      const [turn, setTurn] = useState(4);
      const [confidence, setConfidence] = useState(50);
      const [cardsToDraw, setCardsToDraw] = useState(1);
      const [copiesInDeck, setCopiesInDeck] = useState(1);

      const cardsSeen = Math.min(12, 3 + turn);

      const hypergeometric = (N, K, n) => {
        const factorial = (num) => { if (num <= 1) return 1; let r = 1; for (let i = 2; i <= num; i++) r *= i; return r; };
        const comb = (a, b) => { if (b > a) return 0; if (b === 0 || b === a) return 1; return factorial(a) / (factorial(b) * factorial(a - b)); };
        return 1 - (comb(N - K, n) / comb(N, n));
      };

      const drawProbability = hypergeometric(12, copiesInDeck, cardsToDraw) * 100;

      const getRecommendation = () => {
        const turnRiskFactor = turn <= 3 ? 0.9 : turn <= 5 ? 1.0 : 1.1;
        const adj = confidence / turnRiskFactor;
        if (adj >= 70) return { action: 'SNAP', bgColor: 'bg-green-600', animate: true };
        if (adj >= 45) return { action: 'HOLD', bgColor: 'bg-yellow-600', animate: false };
        return { action: 'RETREAT', bgColor: 'bg-red-600', animate: false };
      };
      const rec = getRecommendation();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAP CALCULATOR" />
          <div className={`${rec.bgColor} rounded-lg p-6 panel-border mb-4 text-center ${rec.animate ? 'pulse-snap' : ''}`}>
            <div className="text-4xl font-comic text-white mb-2">{rec.action}</div>
            <div className="text-white/80">
              {rec.action === 'SNAP' && 'The odds favor you. Make your move!'}
              {rec.action === 'HOLD' && 'Wait for more information.'}
              {rec.action === 'RETREAT' && 'Live to fight another match.'}
            </div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Current Turn</span>
              <span className="text-marvel-gold font-bold text-xl">{turn}</span>
            </div>
            <input type="range" min="1" max="7" value={turn} onChange={(e) => setTurn(parseInt(e.target.value))} className="w-full" />
            <div className="text-center text-sm text-gray-400 mt-2">Cards seen: {cardsSeen}/12</div>
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Win Confidence</span>
              <span className={`font-bold text-xl ${confidence >= 70 ? 'text-green-400' : confidence >= 45 ? 'text-yellow-400' : 'text-red-400'}`}>{confidence}%</span>
            </div>
            <input type="range" min="0" max="100" value={confidence} onChange={(e) => setConfidence(parseInt(e.target.value))} className="w-full" />
          </div>
          <div className="bg-gray-800 rounded-lg p-4 panel-border">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Draw Probability</h3>
            <div className="grid grid-cols-2 gap-3 mb-4">
              <div>
                <label className="text-sm text-gray-400">Cards to Draw</label>
                <input type="number" min="1" max="12" value={cardsToDraw}
                  onChange={(e) => setCardsToDraw(Math.max(1, Math.min(12, parseInt(e.target.value) || 1)))}
                  className="w-full bg-gray-700 text-white rounded px-3 py-2 mt-1 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              </div>
              <div>
                <label className="text-sm text-gray-400">Copies in Deck</label>
                <input type="number" min="1" max="4" value={copiesInDeck}
                  onChange={(e) => setCopiesInDeck(Math.max(1, Math.min(4, parseInt(e.target.value) || 1)))}
                  className="w-full bg-gray-700 text-white rounded px-3 py-2 mt-1 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
              </div>
            </div>
            <div className="bg-gray-700 rounded-lg p-4 text-center">
              <div className="text-gray-400 text-sm mb-1">Probability of drawing at least 1:</div>
              <div className={`text-3xl font-comic ${drawProbability >= 70 ? 'text-green-400' : drawProbability >= 40 ? 'text-yellow-400' : 'text-red-400'}`}>
                {drawProbability.toFixed(1)}%
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Log Preview Modal Component
    const LogPreviewModal = ({ matches, skippedCount, onConfirm, onCancel }) => {
      const wins = matches.filter(m => m.result === 'WIN').length;
      const losses = matches.filter(m => m.result === 'LOSS').length;
      const totalCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-comic text-marvel-gold mb-4 text-center">Log Analysis Complete</h3>

            <div className="grid grid-cols-2 gap-3 mb-4">
              <div className="bg-gray-700 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">{matches.length}</div>
                <div className="text-xs text-gray-400">New Matches</div>
              </div>
              <div className="bg-gray-700 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-gray-400">{skippedCount}</div>
                <div className="text-xs text-gray-400">Duplicates Skipped</div>
              </div>
              <div className="bg-green-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-green-400">{wins}</div>
                <div className="text-xs text-gray-400">Wins</div>
              </div>
              <div className="bg-red-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-red-400">{losses}</div>
                <div className="text-xs text-gray-400">Losses</div>
              </div>
            </div>

            <div className="bg-gray-700 rounded-lg p-3 mb-4 text-center">
              <div className="text-xs text-gray-400 mb-1">Net Cubes from Import</div>
              <div className={`text-2xl font-bold ${totalCubes >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {totalCubes >= 0 ? '+' : ''}{totalCubes}
              </div>
            </div>

            {matches.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-300 mb-2">Preview (Recent 5):</h4>
                <div className="space-y-1 max-h-32 overflow-y-auto">
                  {matches.slice(0, 5).map((m, i) => (
                    <div key={i} className={`flex items-center justify-between p-2 rounded text-sm ${
                      m.result === 'WIN' ? 'bg-green-900/30' : 'bg-red-900/30'
                    }`}>
                      <span className={m.result === 'WIN' ? 'text-green-400' : 'text-red-400'}>{m.result}</span>
                      <span className="text-white">{m.result === 'WIN' ? '+' : '-'}{m.cubes}</span>
                      <span className="text-gray-400 text-xs">{formatDate(m.timestamp)}</span>
                    </div>
                  ))}
                  {matches.length > 5 && (
                    <div className="text-center text-gray-400 text-xs py-1">...and {matches.length - 5} more</div>
                  )}
                </div>
              </div>
            )}

            <div className="flex gap-2">
              <button onClick={() => onConfirm(matches)}
                className="flex-1 bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import {matches.length} Matches
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-gray-600 text-white py-3 rounded-lg font-medium hover:bg-gray-500">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Sync Confirm Modal Component
    const SyncConfirmModal = ({ syncData, onConfirm, onCancel }) => {
      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-comic text-marvel-gold mb-4 text-center">Sync Data Received</h3>

            <div className="bg-gray-700 rounded-lg p-4 mb-4">
              <div className="text-center mb-3">
                <div className="text-3xl font-bold text-marvel-blue">{syncData.c?.length || 0}</div>
                <div className="text-sm text-gray-400">Cards in Collection</div>
              </div>
              {syncData.s && (
                <div className="grid grid-cols-3 gap-2 text-center text-sm">
                  <div>
                    <div className="text-green-400 font-bold">{syncData.s.wins || 0}</div>
                    <div className="text-gray-400 text-xs">Wins</div>
                  </div>
                  <div>
                    <div className="text-red-400 font-bold">{syncData.s.losses || 0}</div>
                    <div className="text-gray-400 text-xs">Losses</div>
                  </div>
                  <div>
                    <div className={`font-bold ${(syncData.s.cubes || 0) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                      {(syncData.s.cubes || 0) >= 0 ? '+' : ''}{syncData.s.cubes || 0}
                    </div>
                    <div className="text-gray-400 text-xs">Cubes</div>
                  </div>
                </div>
              )}
            </div>

            <p className="text-gray-400 text-sm mb-4 text-center">
              This will merge the synced collection with your current data.
            </p>

            <div className="flex gap-2">
              <button onClick={onConfirm}
                className="flex-1 bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import Collection
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-gray-600 text-white py-3 rounded-lg font-medium hover:bg-gray-500">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Settings Component
    const Settings = ({ settings, setSettings, collection, matches, setCollection, setMatches, aiConfig, setAiConfig }) => {
      const [showImport, setShowImport] = useState(false);
      const [importData, setImportData] = useState('');
      const [showAdvanced, setShowAdvanced] = useState(false);
      const [testStatus, setTestStatus] = useState({});
      const [rapidApiKey, setRapidApiKey] = useState(loadFromStorage('snap_rapidapi_key', ''));
      const [isRefreshingCards, setIsRefreshingCards] = useState(false);

      // Phase 4: Log Ingestor state
      const [isDragOver, setIsDragOver] = useState(false);
      const [isProcessingLog, setIsProcessingLog] = useState(false);
      const [logError, setLogError] = useState(null);
      const [showLogPreview, setShowLogPreview] = useState(false);
      const [parsedMatches, setParsedMatches] = useState([]);
      const [skippedCount, setSkippedCount] = useState(0);
      const fileInputRef = useRef(null);

      // Phase 4: QR Sync state
      const [qrDataUrl, setQrDataUrl] = useState(null);
      const [qrError, setQrError] = useState(null);

      // Google OAuth initialization
      useEffect(() => {
        if (window.google?.accounts?.id) {
          window.google.accounts.id.initialize({
            client_id: GOOGLE_CLIENT_ID,
            callback: handleGoogleCallback,
            auto_select: false
          });
        }
      }, []);

      const handleGoogleCallback = (response) => {
        if (response.credential) {
          setAiConfig(prev => ({
            ...prev,
            provider: 'gemini-oauth',
            googleToken: response.credential,
            model: AIProviders['gemini-oauth'].defaultModel
          }));
          setTestStatus(prev => ({ ...prev, 'gemini-oauth': 'success' }));
        }
      };

      const handleGoogleSignIn = () => {
        if (window.google?.accounts?.id) {
          window.google.accounts.id.prompt((notification) => {
            if (notification.isNotDisplayed() || notification.isSkippedMoment()) {
              window.google.accounts.id.renderButton(
                document.getElementById('google-signin-container'),
                { theme: 'filled_blue', size: 'large', text: 'continue_with' }
              );
            }
          });
        } else {
          alert('Google Sign-In not loaded. Please refresh the page.');
        }
      };

      const handleGoogleSignOut = () => {
        setAiConfig(prev => ({ ...prev, provider: '', googleToken: null }));
        setTestStatus(prev => ({ ...prev, 'gemini-oauth': null }));
      };

      const setApiKey = (provider, key) => {
        setAiConfig(prev => ({
          ...prev,
          apiKeys: { ...prev.apiKeys, [provider]: key }
        }));
      };

      const selectProvider = (providerId) => {
        const provider = AIProviders[providerId];
        setAiConfig(prev => ({
          ...prev,
          provider: providerId,
          model: provider.defaultModel
        }));
      };

      const testConnection = async (providerId) => {
        setTestStatus(prev => ({ ...prev, [providerId]: 'testing' }));
        try {
          const testMessages = [{ role: 'user', content: 'Say "Connection successful!" in 5 words or less.' }];
          const model = aiConfig.model || AIProviders[providerId]?.defaultModel;

          switch (providerId) {
            case 'gemini-oauth':
              await callGeminiOAuth(testMessages, model, aiConfig.googleToken);
              break;
            case 'gemini':
              await callGeminiAPIKey(testMessages, model, aiConfig.apiKeys?.gemini);
              break;
            case 'groq':
              await callGroq(testMessages, model, aiConfig.apiKeys?.groq);
              break;
            case 'claude':
              await callClaude(testMessages, model, aiConfig.apiKeys?.claude);
              break;
            case 'openai':
              await callOpenAI(testMessages, model, aiConfig.apiKeys?.openai);
              break;
            case 'local':
              await callLocal(testMessages, model, aiConfig.localEndpoint);
              break;
            case 'mkg':
              await callMKG(testMessages, model, aiConfig.mkgEndpoint);
              break;
          }
          setTestStatus(prev => ({ ...prev, [providerId]: 'success' }));
        } catch (err) {
          console.error('Test failed:', err);
          setTestStatus(prev => ({ ...prev, [providerId]: 'error' }));
        }
      };

      const refreshCardData = async () => {
        if (!rapidApiKey) {
          alert('Please enter your RapidAPI key first');
          return;
        }
        setIsRefreshingCards(true);
        try {
          const response = await fetch('https://marvel-snap-api.p.rapidapi.com/api/getCards', {
            headers: {
              'x-rapidapi-host': 'marvel-snap-api.p.rapidapi.com',
              'x-rapidapi-key': rapidApiKey
            }
          });
          if (!response.ok) throw new Error('API request failed');
          const data = await response.json();
          saveToStorage('snap_card_cache', { data, timestamp: Date.now() });
          saveToStorage('snap_rapidapi_key', rapidApiKey);
          alert(`Card data refreshed! ${data.length || 'Unknown'} cards loaded.`);
        } catch (err) {
          alert('Failed to refresh cards: ' + err.message);
        } finally {
          setIsRefreshingCards(false);
        }
      };

      // Phase 4: Log file handlers
      const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
      };

      const handleLogDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
        const file = e.dataTransfer?.files[0];
        if (file) processLogFile(file);
      };

      const handleFileSelect = (e) => {
        const file = e.target.files?.[0];
        if (file) processLogFile(file);
      };

      const processLogFile = (file) => {
        setLogError(null);

        // Validate file
        if (!file.name.endsWith('.log') && !file.name.endsWith('.txt')) {
          setLogError('Please select a .log or .txt file');
          return;
        }

        // Size check (50MB limit)
        if (file.size > 50 * 1024 * 1024) {
          setLogError(LogErrors.FILE_TOO_LARGE);
          return;
        }

        setIsProcessingLog(true);

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const content = event.target.result;
            const parsed = LogParser.parsePlayerLog(content);

            if (parsed.matches.length === 0) {
              setLogError(LogErrors.NO_MATCHES);
              setIsProcessingLog(false);
              return;
            }

            // Check for duplicates against existing data
            const merged = LogParser.mergeWithExisting(parsed.matches, matches);

            setParsedMatches(merged.added);
            setSkippedCount(merged.skipped);
            setShowLogPreview(true);
            setIsProcessingLog(false);
          } catch (err) {
            console.error('Log parse error:', err);
            setLogError(LogErrors.PARSE_FAILED);
            setIsProcessingLog(false);
          }
        };

        reader.onerror = () => {
          setLogError(LogErrors.READ_ERROR);
          setIsProcessingLog(false);
        };

        reader.readAsText(file);
      };

      const handleLogImport = (matchesToImport) => {
        setMatches(prev => [...prev, ...matchesToImport].sort((a, b) =>
          new Date(b.timestamp) - new Date(a.timestamp)
        ));
        setShowLogPreview(false);
        setParsedMatches([]);
        alert(`Successfully imported ${matchesToImport.length} matches!`);
      };

      // Phase 4: QR Code generation
      const generateSyncQR = async () => {
        setQrError(null);
        setQrDataUrl(null);

        try {
          const syncData = VaultManager.generateSyncData(collection, matches);
          const compressed = VaultManager.compressForQR(syncData);

          if (!compressed) {
            setQrError('Failed to compress data');
            return;
          }

          // QR codes have size limits (~2.5KB for reliable scanning)
          if (compressed.length > 2500) {
            setQrError('Collection too large for QR sync. Use file export instead.');
            return;
          }

          const syncUrl = `https://platano78.github.io/Marvel-Snap-Tactics-/?sync=${compressed}`;

          // Generate QR code using the QRCode library
          const dataUrl = await QRCode.toDataURL(syncUrl, {
            width: 200,
            margin: 2,
            color: { dark: '#1A1A1A', light: '#FFFFFF' }
          });

          setQrDataUrl(dataUrl);
        } catch (err) {
          console.error('QR generation error:', err);
          setQrError('Failed to generate QR code');
        }
      };

      // Phase 4: Vault export
      const exportVault = () => {
        const vault = VaultManager.exportFullVault(collection, matches, settings);
        const blob = new Blob([JSON.stringify(vault, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `snapapoulous-vault-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      };

      const handleExport = (type) => {
        let data, filename;
        if (type === 'all') {
          data = { collection, matches, settings, aiConfig: { ...aiConfig, apiKeys: {}, googleToken: null } };
          filename = `snapapoulous-backup-${new Date().toISOString().split('T')[0]}.json`;
        } else if (type === 'collection') {
          data = collection;
          filename = `snap-collection-${new Date().toISOString().split('T')[0]}.json`;
        } else {
          data = matches;
          filename = `snap-matches-${new Date().toISOString().split('T')[0]}.json`;
        }
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
      };

      const handleImport = () => {
        try {
          const data = JSON.parse(importData);
          if (data.collection && data.matches) {
            setCollection(data.collection);
            setMatches(data.matches);
            if (data.settings) setSettings(data.settings);
            alert('Data imported successfully!');
          } else if (data.owned) {
            setCollection(data);
            alert('Collection imported!');
          } else if (Array.isArray(data)) {
            setMatches(data);
            alert('Matches imported!');
          } else {
            alert('Unrecognized format');
          }
          setShowImport(false);
          setImportData('');
        } catch { alert('Invalid JSON'); }
      };

      const StatusBadge = ({ status }) => {
        if (!status) return null;
        if (status === 'testing') return <span className="text-yellow-400 text-xs">Testing...</span>;
        if (status === 'success') return <span className="text-green-400 text-xs">Connected</span>;
        return <span className="text-red-400 text-xs">Failed</span>;
      };

      const mainProviders = Object.values(AIProviders).filter(p => !p.advanced);
      const advancedProviders = Object.values(AIProviders).filter(p => p.advanced);

      return (
        <div className="px-4 pb-20">
          <Header title="SETTINGS" />

          {/* App Info */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <div className="flex items-center gap-3">
              <div className="w-12 h-12 bg-marvel-red rounded-lg flex items-center justify-center">
                <span className="text-2xl font-comic text-white">S</span>
              </div>
              <div>
                <div className="text-white font-bold">Snapapoulous Prime</div>
                <div className="text-gray-400 text-sm">v2.1.0 - Log Sync Edition</div>
              </div>
            </div>
          </div>

          {/* PC Data Sync - Phase 4 */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">PC Data Sync</h3>
            <p className="text-gray-400 text-sm mb-4">
              Playing on PC/Steam? Drag your Player.log file here to automatically import your match history.
            </p>

            <div
              className={`drop-zone ${isDragOver ? 'drag-over' : ''}`}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onDrop={handleLogDrop}
              onClick={() => fileInputRef.current?.click()}
            >
              {isProcessingLog ? (
                <div className="flex flex-col items-center">
                  <div className="spinner mb-2"></div>
                  <span className="text-gray-300">Analyzing Player.log...</span>
                  <span className="text-gray-500 text-xs mt-1">This may take a moment for large files</span>
                </div>
              ) : (
                <>
                  <span className="drop-icon">üìÇ</span>
                  <span className="text-gray-300">Drop Player.log here or click to browse</span>
                  <span className="file-path">
                    Windows: %AppData%\LocalLow\Second Dinner\SNAP\...\Player.log
                  </span>
                  <span className="file-path">
                    Mac: ~/Library/Application Support/Second Dinner/SNAP/.../Player.log
                  </span>
                </>
              )}
            </div>
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileSelect}
              accept=".log,.txt"
              className="hidden"
            />

            {logError && (
              <div className="mt-3 bg-red-900/50 border border-red-500 rounded-lg p-3">
                <p className="text-red-300 text-sm">{logError}</p>
              </div>
            )}
          </div>

          {/* QR Sync - Phase 4 */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Cross-Device Sync</h3>
            <p className="text-gray-400 text-sm mb-4">
              Generate a QR code to quickly sync your collection to another device.
            </p>

            <button
              onClick={generateSyncQR}
              className="w-full bg-marvel-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600 mb-3"
            >
              üì± Generate Sync QR Code
            </button>

            {qrError && (
              <div className="bg-red-900/50 border border-red-500 rounded-lg p-3 mb-3">
                <p className="text-red-300 text-sm">{qrError}</p>
              </div>
            )}

            {qrDataUrl && (
              <div className="text-center">
                <div className="qr-container inline-block mb-2">
                  <img src={qrDataUrl} alt="Sync QR Code" />
                </div>
                <p className="text-gray-400 text-xs">Scan with your phone camera to sync collection</p>
              </div>
            )}
          </div>

          {/* AI Provider Configuration */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-4">AI Provider</h3>

            {/* Google OAuth - Primary */}
            <div className="mb-4 p-4 bg-gray-700 rounded-lg border-2 border-marvel-blue">
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2">
                  <span className="text-white font-medium">Google (Gemini)</span>
                  <span className="bg-marvel-blue text-white text-xs px-2 py-0.5 rounded">Recommended</span>
                </div>
                <StatusBadge status={testStatus['gemini-oauth']} />
              </div>
              <p className="text-gray-400 text-sm mb-3">One-click sign in, no API key needed</p>

              {aiConfig.googleToken ? (
                <div className="flex gap-2">
                  <button onClick={() => selectProvider('gemini-oauth')}
                    className={`flex-1 py-2 rounded font-medium ${aiConfig.provider === 'gemini-oauth' ? 'bg-marvel-blue text-white' : 'bg-gray-600 text-gray-300'}`}>
                    {aiConfig.provider === 'gemini-oauth' ? 'Selected' : 'Use This'}
                  </button>
                  <button onClick={() => testConnection('gemini-oauth')}
                    className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-500">Test</button>
                  <button onClick={handleGoogleSignOut}
                    className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-500">Sign Out</button>
                </div>
              ) : (
                <div>
                  <button onClick={handleGoogleSignIn}
                    className="w-full bg-white text-gray-800 py-3 rounded-lg font-medium flex items-center justify-center gap-2 hover:bg-gray-100">
                    <svg className="w-5 h-5" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Continue with Google
                  </button>
                  <div id="google-signin-container" className="mt-2"></div>
                </div>
              )}
            </div>

            {/* API Key Providers */}
            {mainProviders.filter(p => p.id !== 'gemini-oauth').map(provider => (
              <div key={provider.id} className="mb-3 p-3 bg-gray-700 rounded-lg">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-white font-medium">{provider.name}</span>
                  <StatusBadge status={testStatus[provider.id]} />
                </div>
                <p className="text-gray-400 text-xs mb-2">{provider.description}</p>
                <div className="flex gap-2">
                  <input type="password" placeholder="API Key..."
                    value={aiConfig.apiKeys?.[provider.id] || ''}
                    onChange={(e) => setApiKey(provider.id, e.target.value)}
                    className="flex-1 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                  <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                    disabled={!aiConfig.apiKeys?.[provider.id]}
                    className="bg-marvel-blue text-white px-3 py-2 rounded text-sm hover:bg-blue-600 disabled:opacity-50">
                    Test
                  </button>
                </div>
                {aiConfig.provider === provider.id && (
                  <div className="mt-2">
                    <select value={aiConfig.model || provider.defaultModel}
                      onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                      className="w-full bg-gray-600 text-white rounded px-2 py-1 text-sm border border-gray-500">
                      {provider.models.map(m => <option key={m} value={m}>{m}</option>)}
                    </select>
                  </div>
                )}
              </div>
            ))}

            {/* Advanced Section */}
            <button onClick={() => setShowAdvanced(!showAdvanced)}
              className="w-full flex items-center justify-between py-2 text-gray-400 hover:text-white">
              <span className="text-sm">Advanced Options</span>
              <span>{showAdvanced ? '‚ñ≤' : '‚ñº'}</span>
            </button>

            {showAdvanced && (
              <div className="mt-3 space-y-3">
                {advancedProviders.map(provider => (
                  <div key={provider.id} className="p-3 bg-gray-700 rounded-lg">
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-white font-medium">{provider.name}</span>
                      <StatusBadge status={testStatus[provider.id]} />
                    </div>
                    <p className="text-gray-400 text-xs mb-2">{provider.description}</p>
                    <div className="flex gap-2">
                      <input type="text"
                        placeholder={provider.id === 'local' ? 'http://localhost:11434' : 'http://localhost:8000'}
                        value={provider.id === 'local' ? (aiConfig.localEndpoint || '') : (aiConfig.mkgEndpoint || '')}
                        onChange={(e) => setAiConfig(prev => ({
                          ...prev,
                          [provider.id === 'local' ? 'localEndpoint' : 'mkgEndpoint']: e.target.value
                        }))}
                        className="flex-1 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                      <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                        className="bg-gray-600 text-white px-3 py-2 rounded text-sm hover:bg-gray-500">Test</button>
                    </div>
                    {aiConfig.provider === provider.id && (
                      <input type="text" placeholder="Model name..."
                        value={aiConfig.model || ''}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                        className="w-full mt-2 bg-gray-600 text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-marvel-red focus:outline-none" />
                    )}
                  </div>
                ))}
              </div>
            )}

            {/* Current Selection */}
            {aiConfig.provider && (
              <div className="mt-4 p-3 bg-green-900/30 border border-green-600 rounded-lg">
                <div className="text-green-400 text-sm">
                  Active: <strong>{AIProviders[aiConfig.provider]?.name}</strong>
                  {aiConfig.model && <span className="text-green-300"> ({aiConfig.model})</span>}
                </div>
              </div>
            )}
          </div>

          {/* RapidAPI Card Refresh */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Card Data (Optional)</h3>
            <p className="text-gray-400 text-sm mb-3">Refresh card data from RapidAPI for the latest cards</p>
            <input type="password" placeholder="RapidAPI Key..."
              value={rapidApiKey} onChange={(e) => setRapidApiKey(e.target.value)}
              className="w-full bg-gray-700 text-white rounded px-3 py-2 mb-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none" />
            <button onClick={refreshCardData} disabled={isRefreshingCards}
              className="w-full bg-series-3 text-white py-2 rounded hover:opacity-80 disabled:opacity-50">
              {isRefreshingCards ? 'Refreshing...' : 'Refresh Card Data'}
            </button>
            <p className="text-gray-500 text-xs mt-2">
              Get a free key at <a href="https://rapidapi.com/zelgady-SeTJboMFFHk/api/marvel-snap-api" target="_blank" className="text-marvel-blue hover:underline">RapidAPI</a>
            </p>
          </div>

          {/* Export/Import */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border mb-4">
            <h3 className="text-lg font-comic text-marvel-gold mb-3">Export Data</h3>
            <div className="space-y-2 mb-4">
              <button onClick={exportVault} className="w-full bg-marvel-gold text-black py-3 rounded-lg font-medium hover:bg-yellow-400 flex items-center justify-center gap-2">
                <span>üì¶</span> Export Full Vault (Recommended)
              </button>
              <div className="grid grid-cols-3 gap-2">
                <button onClick={() => handleExport('all')} className="bg-marvel-blue text-white py-2 rounded text-sm hover:bg-blue-600">Backup</button>
                <button onClick={() => handleExport('collection')} className="bg-series-3 text-white py-2 rounded text-sm hover:opacity-80">Collection</button>
                <button onClick={() => handleExport('matches')} className="bg-series-2 text-white py-2 rounded text-sm hover:opacity-80">Matches</button>
              </div>
            </div>

            <h3 className="text-lg font-comic text-marvel-gold mb-3">Import Data</h3>
            {!showImport ? (
              <button onClick={() => setShowImport(true)} className="w-full bg-gray-700 text-white py-2 rounded hover:bg-gray-600">
                Import from JSON
              </button>
            ) : (
              <div className="space-y-2">
                <textarea value={importData} onChange={(e) => setImportData(e.target.value)}
                  placeholder="Paste JSON data here..."
                  className="w-full h-24 bg-gray-700 text-white rounded px-3 py-2 border-2 border-gray-600 focus:border-marvel-red focus:outline-none text-sm" />
                <div className="flex gap-2">
                  <button onClick={handleImport} className="flex-1 bg-marvel-blue text-white py-2 rounded hover:bg-blue-600">Import</button>
                  <button onClick={() => { setShowImport(false); setImportData(''); }} className="flex-1 bg-gray-600 text-white py-2 rounded hover:bg-gray-500">Cancel</button>
                </div>
              </div>
            )}
          </div>

          {/* Danger Zone */}
          <div className="bg-gray-800 rounded-lg p-4 panel-border border-red-500/50">
            <h3 className="text-lg font-comic text-red-400 mb-3">Danger Zone</h3>
            <button onClick={() => {
              if (confirm('Clear ALL data including AI settings?')) {
                localStorage.clear();
                setCollection({ owned: [], lastUpdated: new Date().toISOString() });
                setMatches([]);
                setSettings({ theme: 'dark' });
                setAiConfig({ provider: '', model: '', apiKeys: {}, googleToken: null, localEndpoint: 'http://localhost:11434', mkgEndpoint: 'http://localhost:8000' });
                alert('All data cleared');
              }
            }} className="w-full bg-red-600 text-white py-2 rounded hover:bg-red-500">Clear All Data</button>
          </div>

          {/* Log Preview Modal */}
          {showLogPreview && (
            <LogPreviewModal
              matches={parsedMatches}
              skippedCount={skippedCount}
              onConfirm={handleLogImport}
              onCancel={() => { setShowLogPreview(false); setParsedMatches([]); }}
            />
          )}
        </div>
      );
    };

    // ==================== MAIN APP ====================
    const App = () => {
      const [activeTab, setActiveTab] = useState('dashboard');
      const [collection, setCollection] = useState(() => loadFromStorage('snap_collection', { owned: [], lastUpdated: new Date().toISOString() }));
      const [matches, setMatches] = useState(() => loadFromStorage('snap_matches', []));
      const [settings, setSettings] = useState(() => loadFromStorage('snap_settings', { theme: 'dark' }));
      const [aiConfig, setAiConfig] = useState(() => loadFromStorage('snap_ai_config', {
        provider: '',
        model: '',
        apiKeys: {},
        googleToken: null,
        localEndpoint: 'http://localhost:11434',
        mkgEndpoint: 'http://localhost:8000'
      }));

      // Phase 4: URL Sync state
      const [syncImportData, setSyncImportData] = useState(null);
      const [showSyncConfirm, setShowSyncConfirm] = useState(false);

      useEffect(() => { saveToStorage('snap_collection', collection); }, [collection]);
      useEffect(() => { saveToStorage('snap_matches', matches); }, [matches]);
      useEffect(() => { saveToStorage('snap_settings', settings); }, [settings]);
      useEffect(() => { saveToStorage('snap_ai_config', aiConfig); }, [aiConfig]);

      // Phase 4: Check for sync parameter in URL on load
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const syncData = params.get('sync');

        if (syncData) {
          try {
            const data = VaultManager.decompressFromQR(syncData);

            if (data && data.v === 1 && data.c) {
              setSyncImportData(data);
              setShowSyncConfirm(true);

              // Clean URL
              window.history.replaceState({}, '', window.location.pathname);
            }
          } catch (e) {
            console.error('Invalid sync data:', e);
          }
        }
      }, []);

      const handleSyncImport = () => {
        if (syncImportData && syncImportData.c) {
          // Merge collections - add new cards without removing existing
          const existingOwned = new Set(collection.owned || []);
          syncImportData.c.forEach(card => existingOwned.add(card));

          setCollection({
            owned: Array.from(existingOwned),
            lastUpdated: new Date().toISOString()
          });

          setShowSyncConfirm(false);
          setSyncImportData(null);
          alert(`Synced ${syncImportData.c.length} cards to your collection!`);
        }
      };

      const handleQuickMatch = (result, cubes) => {
        setMatches(prev => [...prev, {
          id: generateId(),
          timestamp: new Date().toISOString(),
          result, cubes,
          opponent: '', deck: '', notes: '', snapped: 'NONE'
        }]);
      };

      useEffect(() => {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js')
            .then(reg => console.log('SW registered:', reg.scope))
            .catch(err => console.error('SW error:', err));
        }
      }, []);

      return (
        <div className="min-h-screen bg-marvel-black">
          {activeTab === 'dashboard' && <Dashboard collection={collection} matches={matches} onQuickMatch={handleQuickMatch} />}
          {activeTab === 'ai' && <AIChat collection={collection} matches={matches} aiConfig={aiConfig} setActiveTab={setActiveTab} />}
          {activeTab === 'collection' && <Collection collection={collection} setCollection={setCollection} />}
          {activeTab === 'calculator' && <Calculator />}
          {activeTab === 'settings' && <Settings settings={settings} setSettings={setSettings} collection={collection} matches={matches} setCollection={setCollection} setMatches={setMatches} aiConfig={aiConfig} setAiConfig={setAiConfig} />}
          <NavBar activeTab={activeTab} setActiveTab={setActiveTab} />

          {/* Phase 4: Sync Confirm Modal */}
          {showSyncConfirm && syncImportData && (
            <SyncConfirmModal
              syncData={syncImportData}
              onConfirm={handleSyncImport}
              onCancel={() => { setShowSyncConfirm(false); setSyncImportData(null); }}
            />
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
