<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#120818" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#120818" media="(prefers-color-scheme: dark)">
  <meta name="description" content="Marvel Snap AI Companion & Tracker - Track your collection, log matches, and get tactical advice">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SnapPrime">

  <title>Snapapoulous Prime - Marvel Snap Companion</title>

  <!-- Preconnect to CDN origins for faster resource loading -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
  <link rel="preconnect" href="https://accounts.google.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">

  <!-- Google Fonts - Spline Sans (UI) + Inter (fallback) + Permanent Marker (Hero) + Material Symbols -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Spline+Sans:wght@400;500;600;700&family=Inter:wght@400;500;600;700&family=Permanent+Marker&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&display=swap" rel="stylesheet">

  <!-- Service Worker Update Handler - runs early to catch SW updates -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'SW_UPDATED') {
          console.log('[App] Service worker updated to:', event.data.version);
          window.location.reload();
        }
      });
    }
  </script>

  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="assets/icons/icon-192.png">
  <link rel="apple-touch-icon" href="assets/icons/icon-192.png">

  <!-- iOS Splash Screens -->
  <!-- iPhone X / XS / 11 Pro (1125x2436) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone XR / 11 (828x1792) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)">
  <!-- iPhone XS Max / 11 Pro Max (1242x2688) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 12 / 12 Pro / 13 / 13 Pro / 14 (1170x2532) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 12/13 Mini (1080x2340) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 360px) and (device-height: 780px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 12 Pro Max / 13 Pro Max / 14 Plus (1284x2778) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 14 Pro (1179x2556) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone 14 Pro Max (1290x2796) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3)">
  <!-- iPhone SE 2/3, iPhone 8 (750x1334) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)">
  <!-- iPhone 8 Plus (1242x2208) -->
  <link rel="apple-touch-startup-image"
        href="assets/icons/icon-512.png"
        media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3)">

  <!-- Google Identity Services for OAuth -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- QR Code Generation - deferred as non-critical for initial render -->
  <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js" defer></script>

  <!-- LZ-String for compression (QR sync) - deferred as non-critical for initial render -->
  <script src="https://unpkg.com/lz-string@1.5.0/libs/lz-string.min.js" defer></script>

  <!-- Tailwind Config -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            // Cosmic Purple Foundation
            'mcu-blue': '#c75fff',
            'mcu-blue-light': '#d9a8ff',
            'mcu-red': '#ff4444',
            'mcu-gold': '#ffd700',
            'stark-dark': '#120818',
            'stark-surface': '#1c1022',
            'stark-surface-2': '#2b1933',
            // Cosmic Accents
            'cosmic-purple': '#ad2bee',
            'cosmic-purple-text': '#c75fff',
            'cosmic-cyan': '#00f3ff',
            'spider-pink': '#ff00ff',
            'spider-cyan': '#00ffff',
            'spider-yellow': '#fef08a',
            // Series colors (unchanged)
            'series-1': '#6B7280',
            'series-2': '#22C55E',
            'series-3': '#8B5CF6',
            'series-4': '#EAB308',
            'series-5': '#EF4444',
            'series-6': '#F97316',
            'series-7': '#EC4899',
            'series-8': '#06B6D4',
            'series-9': '#84CC16',
            'series-10': '#A855F7',
            'spotlight': '#F97316',
            // Stitch Design Tokens
            'stitch-muted': '#b792c9',
            'stitch-accent': '#3c2348',
            'stitch-border': '#553267',
            'stitch-green': '#0bda76',
            'stitch-card': '#2a1a33',
            // Legacy (for gradual migration)
            'marvel-red': '#ED1D24',
            'marvel-blue': '#006EC7',
            'marvel-gold': '#FFC107',
            'marvel-black': '#1A1A1A',
            'marvel-white': '#FFFFFF',
          },
          fontFamily: {
            'display': ['Spline Sans', 'Inter', 'system-ui', 'sans-serif'],
            'hero': ['Permanent Marker', 'cursive'],
            'mono': ['SF Mono', 'Menlo', 'Monaco', 'monospace'],
            'comic': ['Impact', 'Arial Black', 'sans-serif'],
          },
          boxShadow: {
            'glass': '0 0 20px rgba(173, 43, 238, 0.15)',
            'glow-blue': '0 0 15px rgba(173, 43, 238, 0.4), inset 0 0 5px rgba(173, 43, 238, 0.2)',
            'glow-red': '0 0 15px rgba(255, 68, 68, 0.4), inset 0 0 5px rgba(255, 68, 68, 0.2)',
            'glow-gold': '0 0 15px rgba(255, 215, 0, 0.4), inset 0 0 5px rgba(255, 215, 0, 0.2)',
            'glow-purple': '0 0 15px rgba(173, 43, 238, 0.4)',
            'sketch': '6px 6px 0 #111',
            'comic': '4px 4px 0px #1A1A1A',
            'comic-sm': '2px 2px 0px #1A1A1A',
          },
          backdropBlur: {
            'glass': '12px',
            'glass-mobile': '6px',
          }
        }
      }
    }
  </script>

  <style>
    /* ============================================
       LAYER 1: BRAND TOKENS (Raw palette values)
       ============================================ */
    :root {
      /* Cosmic Purple Foundation */
      --mcu-blue: #c75fff;
      --mcu-blue-light: #d9a8ff;
      --mcu-blue-glow: rgba(173, 43, 238, 0.4);
      --mcu-red: #ff4444;
      --mcu-red-glow: rgba(255, 68, 68, 0.4);
      --mcu-gold: #ffd700;

      /* Cosmic Accents */
      --cosmic-purple: #ad2bee;
      --cosmic-purple-text: #c75fff;
      --cosmic-cyan: #00f3ff;
      --spider-pink: #ff00ff;
      --spider-cyan: #00ffff;
      --spider-yellow: #fef08a;

      /* Series Colors (unchanged) */
      --series-1: #6B7280;
      --series-2: #22C55E;
      --series-3: #8B5CF6;
      --series-4: #EAB308;
      --series-5: #EF4444;
      --series-6: #F97316;
      --series-7: #EC4899;
      --series-8: #06B6D4;
      --series-9: #84CC16;
      --series-10: #A855F7;
      --spotlight: #F97316;

      /* ============================================
         LAYER 2: SEMANTIC TOKENS
         ============================================ */

      /* Surfaces - Cosmic Purple */
      --ui-surface-base: #120818;
      --ui-surface-1: #1c1022;
      --ui-surface-2: #2b1933;
      --ui-surface-glass: rgba(60, 35, 72, 0.6);
      --ui-surface-glass-solid: rgba(28, 16, 34, 0.92);

      /* Borders */
      --ui-border: rgba(255, 255, 255, 0.08);
      --ui-border-accent: rgba(173, 43, 238, 0.6);

      /* Text */
      --ui-text-primary: #eaeaf0;
      --ui-text-secondary: #a08cb0;
      --ui-text-muted: #6e5c7e;
      --ui-text-accent: var(--cosmic-purple-text);

      /* Legacy text tokens (WCAG AA compliant) */
      --text-muted: #9CA3AF;
      --text-placeholder: #9CA3AF;
      --text-disabled: #D1D5DB;

      /* Accent (maps to cosmic purple) */
      --ui-accent: var(--cosmic-purple-text);
      --ui-accent-glow: var(--mcu-blue-glow);
      --ui-accent-light: var(--mcu-blue-light);

      /* Semantic States */
      --ui-success: #22C55E;
      --ui-warning: #EAB308;
      --ui-danger: var(--mcu-red);
      --ui-info: var(--cosmic-purple-text);

      /* Focus Ring (accessibility - gold passes at 13.95:1) */
      --ui-focus-ring: var(--mcu-gold);
      --ui-focus-ring-glow: rgba(255, 215, 0, 0.4);

      /* Shadows */
      --ui-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.3);
      --ui-shadow-glow: 0 0 15px rgba(173, 43, 238, 0.15);
      --ui-shadow-strong: 0 8px 24px rgba(0, 0, 0, 0.5);

      /* Cosmic Glow Effects */
      --holo-glow: 0 0 15px rgba(173, 43, 238, 0.4);
      --rank-glow: drop-shadow(0 0 15px rgba(173, 43, 238, 0.6));

      /* Stitch Design Tokens */
      --stitch-muted: #b792c9;
      --stitch-accent: #3c2348;
      --stitch-border: #553267;
      --stitch-green: #0bda76;
      --stitch-card: #2a1a33;

      /* Spider-Verse Highlight (overlays only) */
      --ui-highlight: var(--spider-yellow);
      --ui-highlight-glitch: var(--spider-pink);

      /* ============================================
         LAYER 3: EFFECT TOKENS
         ============================================ */

      /* Glass Effects */
      --glass-blur: blur(12px);
      --glass-blur-mobile: blur(6px);
      --glass-blur-none: blur(0px);

      /* Chromatic Effects */
      --chromatic-offset: 2px;
      --sketch-shadow: 6px 6px 0 #111;

      /* Neon Outer Glow for accessibility */
      --text-glow-accent: 0 0 8px rgba(173, 43, 238, 0.4), 0 0 16px rgba(173, 43, 238, 0.3);

      /* ============================================
         LAYER 4: TYPOGRAPHY TOKENS
         ============================================ */

      --font-ui: 'Spline Sans', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-mono: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
      --font-hero: 'Permanent Marker', cursive;
    }

    /* ============================================
       PERFORMANCE MODE TOGGLE
       Detect low-power devices and disable heavy effects
       ============================================ */

    html[data-perf="low"] {
      --glass-blur: var(--glass-blur-none);
      --glass-blur-mobile: var(--glass-blur-none);
      --ui-surface-glass: var(--ui-surface-glass-solid);
      --ui-shadow-glow: none;
      --text-glow-accent: none;
    }

    @media (prefers-reduced-motion: reduce) {
      :root {
        --glass-blur: var(--glass-blur-none);
        --ui-shadow-glow: none;
      }
    }

    /* ============================================
       REDUCED MOTION - COMPLETE HANDLING
       Kill ALL animations, not just specific ones
       ============================================ */

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    html[data-motion="reduced"] *,
    html[data-motion="reduced"] *::before,
    html[data-motion="reduced"] *::after {
      animation: none !important;
      transition: none !important;
    }

    * { -webkit-tap-highlight-color: transparent; }

    /* Custom focus ring for all interactive elements */
    :focus-visible {
      outline: 3px solid var(--ui-focus-ring);
      outline-offset: 2px;
    }
    :focus:not(:focus-visible) {
      outline: none;
    }
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    select:focus-visible {
      outline: 3px solid var(--ui-focus-ring);
      outline-offset: 2px;
      box-shadow: 0 0 0 6px var(--ui-focus-ring-glow);
    }

    /* Screen reader only utility class */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* ============================================
       COSMIC GLOW EFFECTS
       ============================================ */
    .mcu-glow-blue {
      box-shadow: 0 0 15px rgba(173, 43, 238, 0.4), inset 0 0 5px rgba(173, 43, 238, 0.2);
    }

    .mcu-glow-red {
      box-shadow: 0 0 15px var(--mcu-red-glow), inset 0 0 5px var(--mcu-red-glow);
    }

    .mcu-glow-gold {
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.4), inset 0 0 5px rgba(255, 215, 0, 0.2);
    }

    .mcu-text-glow {
      text-shadow: var(--text-glow-accent);
    }

    /* Holographic Card Glow */
    .holo-glow {
      box-shadow: 0 0 15px rgba(173, 43, 238, 0.4);
    }

    /* Rank Glow */
    .rank-glow {
      filter: drop-shadow(0 0 15px rgba(173, 43, 238, 0.6));
    }

    /* Card Slot (empty deck slot) */
    .card-slot {
      background: linear-gradient(135deg, #1a1320, #251830);
      border: 2px dashed rgba(173, 43, 238, 0.3);
      border-radius: 0.75rem;
      aspect-ratio: 3/4;
    }
    @supports not (aspect-ratio: 3/4) {
      .card-slot {
        position: relative;
        padding-bottom: 133.33%;
        height: 0;
      }
    }
    .card-slot.filled {
      border-style: solid;
      border-color: rgba(173, 43, 238, 0.6);
      box-shadow: 0 0 15px rgba(173, 43, 238, 0.4);
    }

    /* Show remove button on touch devices (no hover capability) */
    @media (hover: none) {
      .group .group-hover\:opacity-100 {
        opacity: 1;
      }
    }

    /* Cosmic Gradient (linear variant) */
    .cosmic-gradient {
      background: linear-gradient(135deg, #1c1022 0%, #2d1b4d 50%, #1c1022 100%);
    }

    /* Scrollbar hide utility */
    .scrollbar-hide {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .scrollbar-hide::-webkit-scrollbar {
      display: none;
    }

    /* Material Symbols sizing */
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
      font-size: 24px;
      line-height: 1;
    }

    /* Spider-Verse Chromatic Text (Victory/High-Energy only) */
    .glitch-text {
      text-shadow:
        var(--chromatic-offset) 0 var(--spider-pink),
        calc(-1 * var(--chromatic-offset)) 0 var(--spider-cyan);
    }

    /* Spider-Verse Sketch Border (Hover states) */
    .sketch-border {
      border: 3px solid #111;
      box-shadow: var(--sketch-shadow);
    }

    /* Cosmic HUD Grid Background */
    .mcu-hud-grid {
      background-image:
        linear-gradient(rgba(173, 43, 238, 0.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(173, 43, 238, 0.04) 1px, transparent 1px);
      background-size: 40px 40px;
    }

    /* Cosmic Pulse Animation */
    @keyframes arc-pulse {
      0%, 100% { box-shadow: 0 0 20px rgba(173, 43, 238, 0.3); }
      50% { box-shadow: 0 0 30px rgba(173, 43, 238, 0.5), 0 0 40px rgba(173, 43, 238, 0.3); }
    }

    .arc-pulse {
      animation: arc-pulse 2s ease-in-out infinite;
    }

    /* Spider-Verse Glitch Animation (Victory only) */
    @keyframes chromatic-glitch {
      0%, 100% { text-shadow: 2px 0 var(--spider-pink), -2px 0 var(--spider-cyan); }
      25% { text-shadow: -2px 0 var(--spider-pink), 2px 0 var(--spider-cyan); }
      50% { text-shadow: 1px 1px var(--spider-pink), -1px -1px var(--spider-cyan); }
      75% { text-shadow: -1px 1px var(--spider-pink), 1px -1px var(--spider-cyan); }
    }

    .chromatic-glitch {
      animation: chromatic-glitch 0.3s ease-in-out infinite;
    }

    /* Reduced Motion Support for all cosmic effects */
    @media (prefers-reduced-motion: reduce) {
      .arc-pulse,
      .glitch-text,
      .chromatic-glitch {
        animation: none;
        text-shadow: none;
      }
      .holo-glow,
      .rank-glow,
      .card-slot.filled {
        box-shadow: none;
        filter: none;
      }
    }

    body {
      font-family: var(--font-ui);
      background-color: var(--ui-surface-base);
      color: var(--ui-text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }
    @media (orientation: landscape) {
      .app-container {
        padding-left: max(1rem, env(safe-area-inset-left));
        padding-right: max(1rem, env(safe-area-inset-right));
      }
    }
    /* Safe area support for fixed elements */
    nav.fixed.bottom-0 {
      padding-bottom: env(safe-area-inset-bottom);
    }
    header {
      padding-top: calc(1rem + env(safe-area-inset-top));
    }
    .panel-border { border: 3px solid #1A1A1A; box-shadow: 4px 4px 0px #1A1A1A; }
    .halftone { background-image: radial-gradient(circle, rgba(0,0,0,0.1) 1px, transparent 1px); background-size: 8px 8px; }
    .card-hover { transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; }
    .card-hover:active { transform: scale(0.98); }
    .series-border-1 { border-color: #6B7280; }
    .series-border-2 { border-color: #22C55E; }
    .series-border-3 { border-color: #8B5CF6; }
    .series-border-4 { border-color: #EAB308; }
    .series-border-5 { border-color: #EF4444; }
    .series-border-spotlight { border-color: #F97316; }

    /* ============================================
       STITCH DESIGN SYSTEM COMPONENTS
       Reusable classes for the Stitch UI redesign
       ============================================ */

    /* Stat card */
    .stitch-stat {
      background: rgba(173, 43, 238, 0.08);
      border: 1px solid rgba(173, 43, 238, 0.2);
      border-radius: 0.75rem;
      padding: 1rem;
    }

    /* Micro label */
    .stitch-label {
      color: var(--stitch-muted);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 700;
    }

    /* Card panel */
    .stitch-card {
      background: var(--stitch-card);
      border-radius: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    /* Filter pills */
    .stitch-pill {
      display: inline-flex;
      align-items: center;
      padding: 0.375rem 0.875rem;
      border-radius: 9999px;
      font-size: 0.8125rem;
      font-weight: 600;
      background: var(--stitch-accent);
      color: var(--stitch-muted);
      border: 1px solid var(--stitch-border);
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .stitch-pill:hover {
      background: rgba(85, 50, 103, 0.8);
    }
    .stitch-pill.active {
      background: var(--cosmic-purple);
      color: white;
      border-color: var(--cosmic-purple);
    }

    /* Sticky top bar */
    .stitch-topbar {
      background: rgba(28, 16, 34, 0.92);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--stitch-border);
    }

    /* Progress bars */
    .stitch-progress {
      background: rgba(26, 19, 32, 0.8);
      border-radius: 9999px;
      height: 0.5rem;
      overflow: hidden;
    }
    .stitch-progress-fill {
      height: 100%;
      border-radius: 9999px;
      transition: width 0.3s ease;
    }

    /* Small chips / badges */
    .stitch-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.125rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      background: rgba(173, 43, 238, 0.2);
      color: white;
    }

    /* List entry */
    .stitch-list-item {
      background: var(--stitch-card);
      border-radius: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 0.75rem;
      transition: background 0.15s ease;
    }
    .stitch-list-item:hover {
      background: rgba(60, 35, 72, 0.5);
    }

    /* Section header */
    .stitch-section-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8125rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--stitch-muted);
      margin-bottom: 0.75rem;
    }
    .stitch-section-header .material-symbols-outlined {
      font-size: 18px;
      color: var(--cosmic-purple-text);
    }

    /* Card art with fallback gradient */
    .card-art {
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-color: var(--stitch-card);
    }
    .card-art-fallback {
      background: linear-gradient(135deg, #2a1a33 0%, #3c2348 50%, #2a1a33 100%);
    }

    /* Floating action button */
    .stitch-fab {
      position: fixed;
      bottom: 5.5rem;
      right: 1.25rem;
      width: 3.5rem;
      height: 3.5rem;
      border-radius: 9999px;
      background: var(--cosmic-purple);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(173, 43, 238, 0.4);
      z-index: 40;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .stitch-fab:active {
      transform: scale(0.95);
    }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #1c1022; }
    ::-webkit-scrollbar-thumb { background: #ad2bee; border-radius: 4px; }
    .tab-active { position: relative; }
    .tab-active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 3px; background: #ad2bee; }
    input[type="range"] { -webkit-appearance: none; background: #1c1022; border-radius: 4px; height: 8px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #ad2bee; border-radius: 50%; cursor: pointer; border: 2px solid #ffd700; }
    @keyframes pulse-snap { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .pulse-snap { animation: pulse-snap 0.5s ease-in-out infinite; }
    @keyframes typing { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
    .typing-dot { animation: typing 1.4s infinite; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    .chat-bubble { border-radius: 1rem; }
    .chat-bubble-user { border-bottom-right-radius: 0.25rem; }
    .chat-bubble-ai { border-bottom-left-radius: 0.25rem; }
    /* Drop Zone Styling */
    .drop-zone {
      border: 3px dashed rgba(173, 43, 238, 0.4);
      border-radius: 1rem;
      padding: 2rem;
      text-align: center;
      background: rgba(173, 43, 238, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .drop-zone:hover, .drop-zone.drag-over {
      border-color: #c75fff;
      background: rgba(173, 43, 238, 0.1);
      transform: scale(1.02);
    }
    .drop-zone .drop-icon { font-size: 3rem; display: block; margin-bottom: 1rem; }
    .drop-zone .file-path {
      display: block;
      margin-top: 0.5rem;
      font-size: 0.7rem;
      color: #c75fff;
      font-family: monospace;
      opacity: 0.7;
    }
    /* Modal Overlay */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 1rem;
    }
    .modal {
      background: #1c1022;
      border-radius: 1rem;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid rgba(173, 43, 238, 0.4);
      box-shadow: 0 0 30px rgba(173, 43, 238, 0.2);
    }
    /* Spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #1c1022;
      border-top-color: #ad2bee;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Install banner animation */
    @keyframes slide-up {
      from { transform: translateY(100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .install-banner-enter {
      animation: slide-up 0.3s ease-out;
    }
    /* QR Code Container */
    .qr-container { background: white; padding: 1rem; border-radius: 8px; display: inline-block; }

    /* Phase 5: Sync Section Styles */
    .pc-sync-section { margin: 0; }

    .sync-divider {
      display: flex;
      align-items: center;
      margin: 20px 0;
      color: #9CA3AF;
    }
    .sync-divider::before,
    .sync-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #444;
    }
    .sync-divider span {
      padding: 0 16px;
      font-size: 0.9em;
    }

    /* Linked Folder Styles */
    .linked-folder-section {
      background: rgba(173, 43, 238, 0.1);
      border: 2px solid rgba(173, 43, 238, 0.4);
      border-radius: 1rem;
      padding: 16px;
      margin-bottom: 12px;
    }
    .linked-folder-section h4 {
      margin: 0 0 8px 0;
      color: #c75fff;
      font-family: 'Spline Sans', 'Inter', sans-serif;
      font-weight: 700;
    }
    .linked-folder-section .description {
      margin: 0 0 12px 0;
      color: #aaa;
      font-size: 0.85em;
    }
    .link-folder-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 1em;
      background: #ad2bee;
      color: white;
      border: none;
      border-radius: 0.75rem;
      cursor: pointer;
      font-weight: bold;
    }
    .link-folder-btn:hover { background: #c75fff; }
    .linked-status {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .status-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: bold;
    }
    .status-badge.linked {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }
    .unlink-btn {
      background: none;
      border: none;
      color: #9CA3AF;
      cursor: pointer;
      font-size: 0.85em;
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
    }
    .unlink-btn:hover {
      color: #ef4444;
      text-decoration: underline;
    }
    .sync-btn {
      padding: 12px 20px;
      font-size: 1em;
      background: #ad2bee;
      color: white;
      border: none;
      border-radius: 0.75rem;
      cursor: pointer;
      font-weight: bold;
    }
    .sync-btn:hover { background: #c75fff; }
    .sync-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .last-sync {
      margin: 0;
      font-size: 0.8em;
      color: #9CA3AF;
      text-align: center;
    }
    .not-supported-msg {
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid #ffd700;
      border-radius: 8px;
      padding: 12px;
      font-size: 0.85em;
      color: #ccc;
    }

    /* Drag & Drop JSON Styles */
    .drag-drop-section h4 {
      margin: 0 0 4px 0;
      color: #aaa;
    }
    .drag-drop-section .description {
      margin: 0 0 12px 0;
      color: #9CA3AF;
      font-size: 0.8em;
    }
    .drop-zone-json {
      border: 3px dashed rgba(173, 43, 238, 0.4);
      border-radius: 1rem;
      padding: 30px 20px;
      text-align: center;
      background: rgba(173, 43, 238, 0.05);
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .drop-zone-json:hover,
    .drop-zone-json.drag-over {
      border-color: #ffd700;
      background: rgba(255, 215, 0, 0.1);
    }
    .drop-zone-json code {
      background: #120818;
      color: #ffd700;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75em;
      word-break: break-all;
      display: block;
      margin-top: 8px;
    }

    /* Card Performance Styles */
    .performance-card {
      display: flex;
      align-items: center;
      padding: 10px 14px;
      border-radius: 8px;
      margin: 4px 0;
      background: rgba(255, 255, 255, 0.05);
    }
    .performance-card.positive { border-left: 4px solid #22c55e; }
    .performance-card.negative { border-left: 4px solid #ef4444; }
    .performance-card .rank {
      width: 36px;
      font-weight: bold;
      color: #ffd700;
      font-size: 0.9em;
    }
    .performance-card .card-name {
      flex: 1;
      font-size: 0.95em;
    }
    .performance-card .net-cubes {
      font-weight: bold;
      font-size: 1em;
    }
    .performance-card.positive .net-cubes { color: #22c55e; }
    .performance-card.negative .net-cubes { color: #ef4444; }

    /* Sync Preview Modal */
    .sync-preview-modal {
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .preview-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 14px;
      margin: 10px 0;
    }
    .import-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    .import-toggle input {
      width: 18px;
      height: 18px;
      accent-color: #ad2bee;
    }
    .preview-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    .preview-stat {
      text-align: center;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
    }
    .preview-stat .value {
      display: block;
      font-size: 1.3em;
      font-weight: bold;
      color: white;
    }
    .preview-stat .label {
      font-size: 0.75em;
      color: #9CA3AF;
    }
    .card-performance-preview {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    .card-stat {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.85em;
    }
    .card-stat.positive { background: rgba(34, 197, 94, 0.15); }
    .card-stat.negative { background: rgba(239, 68, 68, 0.15); }
    .card-stat .cubes { font-weight: bold; }
    .card-stat.positive .cubes { color: #22c55e; }
    .card-stat.negative .cubes { color: #ef4444; }

    /* Performance Summary */
    .performance-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }
    .summary-stat {
      text-align: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
    }
    .summary-stat .label {
      display: block;
      font-size: 0.75em;
      color: #9CA3AF;
      margin-bottom: 4px;
    }
    .summary-stat .value {
      font-size: 1.3em;
      font-weight: bold;
    }
    .summary-stat.positive .value { color: #22c55e; }
    .summary-stat.negative .value { color: #ef4444; }
    .summary-stat.net .value { color: #ffd700; }

    /* Stats Section Styling */
    .stats-section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .stats-section h3 {
      margin: 0 0 12px 0;
      font-size: 1em;
      color: #ffd700;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .stat-card {
      background: linear-gradient(135deg, #1c1022 0%, #2d1f4e 50%, #1c1022 100%);
      border: 1px solid rgba(173, 43, 238, 0.15);
      border-radius: 0.75rem;
      padding: 12px;
      text-align: center;
    }
    .stat-card .stat-value {
      display: block;
      font-size: 1.5em;
      font-weight: bold;
      color: white;
    }
    .stat-card .stat-label {
      font-size: 0.75em;
      color: #9CA3AF;
    }
    .stat-card.highlight .stat-value { color: #ffd700; }
    .stat-card.positive .stat-value { color: #22c55e; }
    .stat-card.negative .stat-value { color: #ef4444; }
    .data-source {
      margin-top: 8px;
      font-size: 0.75em;
      color: #9CA3AF;
      text-align: right;
    }
    .import-prompt {
      text-align: center;
      padding: 20px;
      color: #9CA3AF;
    }
    .import-prompt a {
      color: #c75fff;
      text-decoration: underline;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: #2b1933;
      color: white;
      padding: 12px 20px;
      border-radius: 0.75rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3), 0 0 15px rgba(173, 43, 238, 0.2);
      border: 1px solid rgba(173, 43, 238, 0.3);
      z-index: 1000;
      white-space: pre-line;
      max-width: 90%;
      text-align: center;
    }

    /* Touch target utilities for accessibility */
    .touch-target {
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .touch-target-sm {
      min-width: 36px;
      min-height: 36px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    /* Expand clickable area while keeping visual size small */
    .touch-expand {
      position: relative;
    }
    .touch-expand::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 44px;
      height: 44px;
    }

    /* Low-end device optimizations */
    .low-end-mode *,
    .low-end-mode *::before,
    .low-end-mode *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }

    .low-end-mode .card-hover {
      transform: none !important;
    }

    .low-end-mode .halftone {
      background-image: none;
    }

    .low-end-mode .panel-border {
      box-shadow: none;
      border-width: 2px;
    }

    .low-end-mode .shadow-comic,
    .low-end-mode .shadow-glass {
      box-shadow: none;
    }

    .low-end-mode .pulse-snap {
      animation: none;
    }

    .low-end-mode .typing-dot {
      animation: none;
      opacity: 1;
    }

    .low-end-mode .spinner {
      animation: spin 2s linear infinite;
    }

    /* ==================== ACCESSIBILITY & PERFORMANCE ==================== */
    /* Respect user's reduced motion preference */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
      .pulse-snap {
        animation: none !important;
      }
      .typing-dot {
        animation: none !important;
        opacity: 1 !important;
      }
      .card-hover {
        transition: none !important;
      }
      .spinner {
        animation: spin 2s linear infinite;
      }
    }

    /* Low-power mode styles (applied via JS) */
    .low-power-mode *,
    .low-power-mode *::before,
    .low-power-mode *::after {
      animation-duration: 0ms !important;
      transition-duration: 0ms !important;
    }
    .low-power-mode .card-hover {
      transform: none !important;
    }
    .low-power-mode .halftone {
      background-image: none !important;
    }
    .low-power-mode .panel-border {
      box-shadow: none !important;
    }

    /* CSS Grid fallbacks for older browsers */
    .card-grid {
      display: flex;
      flex-wrap: wrap;
    }
    .card-grid > * {
      flex: 0 0 calc(33.333% - 8px);
      margin: 4px;
    }
    @supports (display: grid) {
      .card-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }
      .card-grid > * {
        flex: none;
        margin: 0;
      }
    }

    /* Swipe-to-delete styles */
    .swipe-item-container {
      position: relative;
      overflow: hidden;
    }
    .swipe-delete-bg {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background: #DC2626;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    .swipe-item {
      position: relative;
      background: #1c1022;
      transition: transform 0.2s ease-out;
    }

    /* CSS Gap Fallbacks for older Safari (pre-14.1) */
    .linked-status {
      gap: 12px;
    }
    @supports not (gap: 12px) {
      .linked-status > * + * {
        margin-top: 12px;
      }
    }
    /* Grid gap fallback - use grid-gap as older property */
    .grid {
      grid-gap: 0.5rem; /* fallback */
      gap: 0.5rem;
    }
    /* Flexbox gap fallback using margin for older browsers */
    @supports not (gap: 8px) {
      .flex > * + * {
        margin-left: 8px;
      }
      .flex-col > * + * {
        margin-left: 0;
        margin-top: 8px;
      }
    }
  </style>
</head>
<body>
  <!-- Skip Navigation Link for Accessibility -->
  <a href="#main-content" class="sr-only" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;" onfocus="this.style.cssText='position:fixed;left:16px;top:16px;z-index:9999;background:#ED1D24;color:white;padding:12px 24px;border-radius:8px;font-weight:bold;text-decoration:none;width:auto;height:auto;overflow:visible;';" onblur="this.style.cssText='position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;';">Skip to main content</a>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useRef } = React;

    // ==================== GESTURE HOOKS ====================
    // Pull-to-refresh hook
    const usePullToRefresh = (onRefresh, { threshold = 80 } = {}) => {
      const [pulling, setPulling] = useState(false);
      const [pullDistance, setPullDistance] = useState(0);
      const [refreshing, setRefreshing] = useState(false);
      const startY = useRef(0);
      const containerRef = useRef(null);

      const handleTouchStart = useCallback((e) => {
        if (containerRef.current && containerRef.current.scrollTop === 0) {
          startY.current = e.touches[0].clientY;
        }
      }, []);

      const handleTouchMove = useCallback((e) => {
        if (startY.current === 0) return;
        const currentY = e.touches[0].clientY;
        const distance = Math.max(0, Math.min(currentY - startY.current, 150));

        if (distance > 0) {
          setPullDistance(distance);
          setPulling(distance > threshold);
        }
      }, [threshold]);

      const handleTouchEnd = useCallback(async () => {
        if (pulling && !refreshing) {
          setRefreshing(true);
          try {
            await onRefresh();
          } finally {
            setRefreshing(false);
          }
        }
        setPullDistance(0);
        setPulling(false);
        startY.current = 0;
      }, [pulling, refreshing, onRefresh]);

      return {
        containerRef,
        pullDistance,
        pulling,
        refreshing,
        handlers: {
          onTouchStart: handleTouchStart,
          onTouchMove: handleTouchMove,
          onTouchEnd: handleTouchEnd
        }
      };
    };

    // Swipe-to-delete hook
    const useSwipeToDelete = (onDelete) => {
      const [translateX, setTranslateX] = useState(0);
      const [showDelete, setShowDelete] = useState(false);
      const startX = useRef(0);
      const swiping = useRef(false);

      const handleTouchStart = useCallback((e) => {
        startX.current = e.touches[0].clientX;
        swiping.current = true;
      }, []);

      const handleTouchMove = useCallback((e) => {
        if (!swiping.current) return;
        const diff = e.touches[0].clientX - startX.current;
        if (diff < 0 && diff > -100) {
          setTranslateX(diff);
        }
      }, []);

      const handleTouchEnd = useCallback(() => {
        swiping.current = false;
        if (translateX < -50) {
          setTranslateX(-80);
          setShowDelete(true);
        } else {
          setTranslateX(0);
          setShowDelete(false);
        }
      }, [translateX]);

      const resetSwipe = useCallback(() => {
        setTranslateX(0);
        setShowDelete(false);
      }, []);

      const handleDelete = useCallback(() => {
        onDelete();
        resetSwipe();
      }, [onDelete, resetSwipe]);

      return {
        translateX,
        showDelete,
        resetSwipe,
        handleDelete,
        handlers: {
          onTouchStart: handleTouchStart,
          onTouchMove: handleTouchMove,
          onTouchEnd: handleTouchEnd
        }
      };
    };

    // Pull-to-refresh visual indicator
    const PullToRefreshIndicator = ({ pullDistance, refreshing }) => {
      if (pullDistance === 0 && !refreshing) return null;

      const rotation = Math.min(pullDistance * 3, 360);
      const opacity = Math.min(pullDistance / 80, 1);

      return (
        <div
          className="flex justify-center py-2 transition-all"
          style={{
            height: refreshing ? 50 : Math.min(pullDistance, 80),
            opacity: refreshing ? 1 : opacity
          }}
        >
          <div
            className={`w-8 h-8 border-4 border-mcu-blue border-t-transparent rounded-full ${refreshing ? 'animate-spin' : ''}`}
            style={{ transform: refreshing ? 'none' : `rotate(${rotation}deg)` }}
          />
        </div>
      );
    };

    // ==================== BROWSER COMPATIBILITY HELPERS ====================
    // Safe property access for browsers without optional chaining (Safari iOS < 13.4, Firefox < 72)
    const safeGet = (obj, path, defaultValue) => {
      if (obj == null) return defaultValue;
      const keys = path.split('.');
      let result = obj;
      for (const key of keys) {
        // Handle array index access like "candidates.0.content"
        if (result == null) return defaultValue;
        result = result[key];
      }
      return result !== undefined ? result : defaultValue;
    };

    // Check if Google OAuth is available
    const isGoogleOAuthAvailable = () => {
      return !!(window.google && window.google.accounts && window.google.accounts.oauth2);
    };

    // ==================== CONSTANTS ====================
    const GOOGLE_CLIENT_ID = '770573636629-tddodsck0vtmtqpdh7uj7dtevr07orn2.apps.googleusercontent.com';
    const GEMINI_SCOPES = 'https://www.googleapis.com/auth/generative-language.retriever';

    // ==================== GOOGLE OAUTH 2.0 HELPERS ====================
    let googleTokenClient = null;
    let pendingTokenResolve = null;
    let pendingTokenReject = null;

    // Initialize Google OAuth 2.0 Token Client
    const initGoogleOAuth = (callback) => {
      if (!isGoogleOAuthAvailable()) {
        console.log('Google OAuth2 library not loaded yet');
        return false;
      }

      googleTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GOOGLE_CLIENT_ID,
        scope: GEMINI_SCOPES,
        callback: (response) => {
          if (response.error) {
            console.error('Google OAuth error:', response.error);
            if (pendingTokenReject) {
              pendingTokenReject(new Error(response.error));
              pendingTokenReject = null;
              pendingTokenResolve = null;
            }
            return;
          }

          const expiresAt = Date.now() + (response.expires_in * 1000);
          localStorage.setItem('snap_google_access_token', response.access_token);
          localStorage.setItem('snap_google_token_expiry', expiresAt.toString());

          if (pendingTokenResolve) {
            pendingTokenResolve(response.access_token);
            pendingTokenResolve = null;
            pendingTokenReject = null;
          }

          if (callback) callback(response.access_token);
        },
        error_callback: (error) => {
          console.error('Google token error:', error);
          if (error.type !== 'popup_closed' && pendingTokenReject) {
            pendingTokenReject(new Error(error.message || error.type || 'Unknown error'));
            pendingTokenReject = null;
            pendingTokenResolve = null;
          }
        }
      });

      return true;
    };

    // Check if Google access token is valid
    const isGoogleTokenValid = () => {
      const token = localStorage.getItem('snap_google_access_token');
      const expiry = localStorage.getItem('snap_google_token_expiry');
      if (!token || !expiry) return false;
      return Date.now() < (parseInt(expiry) - 300000); // 5 min buffer
    };

    // Get Google access token (with auto-refresh)
    const getGoogleAccessToken = async () => {
      if (isGoogleTokenValid()) {
        return localStorage.getItem('snap_google_access_token');
      }

      // Need to get a new token
      return new Promise((resolve, reject) => {
        if (!googleTokenClient) {
          if (!initGoogleOAuth()) {
            reject(new Error('Google OAuth not initialized'));
            return;
          }
        }

        pendingTokenResolve = resolve;
        pendingTokenReject = reject;

        // Request new token - may show popup if consent needed
        googleTokenClient.requestAccessToken({ prompt: '' });
      });
    };

    // Request new Google access token (shows popup)
    const requestGoogleAccessToken = () => {
      return new Promise((resolve, reject) => {
        if (!googleTokenClient) {
          if (!initGoogleOAuth()) {
            reject(new Error('Google OAuth not initialized. Please refresh the page.'));
            return;
          }
        }

        pendingTokenResolve = resolve;
        pendingTokenReject = reject;

        googleTokenClient.requestAccessToken({ prompt: 'consent' });
      });
    };

    // Sign out from Google
    const signOutGoogle = () => {
      const token = localStorage.getItem('snap_google_access_token');
      if (token && isGoogleOAuthAvailable()) {
        google.accounts.oauth2.revoke(token, () => {
          console.log('Google token revoked');
        });
      }
      localStorage.removeItem('snap_google_access_token');
      localStorage.removeItem('snap_google_token_expiry');
    };

    // ==================== CARD ART URL HELPER ====================
    // Generate card art URL from card name or defId
    const CARD_ART_CDN = 'https://marvelsnapzone.com/wp-content/themes/blocksy-child/assets/media/cards/';
    const getCardArtUrl = (card) => {
      if (card.art) return card.art;
      // Build slug from defId or name: "Iron Man" -> "iron-man", "AmericaChavez" -> "america-chavez"
      const slug = (card.defId || card.name)
        .replace(/([a-z])([A-Z])/g, '$1-$2')  // camelCase -> camel-Case
        .replace(/\s+/g, '-')                   // spaces -> hyphens
        .replace(/[^a-zA-Z0-9-]/g, '')          // remove special chars
        .toLowerCase();
      return `${CARD_ART_CDN}${slug}.webp?v=787`;
    };

    // ==================== CARD DATA ====================
    // Series 1 fallback data for offline-first functionality (with art URLs)
    const CARD_DATA_FALLBACK = [
      { name: "Abomination", cost: 5, power: 9, series: 1, ability: "No ability.", art: `${CARD_ART_CDN}abomination.webp?v=787` },
      { name: "Ant-Man", cost: 1, power: 1, series: 1, ability: "Ongoing: If your side of this location is full, +3 Power.", art: `${CARD_ART_CDN}ant-man.webp?v=787` },
      { name: "America Chavez", cost: 6, power: 9, series: 1, ability: "On Reveal: This always starts in your deck, and is drawn on turn 6.", art: `${CARD_ART_CDN}america-chavez.webp?v=787` },
      { name: "Angela", cost: 2, power: 0, series: 1, ability: "When you play a card here, +2 Power.", art: `${CARD_ART_CDN}angela.webp?v=787` },
      { name: "Armor", cost: 2, power: 3, series: 1, ability: "Ongoing: Cards at this location can't be destroyed.", art: `${CARD_ART_CDN}armor.webp?v=787` },
      { name: "Bishop", cost: 3, power: 1, series: 1, ability: "When you play a card, +1 Power.", art: `${CARD_ART_CDN}bishop.webp?v=787` },
      { name: "Blue Marvel", cost: 5, power: 3, series: 1, ability: "Ongoing: Your other cards have +1 Power.", art: `${CARD_ART_CDN}blue-marvel.webp?v=787` },
      { name: "Cable", cost: 2, power: 2, series: 1, ability: "On Reveal: Draw a card from your opponent's deck.", art: `${CARD_ART_CDN}cable.webp?v=787` },
      { name: "Captain America", cost: 3, power: 3, series: 1, ability: "Ongoing: Your other cards at this location have +1 Power.", art: `${CARD_ART_CDN}captain-america.webp?v=787` },
      { name: "Carnage", cost: 2, power: 2, series: 1, ability: "On Reveal: Destroy your other cards here. +2 Power for each destroyed.", art: `${CARD_ART_CDN}carnage.webp?v=787` },
      { name: "Colossus", cost: 2, power: 3, series: 1, ability: "Ongoing: Can't be destroyed, moved, or have its Power reduced.", art: `${CARD_ART_CDN}colossus.webp?v=787` },
      { name: "Cosmo", cost: 3, power: 3, series: 1, ability: "Ongoing: On Reveal abilities won't happen at this location.", art: `${CARD_ART_CDN}cosmo.webp?v=787` },
      { name: "Cyclops", cost: 3, power: 4, series: 1, ability: "No ability.", art: `${CARD_ART_CDN}cyclops.webp?v=787` },
      { name: "Deathlok", cost: 3, power: 5, series: 1, ability: "On Reveal: Destroy your other cards at this location.", art: `${CARD_ART_CDN}deathlok.webp?v=787` },
      { name: "Elektra", cost: 1, power: 2, series: 1, ability: "On Reveal: Destroy a random enemy 1-Cost card at this location.", art: `${CARD_ART_CDN}elektra.webp?v=787` },
      { name: "Enchantress", cost: 4, power: 5, series: 1, ability: "On Reveal: Remove the abilities from all Ongoing cards at this location.", art: `${CARD_ART_CDN}enchantress.webp?v=787` },
      { name: "Forge", cost: 2, power: 1, series: 1, ability: "On Reveal: Give the next card you play +2 Power.", art: `${CARD_ART_CDN}forge.webp?v=787` },
      { name: "Gamora", cost: 5, power: 7, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +5 Power.", art: `${CARD_ART_CDN}gamora.webp?v=787` },
      { name: "Groot", cost: 3, power: 3, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power.", art: `${CARD_ART_CDN}groot.webp?v=787` },
      { name: "Hawkeye", cost: 1, power: 1, series: 1, ability: "On Reveal: If you play a card here next turn, +3 Power.", art: `${CARD_ART_CDN}hawkeye.webp?v=787` },
      { name: "Hulk", cost: 6, power: 12, series: 1, ability: "No ability.", art: `${CARD_ART_CDN}hulk.webp?v=787` },
      { name: "Human Torch", cost: 1, power: 2, series: 1, ability: "When this moves to a location, double its Power.", art: `${CARD_ART_CDN}human-torch.webp?v=787` },
      { name: "Iron Fist", cost: 1, power: 2, series: 1, ability: "On Reveal: After you play your next card, move it one location to the left.", art: `${CARD_ART_CDN}iron-fist.webp?v=787` },
      { name: "Iron Man", cost: 5, power: 0, series: 1, ability: "Ongoing: Your total Power is doubled at this location.", art: `${CARD_ART_CDN}iron-man.webp?v=787` },
      { name: "Jessica Jones", cost: 4, power: 4, series: 1, ability: "On Reveal: If you don't play a card here next turn, +4 Power.", art: `${CARD_ART_CDN}jessica-jones.webp?v=787` },
      { name: "Klaw", cost: 5, power: 4, series: 1, ability: "Ongoing: The location to the right has +6 Power.", art: `${CARD_ART_CDN}klaw.webp?v=787` },
      { name: "Korg", cost: 1, power: 1, series: 1, ability: "On Reveal: Shuffle a Rock into your opponent's deck.", art: `${CARD_ART_CDN}korg.webp?v=787` },
      { name: "Lady Sif", cost: 3, power: 4, series: 1, ability: "On Reveal: Discard the highest-cost card from your hand.", art: `${CARD_ART_CDN}lady-sif.webp?v=787` },
      { name: "Lizard", cost: 2, power: 5, series: 1, ability: "Ongoing: -3 Power if your opponent has 4 cards here.", art: `${CARD_ART_CDN}lizard.webp?v=787` },
      { name: "Mantis", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, draw a card from their deck.", art: `${CARD_ART_CDN}mantis.webp?v=787` },
      { name: "Medusa", cost: 2, power: 2, series: 1, ability: "On Reveal: If this is at the middle location, +3 Power.", art: `${CARD_ART_CDN}medusa.webp?v=787` },
      { name: "Mister Fantastic", cost: 3, power: 2, series: 1, ability: "Ongoing: Adjacent locations have +2 Power.", art: `${CARD_ART_CDN}mister-fantastic.webp?v=787` },
      { name: "Mister Sinister", cost: 2, power: 2, series: 1, ability: "On Reveal: Add a Sinister Clone to this location with the same Power.", art: `${CARD_ART_CDN}mister-sinister.webp?v=787` },
      { name: "Moon Girl", cost: 4, power: 4, series: 1, ability: "On Reveal: Duplicate your hand.", art: `${CARD_ART_CDN}moon-girl.webp?v=787` },
      { name: "Morph", cost: 3, power: 0, series: 1, ability: "On Reveal: Become a copy of a random card in your opponent's hand.", art: `${CARD_ART_CDN}morph.webp?v=787` },
      { name: "Multiple Man", cost: 2, power: 3, series: 1, ability: "When this moves, add a copy to the old location.", art: `${CARD_ART_CDN}multiple-man.webp?v=787` },
      { name: "Namor", cost: 4, power: 5, series: 1, ability: "Ongoing: +5 Power if this is your only card here.", art: `${CARD_ART_CDN}namor.webp?v=787` },
      { name: "Nightcrawler", cost: 1, power: 2, series: 1, ability: "You can move this once.", art: `${CARD_ART_CDN}nightcrawler.webp?v=787` },
      { name: "Nova", cost: 1, power: 1, series: 1, ability: "When this is destroyed, give your cards +1 Power.", art: `${CARD_ART_CDN}nova.webp?v=787` },
      { name: "Odin", cost: 6, power: 8, series: 1, ability: "On Reveal: Activate the On Reveal abilities of your other cards at this location.", art: `${CARD_ART_CDN}odin.webp?v=787` },
      { name: "Onslaught", cost: 6, power: 7, series: 1, ability: "Ongoing: Double your other Ongoing effects at this location.", art: `${CARD_ART_CDN}onslaught.webp?v=787` },
      { name: "Punisher", cost: 3, power: 2, series: 1, ability: "Ongoing: +1 Power for each enemy card at this location.", art: `${CARD_ART_CDN}punisher.webp?v=787` },
      { name: "Rocket Raccoon", cost: 1, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +2 Power.", art: `${CARD_ART_CDN}rocket-raccoon.webp?v=787` },
      { name: "Scarlet Witch", cost: 2, power: 3, series: 1, ability: "On Reveal: Replace this location with a random location.", art: `${CARD_ART_CDN}scarlet-witch.webp?v=787` },
      { name: "Sentinel", cost: 2, power: 3, series: 1, ability: "On Reveal: Add another Sentinel to your hand.", art: `${CARD_ART_CDN}sentinel.webp?v=787` },
      { name: "Spectrum", cost: 6, power: 5, series: 1, ability: "On Reveal: Give your Ongoing cards +2 Power.", art: `${CARD_ART_CDN}spectrum.webp?v=787` },
      { name: "Spider-Woman", cost: 5, power: 7, series: 1, ability: "On Reveal: Afflict all enemy cards here with -1 Power.", art: `${CARD_ART_CDN}spider-woman.webp?v=787` },
      { name: "Squirrel Girl", cost: 1, power: 1, series: 1, ability: "On Reveal: Add a 1-Power Squirrel to each other location.", art: `${CARD_ART_CDN}squirrel-girl.webp?v=787` },
      { name: "Star-Lord", cost: 2, power: 2, series: 1, ability: "On Reveal: If your opponent played a card here this turn, +3 Power.", art: `${CARD_ART_CDN}star-lord.webp?v=787` },
      { name: "Strong Guy", cost: 4, power: 4, series: 1, ability: "Ongoing: If your hand is empty, +6 Power.", art: `${CARD_ART_CDN}strong-guy.webp?v=787` },
      { name: "Sword Master", cost: 3, power: 6, series: 1, ability: "On Reveal: Discard a card from your hand.", art: `${CARD_ART_CDN}sword-master.webp?v=787` },
      { name: "The Thing", cost: 4, power: 6, series: 1, ability: "No ability.", art: `${CARD_ART_CDN}the-thing.webp?v=787` },
      { name: "White Queen", cost: 4, power: 6, series: 1, ability: "On Reveal: Draw a copy of the highest-Cost card in your opponent's hand.", art: `${CARD_ART_CDN}white-queen.webp?v=787` },
      { name: "White Tiger", cost: 5, power: 1, series: 1, ability: "On Reveal: Add a 7-Power Tiger to another location.", art: `${CARD_ART_CDN}white-tiger.webp?v=787` },
      { name: "Wolfsbane", cost: 3, power: 1, series: 1, ability: "On Reveal: +2 Power for each other card you have here.", art: `${CARD_ART_CDN}wolfsbane.webp?v=787` },
      { name: "Wolverine", cost: 2, power: 2, series: 1, ability: "When this is discarded or destroyed, regenerate it at a random location.", art: `${CARD_ART_CDN}wolverine.webp?v=787` },
      { name: "Yondu", cost: 1, power: 2, series: 1, ability: "On Reveal: Remove the top card of your opponent's deck.", art: `${CARD_ART_CDN}yondu.webp?v=787` }
    ];

    // Card data is loaded from external file for better caching
    let CARD_DATA = [...CARD_DATA_FALLBACK];
    let cardDataLoaded = false;

    // Card Data Loader - fetches full card data from JSON file
    const CardDataLoader = {
      cache: null,
      loading: false,
      loadPromise: null,

      async load() {
        // Return cached data if available
        if (this.cache) return this.cache;

        // If already loading, wait for existing promise
        if (this.loading && this.loadPromise) {
          return this.loadPromise;
        }

        this.loading = true;
        this.loadPromise = this._fetchData();

        try {
          const result = await this.loadPromise;
          return result;
        } finally {
          this.loading = false;
        }
      },

      async _fetchData() {
        try {
          // Try to load from external JSON file (service worker will cache this)
          const response = await fetch('./card-data.json');
          if (response.ok) {
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0) {
              // Enrich cards with art URLs if missing
              const enriched = data.map(card => card.art ? card : { ...card, art: getCardArtUrl(card) });
              this.cache = enriched;
              CARD_DATA = enriched;
              cardDataLoaded = true;
              console.log(`[CardDataLoader] Loaded ${enriched.length} cards from card-data.json`);
              return enriched;
            }
          }
        } catch (error) {
          console.warn('[CardDataLoader] Failed to load card-data.json:', error);
        }

        // Fallback to embedded Series 1 data
        console.log('[CardDataLoader] Using fallback Series 1 data');
        this.cache = CARD_DATA_FALLBACK;
        CARD_DATA = CARD_DATA_FALLBACK;
        cardDataLoaded = true;
        return CARD_DATA_FALLBACK;
      },

      // Get cards synchronously (returns current data, may be fallback)
      getCards() {
        return CARD_DATA;
      },

      // Check if full data is loaded
      isLoaded() {
        return cardDataLoaded && CARD_DATA.length > CARD_DATA_FALLBACK.length;
      }
    };

    // Start loading card data immediately
    CardDataLoader.load().catch(err => console.warn('[CardDataLoader] Initial load error:', err));

    // ==================== LOW-END DEVICE DETECTION ====================
    // Low-end device detection for performance optimization
    const isLowEndDevice = () => {
      // Check device memory (if available)
      if (navigator.deviceMemory && navigator.deviceMemory < 4) {
        return true;
      }

      // Check hardware concurrency (CPU cores)
      if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) {
        return true;
      }

      // Check connection type
      if (navigator.connection) {
        const { effectiveType, saveData } = navigator.connection;
        if (saveData || effectiveType === '2g' || effectiveType === 'slow-2g') {
          return true;
        }
      }

      return false;
    };

    // Check for user preference override in localStorage
    const getPerformanceModePreference = () => {
      const stored = localStorage.getItem('snap_performance_mode');
      if (stored === 'low') return true;
      if (stored === 'high') return false;
      return null; // Auto-detect
    };

    // Apply low-end mode class if needed
    const applyPerformanceMode = () => {
      const preference = getPerformanceModePreference();
      const shouldUseLowEnd = preference !== null ? preference : isLowEndDevice();

      if (shouldUseLowEnd) {
        document.body.classList.add('low-end-mode');
      } else {
        document.body.classList.remove('low-end-mode');
      }
      return shouldUseLowEnd;
    };

    // Initial application
    applyPerformanceMode();

    // Battery-aware optimizations
    if ('getBattery' in navigator) {
      navigator.getBattery().then(battery => {
        const checkBattery = () => {
          // Only auto-switch if user hasn't set a preference
          if (getPerformanceModePreference() !== null) return;

          if (battery.level < 0.2 && !battery.charging) {
            document.body.classList.add('low-end-mode');
          } else if (battery.level > 0.3 || battery.charging) {
            // Only remove if not inherently low-end
            if (!isLowEndDevice()) {
              document.body.classList.remove('low-end-mode');
            }
          }
        };

        checkBattery();
        battery.addEventListener('levelchange', checkBattery);
        battery.addEventListener('chargingchange', checkBattery);
      }).catch(() => {
        // Battery API not supported or permission denied
      });
    }

    // Connection-aware optimizations
    if (navigator.connection) {
      const updateConnectionMode = () => {
        // Only auto-switch if user hasn't set a preference
        if (getPerformanceModePreference() !== null) return;

        const { effectiveType, saveData } = navigator.connection;
        if (saveData || effectiveType === '2g' || effectiveType === 'slow-2g') {
          document.body.classList.add('low-end-mode');
        } else if (!isLowEndDevice()) {
          document.body.classList.remove('low-end-mode');
        }
      };

      navigator.connection.addEventListener('change', updateConnectionMode);
    }

    // Merge embedded cards with any cached cards from API
    const getCachedCards = () => {
      try {
        const cached = localStorage.getItem('snap_card_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          // Use cache if less than 7 days old
          if (Date.now() - timestamp < 7 * 24 * 60 * 60 * 1000 && data && data.length > 0) {
            return data;
          }
        }
      } catch (e) { console.log('Cache read error:', e); }
      return [];
    };

    // uniqueCards - mutable array that updates when card data loads
    let uniqueCards = [...CARD_DATA_FALLBACK];
    let uniqueCardsUpdateCallbacks = [];

    // Function to update uniqueCards and notify listeners
    const updateUniqueCards = (newCards) => {
      // Dedupe by name
      uniqueCards = newCards.reduce((acc, card) => {
        if (!acc.find(c => c.name === card.name)) acc.push(card);
        return acc;
      }, []);
      // Notify all listeners
      uniqueCardsUpdateCallbacks.forEach(cb => cb(uniqueCards));
      console.log(`[uniqueCards] Updated with ${uniqueCards.length} cards`);
    };

    // Subscribe to uniqueCards updates
    const onUniqueCardsUpdate = (callback) => {
      uniqueCardsUpdateCallbacks.push(callback);
      return () => {
        uniqueCardsUpdateCallbacks = uniqueCardsUpdateCallbacks.filter(cb => cb !== callback);
      };
    };

    // Initialize uniqueCards with best available data
    (() => {
      const cachedCards = getCachedCards();
      const baseCards = cachedCards.length > CARD_DATA.length ? cachedCards : CARD_DATA;
      updateUniqueCards(baseCards);
    })();

    // Update uniqueCards when CardDataLoader finishes
    CardDataLoader.load().then(cards => {
      if (cards && cards.length > uniqueCards.length) {
        updateUniqueCards(cards);
      }
    }).catch(err => console.warn('[uniqueCards] Load error:', err));

    // ==================== DYNAMIC META CONTEXT ====================
    // Phase 3: Centralized meta information - update this with each patch/season
    const META_CONTEXT = {
      currentDate: new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' }),
      season: "Dragons Season",
      lastUpdated: "January 2026",
      recentOTA: [
        "Merlin: 3/5  3/4 (nerfed)",
        "Fantomex: 4/4  4/5 (buffed)",
        "Vulture: 3/3  3/4 (buffed)",
        "Iron Lad: 4/6  4/7 (buffed)",
        "Shou-Lao: New card enabling dragon combos"
      ],
      topArchetypes: [
        { name: "Shou-Lao Combo", tier: "S", description: "Dragon synergy with Shou-Lao and Draconic cards" },
        { name: "Destroy", tier: "S", description: "Knull/Death/Deadpool core with Killmonger tech" },
        { name: "High Evo", tier: "A", description: "High Evolutionary with no-ability cards" },
        { name: "Bounce", tier: "A", description: "Beast/Falcon with Hitmonkey/Angela payoffs" },
        { name: "Discard", tier: "A", description: "Apocalypse/MODOK/Hela control" },
        { name: "Move", tier: "B+", description: "Dagger/Human Torch with Heimdall finisher" }
      ],
      hotCards: ["Shou-Lao", "Knull", "Death", "High Evolutionary", "Hela", "Hit-Monkey", "Angela"],
      techCards: ["Killmonger", "Enchantress", "Shadow King", "Rogue", "Shang-Chi", "Cosmo"]
    };

    // ==================== SNAPAPOULOUS PERSONA ====================
    // Phase 4: Default fallback persona (used if persona.json fails to load)
    const DEFAULT_PERSONA = {
      name: "Snapapoulous",
      role: "Marvel Snap Tactical Advisor",
      personality: {
        tone: "Confident, knowledgeable, encouraging",
        style: "Direct tactical guidance with clear reasoning",
        voice: "Like a seasoned hero mentoring a new Avenger",
        quirks: [
          "References Marvel lore when relevant to strategy",
          "Uses card game terminology naturally",
          "Celebrates good plays with enthusiasm",
          "Constructively critiques mistakes without being harsh"
        ]
      },
      expertise: [
        "Deck building and optimization",
        "Meta analysis and counter-strategies",
        "Probability and statistics (hypergeometric draw calculations)",
        "Snap/retreat decision making",
        "Card synergies and combos",
        "Location priority mathematics",
        "OTA balance impact analysis"
      ],
      principles: [
        "The 8-Cube Mandate: Play for high-value wins when the odds favor you",
        "Retreat is not defeat: Preserving cubes is a winning strategy",
        "Adapt or fall: The meta shifts constantly, flexibility is power",
        "Know your outs: Always calculate the probability before snapping"
      ],
      knowledgeBase: {
        archetypes: ["Destroy", "Discard", "High Evolutionary", "Move", "Bounce", "Cerebro", "Shou-Lao Combo", "Zoo/Swarm", "Control", "Ongoing", "On Reveal"],
        keyConcepts: ["Cube equity", "Win condition identification", "Tech card flexibility", "Lane management", "Turn 6 power calculations"]
      },
      sampleResponses: {
        greeting: "Ready to climb the ranks? Let's review your arsenal and find your path to Infinite.",
        deckApproved: "This deck has solid synergy. You've got the tools - now trust your reads and snap with confidence.",
        retreatAdvice: "Sometimes the smartest play is knowing when to fold. Live to fight another match.",
        snapEncouragement: "The odds are in your favor. This is your moment - SNAP!"
      }
    };

    // Phase 4: Cached persona from persona.json (loaded async)
    let loadedPersona = null;
    let personaLoadAttempted = false;

    // Load persona.json asynchronously (enabled by default)
    const loadPersonaFromFile = async () => {
      if (personaLoadAttempted) return loadedPersona || DEFAULT_PERSONA;
      personaLoadAttempted = true;

      try {
        const response = await fetch('persona.json');
        if (response.ok) {
          const data = await response.json();
          loadedPersona = data.persona || data;
          console.log('Loaded persona from persona.json');
          return loadedPersona;
        }
      } catch (e) {
        console.log('Using default persona (persona.json not available):', e.message);
      }
      return DEFAULT_PERSONA;
    };

    // Get active persona (supports toggle via settings)
    const getActivePersona = () => {
      const settings = JSON.parse(localStorage.getItem('snap_settings') || '{}');
      // Phase 4: Enhanced persona ON by default, toggle to turn OFF
      if (settings.useSimplePersona) {
        return DEFAULT_PERSONA;
      }
      return loadedPersona || DEFAULT_PERSONA;
    };

    // Initialize persona loading on startup
    loadPersonaFromFile();

    // ==================== CONTEXT ANALYSIS HELPERS ====================
    // Phase 2: Rich context injection helpers

    const analyzeRecentMatches = (matches, recentCount = 10) => {
      if (!matches || matches.length === 0) {
        return {
          hasData: false,
          summary: "No match history recorded yet"
        };
      }

      const sortedMatches = [...matches].sort((a, b) =>
        new Date(b.timestamp) - new Date(a.timestamp)
      );

      const recentMatches = sortedMatches.slice(0, recentCount);
      const allTimeStats = calculateStats(matches);
      const recentStats = calculateStats(recentMatches);

      // Analyze trends
      const trend = recentStats.winRate > allTimeStats.winRate ? 'improving' :
                    recentStats.winRate < allTimeStats.winRate ? 'declining' : 'stable';

      // Analyze decks played (if tracked)
      const deckStats = analyzeDeckPerformance(matches);

      // Calculate streak
      let streak = 0;
      let streakType = null;
      for (const match of sortedMatches) {
        if (streakType === null) {
          streakType = match.result;
          streak = 1;
        } else if (match.result === streakType) {
          streak++;
        } else {
          break;
        }
      }

      return {
        hasData: true,
        allTime: allTimeStats,
        recent: recentStats,
        trend,
        streak: { count: streak, type: streakType },
        deckStats,
        recentMatchCount: recentMatches.length
      };
    };

    const calculateStats = (matches) => {
      if (matches.length === 0) return { games: 0, wins: 0, winRate: 0, netCubes: 0, avgCubes: 0 };

      const wins = matches.filter(m => m.result === 'WIN').length;
      const netCubes = matches.reduce((sum, m) =>
        sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0
      );

      return {
        games: matches.length,
        wins,
        winRate: Math.round((wins / matches.length) * 100),
        netCubes,
        avgCubes: (netCubes / matches.length).toFixed(2)
      };
    };

    const analyzeDeckPerformance = (matches) => {
      const deckMatches = matches.filter(m => m.deck && m.deck.trim());
      if (deckMatches.length === 0) return null;

      const deckData = {};
      for (const match of deckMatches) {
        const deck = match.deck.trim();
        if (!deckData[deck]) {
          deckData[deck] = { games: 0, wins: 0, cubes: 0 };
        }
        deckData[deck].games++;
        if (match.result === 'WIN') deckData[deck].wins++;
        deckData[deck].cubes += match.result === 'WIN' ? match.cubes : -match.cubes;
      }

      return Object.entries(deckData)
        .map(([name, stats]) => ({
          name,
          ...stats,
          winRate: Math.round((stats.wins / stats.games) * 100)
        }))
        .sort((a, b) => b.games - a.games)
        .slice(0, 5); // Top 5 most played decks
    };

    const analyzeCollectionGaps = (collection, allCards) => {
      const owned = new Set(collection.owned || []);
      const missing = allCards.filter(c => !owned.has(c.name));
      // Only count owned cards that actually exist in the database (fixes >100% bug)
      const allCardNames = new Set(allCards.map(c => c.name));
      const ownedInDatabase = [...owned].filter(name => allCardNames.has(name)).length;

      // Group missing by series
      const missingBySeries = {};
      for (const card of missing) {
        const series = card.series || 'Unknown';
        if (!missingBySeries[series]) missingBySeries[series] = [];
        missingBySeries[series].push(card.name);
      }

      // Identify key missing cards from current meta
      const metaCards = [...META_CONTEXT.hotCards, ...META_CONTEXT.techCards];
      const missingMetaCards = metaCards.filter(name => !owned.has(name));

      // Identify archetypes user can/cannot play
      const archetypeCards = {
        'Destroy': ['Knull', 'Death', 'Deadpool', 'Carnage', 'Venom', 'Deathlok'],
        'Discard': ['Hela', 'Apocalypse', 'MODOK', 'Blade', 'Moon Knight', 'Morbius'],
        'Bounce': ['Beast', 'Falcon', 'Hit-Monkey', 'Angela', 'Kitty Pryde'],
        'High Evo': ['High Evolutionary', 'Wasp', 'Misty Knight', 'Cyclops', 'Thing', 'Hulk'],
        'Move': ['Dagger', 'Human Torch', 'Heimdall', 'Doctor Strange', 'Iron Fist', 'Cloak']
      };

      const archetypeAccess = {};
      for (const [archetype, cards] of Object.entries(archetypeCards)) {
        const ownedCount = cards.filter(c => owned.has(c)).length;
        archetypeAccess[archetype] = {
          owned: ownedCount,
          total: cards.length,
          percent: Math.round((ownedCount / cards.length) * 100),
          missing: cards.filter(c => !owned.has(c))
        };
      }

      return {
        totalOwned: ownedInDatabase,
        totalCards: allCards.length,
        completionPercent: Math.round((ownedInDatabase / allCards.length) * 100),
        missingBySeries,
        missingMetaCards,
        archetypeAccess,
        // Include count of cards owned but not in database (for debugging)
        unrecognizedCards: owned.size - ownedInDatabase
      };
    };

    // ==================== AI PROVIDER MANAGER ====================
    const AIProviders = {
      'gemini-oauth': {
        id: 'gemini-oauth',
        name: 'Google (Gemini)',
        description: 'Sign in with Google - easiest option',
        authType: 'oauth',
        models: ['gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3-flash-preview', 'gemini-3-pro-preview', 'gemini-2.5-flash-lite'],
        defaultModel: 'gemini-2.5-flash',
        primary: true
      },
      'gemini': {
        id: 'gemini',
        name: 'Gemini (API Key)',
        description: 'Use your own Gemini API key',
        authType: 'api_key',
        models: ['gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3-flash-preview', 'gemini-3-pro-preview', 'gemini-2.5-flash-lite'],
        defaultModel: 'gemini-2.5-flash'
      },
      'groq': {
        id: 'groq',
        name: 'Groq',
        description: 'Fast inference, free tier available',
        authType: 'api_key',
        models: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
        defaultModel: 'llama-3.3-70b-versatile'
      },
      'claude': {
        id: 'claude',
        name: 'Claude (Anthropic)',
        description: 'Premium AI assistant',
        authType: 'api_key',
        models: ['claude-sonnet-4-20250514', 'claude-haiku-4-5-20251001'],
        defaultModel: 'claude-sonnet-4-20250514'
      },
      'openai': {
        id: 'openai',
        name: 'OpenAI (GPT)',
        description: 'ChatGPT models',
        authType: 'api_key',
        models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo'],
        defaultModel: 'gpt-4o-mini'
      },
      'local': {
        id: 'local',
        name: 'Local Models',
        description: 'Ollama, LM Studio, vLLM, or any OpenAI-compatible endpoint',
        authType: 'none',
        models: [],
        defaultModel: '',
        advanced: true
      }
    };

    // Build economy context for AI advisor (boosters, wallet, pity status)
    const buildEconomyContext = () => {
      const sections = [];

      // Load economy data from localStorage
      const wallet = loadFromStorage('snap_wallet', null);
      const rewards = loadFromStorage('snap_rewards', null);
      const enhancedCollection = loadFromStorage('snap_collection_enhanced', null);

      // Wallet info (credits, gold, tokens, keys)
      if (wallet) {
        const walletParts = [];
        if (wallet.credits !== undefined) walletParts.push(`${wallet.credits.toLocaleString()} credits`);
        if (wallet.gold !== undefined) walletParts.push(`${wallet.gold.toLocaleString()} gold`);
        if (wallet.tokens !== undefined) walletParts.push(`${wallet.tokens.toLocaleString()} tokens`);
        if (wallet.keys !== undefined) walletParts.push(`${wallet.keys} keys`);
        if (walletParts.length > 0) {
          sections.push(`Currency: ${walletParts.join(', ')}`);
        }
      }

      // Pity counter status
      if (rewards && rewards.pityCounters) {
        const pity = rewards.pityCounters;
        const s4Pity = pity.s4 || 0;
        const s5Pity = pity.s5 || 0;
        const s4ToGuarantee = 20 - s4Pity;
        const s5ToGuarantee = 60 - s5Pity;

        let pityText = `Pity Progress: S4=${s4Pity}/20 (${s4ToGuarantee} caches to guarantee), S5=${s5Pity}/60 (${s5ToGuarantee} caches to guarantee)`;

        // Add urgency hints
        if (s4Pity >= 15) pityText += ' [S4 CLOSE - consider saving for pity]';
        if (s5Pity >= 50) pityText += ' [S5 CLOSE - consider saving for pity]';

        sections.push(pityText);
      }

      // Booster reminders - find cards with high boosters ready for upgrades
      if (enhancedCollection && enhancedCollection.cards) {
        const upgradeReady = enhancedCollection.cards
          .filter(card => card.boosters >= 150 && card.splitLevel < 4)
          .sort((a, b) => b.boosters - a.boosters)
          .slice(0, 5);

        if (upgradeReady.length > 0) {
          const boosterList = upgradeReady.map(c =>
            `${c.cardDefId} (${c.boosters} boosters, split ${c.splitLevel || 0})`
          ).join(', ');
          sections.push(`Upgrade Ready (150+ boosters): ${boosterList}`);
        }

        // Total boosters info
        if (enhancedCollection.totalBoosters) {
          sections.push(`Total Boosters: ${enhancedCollection.totalBoosters.toLocaleString()}`);
        }

        // God splits progress
        if (enhancedCollection.godSplitCount) {
          sections.push(`God Splits: ${enhancedCollection.godSplitCount}`);
        }
      }

      if (sections.length === 0) {
        return null; // No economy data available
      }

      return `ECONOMY STATUS:\n${sections.map(s => `- ${s}`).join('\n')}`;
    };

    // Build system prompt with user context (Phase 2: Enhanced context injection)
    const buildSystemPrompt = (collection, matches) => {
      const persona = getActivePersona();
      const matchAnalysis = analyzeRecentMatches(matches);
      const collectionAnalysis = analyzeCollectionGaps(collection, uniqueCards);

      // Load imported profile stats from game files (takes priority over manual logging)
      const importedStats = loadFromStorage('snap_profile_stats', null);

      // Build personality section from persona
      const personality = persona.personality || {};
      const personalitySection = `PERSONALITY:
- Tone: ${personality.tone || 'Confident and encouraging'}
- Style: ${personality.style || 'Direct tactical guidance'}
- Voice: ${personality.voice || 'Like a seasoned hero mentoring a new Avenger'}
${personality.quirks ? `- Quirks: ${personality.quirks.join('; ')}` : ''}`;

      // Build expertise section
      const expertiseSection = persona.expertise ?
        `YOUR EXPERTISE:\n${persona.expertise.map(e => `- ${e}`).join('\n')}` : '';

      // Build principles section
      const principlesSection = persona.principles || persona.guiding_principles ?
        `GUIDING PRINCIPLES:\n${(persona.principles || persona.guiding_principles).map(p => `- ${p}`).join('\n')}` : '';

      // Build rich user context section
      let userContextSection = `USER CONTEXT (${META_CONTEXT.currentDate}):`;

      // Collection info
      userContextSection += `\n- Collection: ${collectionAnalysis.totalOwned}/${collectionAnalysis.totalCards} cards (${collectionAnalysis.completionPercent}% complete)`;

      // Match history section - use imported stats if available, otherwise use manual logging
      if (importedStats) {
        // Use imported game stats (more accurate lifetime data)
        const totalGames = importedStats.totalGames || (importedStats.wins + importedStats.losses);
        userContextSection += `\n\nLIFETIME STATS (from game):`;
        userContextSection += `\n- Total Games: ${totalGames.toLocaleString()}`;
        userContextSection += `\n- Wins: ${importedStats.wins.toLocaleString()} | Losses: ${importedStats.losses.toLocaleString()}`;
        userContextSection += `\n- Win Rate: ${importedStats.winRate}%`;
        if (importedStats.snapId) {
          userContextSection += `\n- Snap ID: ${importedStats.snapId}`;
        }

        // Also include recent manual match data if available
        if (matchAnalysis.hasData) {
          userContextSection += `\n\nRECENT SESSIONS (manual tracking):`;
          userContextSection += `\n- Recent (last ${matchAnalysis.recentMatchCount}): ${matchAnalysis.recent.winRate}% win rate, ${matchAnalysis.recent.netCubes >= 0 ? '+' : ''}${matchAnalysis.recent.netCubes} cubes`;
          userContextSection += `\n- Trend: ${matchAnalysis.trend === 'improving' ? ' Improving' : matchAnalysis.trend === 'declining' ? ' Declining' : ' Stable'}`;

          if (matchAnalysis.streak.count > 1) {
            userContextSection += `\n- Current streak: ${matchAnalysis.streak.count} ${matchAnalysis.streak.type === 'WIN' ? 'wins' : 'losses'}`;
          }

          // Deck performance if available
          if (matchAnalysis.deckStats && matchAnalysis.deckStats.length > 0) {
            userContextSection += `\n\nDECK PERFORMANCE:`;
            for (const deck of matchAnalysis.deckStats.slice(0, 3)) {
              userContextSection += `\n- ${deck.name}: ${deck.games} games, ${deck.winRate}% WR, ${deck.cubes >= 0 ? '+' : ''}${deck.cubes} cubes`;
            }
          }
        }
      } else if (matchAnalysis.hasData) {
        // Fall back to manual match logging only
        userContextSection += `\n\nMATCH STATISTICS:`;
        userContextSection += `\n- All-Time: ${matchAnalysis.allTime.games} games, ${matchAnalysis.allTime.winRate}% win rate, ${matchAnalysis.allTime.netCubes >= 0 ? '+' : ''}${matchAnalysis.allTime.netCubes} cubes`;
        userContextSection += `\n- Recent (last ${matchAnalysis.recentMatchCount}): ${matchAnalysis.recent.winRate}% win rate, ${matchAnalysis.recent.netCubes >= 0 ? '+' : ''}${matchAnalysis.recent.netCubes} cubes`;
        userContextSection += `\n- Trend: ${matchAnalysis.trend === 'improving' ? ' Improving' : matchAnalysis.trend === 'declining' ? ' Declining' : ' Stable'}`;

        if (matchAnalysis.streak.count > 1) {
          userContextSection += `\n- Current streak: ${matchAnalysis.streak.count} ${matchAnalysis.streak.type === 'WIN' ? 'wins' : 'losses'}`;
        }

        // Deck performance if available
        if (matchAnalysis.deckStats && matchAnalysis.deckStats.length > 0) {
          userContextSection += `\n\nDECK PERFORMANCE:`;
          for (const deck of matchAnalysis.deckStats.slice(0, 3)) {
            userContextSection += `\n- ${deck.name}: ${deck.games} games, ${deck.winRate}% WR, ${deck.cubes >= 0 ? '+' : ''}${deck.cubes} cubes`;
          }
        }
      } else {
        userContextSection += `\n- No match history recorded yet (import game files or log matches manually)`;
      }

      // Collection gaps - key missing meta cards
      if (collectionAnalysis.missingMetaCards.length > 0) {
        userContextSection += `\n\nKEY MISSING META CARDS: ${collectionAnalysis.missingMetaCards.slice(0, 8).join(', ')}`;
      }

      // Archetype access summary
      const playableArchetypes = Object.entries(collectionAnalysis.archetypeAccess)
        .filter(([_, data]) => data.percent >= 60)
        .map(([name, data]) => `${name} (${data.percent}%)`)
        .join(', ');

      if (playableArchetypes) {
        userContextSection += `\n- Playable Archetypes: ${playableArchetypes}`;
      }

      // Build dynamic meta section
      const metaSection = `CURRENT META (${META_CONTEXT.lastUpdated} - ${META_CONTEXT.season}):
Top Archetypes:
${META_CONTEXT.topArchetypes.slice(0, 5).map(a => `- ${a.tier} Tier: ${a.name} - ${a.description}`).join('\n')}

Recent Balance Changes:
${META_CONTEXT.recentOTA.map(c => `- ${c}`).join('\n')}

Hot Cards: ${META_CONTEXT.hotCards.join(', ')}
Tech Options: ${META_CONTEXT.techCards.join(', ')}`;

      // Build knowledge base section if available from persona
      let knowledgeSection = '';
      if (persona.knowledgeBase || persona.knowledge_base) {
        const kb = persona.knowledgeBase || persona.knowledge_base;
        knowledgeSection = `\nKNOWLEDGE BASE:
- Archetypes: ${(kb.archetypes || []).join(', ')}
- Key Concepts: ${(kb.keyConcepts || kb.key_concepts || []).join(', ')}`;
      }

      // Build economy context (wallet, pity, boosters)
      const economyContext = buildEconomyContext();
      const economySection = economyContext ? `\n${economyContext}` : '';

      // Assemble the complete system prompt
      const identity = persona.identity || {};
      return `You are ${persona.name}, a ${persona.role || identity.role}.
${identity.philosophy ? `\nPHILOSOPHY: "${identity.philosophy}"` : ''}

${personalitySection}

${expertiseSection}

${principlesSection}

${userContextSection}
${economySection}

${metaSection}
${knowledgeSection}

RESPONSE GUIDELINES:
- Provide practical, actionable Marvel Snap advice
- Be thorough but focused - give complete answers without unnecessary padding
- Reference Marvel lore when it adds flavor or helps explain strategy
- Use card game terminology naturally (cube equity, snap decision, tech card, etc.)
- Consider the user's collection and recent performance when making recommendations
- If discussing decks, mention which cards the user owns vs. needs to acquire
- When economy data is available, factor pity progress into acquisition advice and remind about cards ready for upgrades`;
    };

    // Helper to split system messages from chat messages for Gemini
    const splitSystemAndChat = (apiMessages) => {
      const systemTexts = apiMessages
        .filter(m => m.role === 'system')
        .map(m => m.content)
        .filter(Boolean);
      const chatMessages = apiMessages.filter(m => m.role !== 'system');
      return { systemText: systemTexts.join('\n\n'), chatMessages };
    };

    // API call functions for each provider
    const callGeminiOAuth = async (messages, model) => {
      // Get access token (will refresh if expired)
      const accessToken = await getGoogleAccessToken();

      if (!accessToken) {
        throw new Error('Not signed in to Google. Please sign in first.');
      }

      // Split system prompt from chat messages
      const { systemText, chatMessages } = splitSystemAndChat(messages);

      // Build request body with proper systemInstruction
      const requestBody = {
        contents: chatMessages.map(m => ({
          role: m.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: m.content }]
        })),
        generationConfig: {
          maxOutputTokens: 8192,
          temperature: 0.7
        }
      };

      // Add system instruction if we have system context
      if (systemText) {
        requestBody.systemInstruction = {
          parts: [{ text: systemText }]
        };
      }

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        if (response.status === 401) {
          // Token invalid - clear it
          localStorage.removeItem('snap_google_access_token');
          localStorage.removeItem('snap_google_token_expiry');
          throw new Error('Google session expired. Please sign in again.');
        }

        throw new Error(`Gemini API error: ${response.status} - ${(errorData.error && errorData.error.message) || 'Unknown error'}`);
      }

      const data = await response.json();

      if (!(data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text)) {
        throw new Error('Invalid response from Gemini API');
      }

      return data.candidates[0].content.parts[0].text;
    };

    const callGeminiAPIKey = async (messages, model, apiKey) => {
      // Split system prompt from chat messages
      const { systemText, chatMessages } = splitSystemAndChat(messages);

      // Build request body with proper systemInstruction
      const requestBody = {
        contents: chatMessages.map(m => ({
          role: m.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: m.content }]
        })),
        generationConfig: {
          maxOutputTokens: 8192,
          temperature: 0.7
        }
      };

      // Add system instruction if we have system context
      if (systemText) {
        requestBody.systemInstruction = {
          parts: [{ text: systemText }]
        };
      }

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        }
      );
      if (!response.ok) throw new Error(`Gemini API error: ${response.status}`);
      const data = await response.json();
      return safeGet(data, 'candidates.0.content.parts.0.text', 'No response');
    };

    const callGroq = async (messages, model, apiKey) => {
      const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 32768 })
      });
      if (!response.ok) throw new Error(`Groq error: ${response.status}`);
      const data = await response.json();
      return safeGet(data, 'choices.0.message.content', 'No response');
    };

    const callClaude = async (messages, model, apiKey) => {
      const systemMsg = messages.find(m => m.role === 'system');
      const otherMsgs = messages.filter(m => m.role !== 'system');

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'Content-Type': 'application/json',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model,
          max_tokens: 8192,
          system: (systemMsg && systemMsg.content) || '',
          messages: otherMsgs
        })
      });
      if (!response.ok) throw new Error(`Claude error: ${response.status}`);
      const data = await response.json();
      return safeGet(data, 'content.0.text', 'No response');
    };

    const callOpenAI = async (messages, model, apiKey) => {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ model, messages, max_tokens: 32768 })
      });
      if (!response.ok) throw new Error(`OpenAI error: ${response.status}`);
      const data = await response.json();
      return safeGet(data, 'choices.0.message.content', 'No response');
    };

    const callLocal = async (messages, model, endpoint) => {
      const response = await fetch(`${endpoint}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model, messages, stream: false })
      });
      if (!response.ok) throw new Error(`Local error: ${response.status}`);
      const data = await response.json();
      return safeGet(data, 'message.content', 'No response');
    };

    // ==================== LOG PARSER ====================
    const LogParser = {
      parsePlayerLog(logContent) {
        const matches = [];
        const lines = logContent.split('\n');

        let currentTimestamp = null;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];

          // Extract timestamp if present
          const tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\]/);
          if (tsMatch) {
            currentTimestamp = tsMatch[1];
          }

          // Look for game result patterns in the log
          if (line.includes('GameResult') || line.includes('MatchComplete') ||
              line.includes('BattleResult') || line.includes('GameOutcome') ||
              line.includes('"Result"') || line.includes('CubesDelta')) {
            try {
              // Try to find JSON object in the line
              const jsonMatch = line.match(/\{[^{}]*\}/);
              if (jsonMatch) {
                const data = JSON.parse(jsonMatch[0]);

                const result = this.normalizeResult(data.Result || data.GameOutcome || data.Outcome);
                const cubes = parseInt(data.CubesDelta || data.Cubes || data.cubes || 0);

                if (result && cubes !== 0) {
                  matches.push({
                    id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                    timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                    result: result,
                    cubes: Math.abs(cubes),
                    deckId: data.DeckId || data.DeckName || null,
                    opponent: data.OpponentName || null,
                    snapped: this.parseSnapState(data),
                    source: 'log_import',
                    notes: ''
                  });
                }
              }
            } catch (e) {
              // Not valid JSON, continue scanning
            }
          }

          // Alternative pattern: look for win/loss with cube values
          const simpleMatch = line.match(/(WIN|LOSS|VICTORY|DEFEAT|RETREAT)[^\d]*(\d+)\s*cube/i);
          if (simpleMatch && !matches.find(m => m.timestamp === currentTimestamp)) {
            const result = this.normalizeResult(simpleMatch[1]);
            const cubes = parseInt(simpleMatch[2]);
            if (result && cubes > 0) {
              matches.push({
                id: crypto.randomUUID ? crypto.randomUUID() : generateId(),
                timestamp: currentTimestamp ? new Date(currentTimestamp).toISOString() : new Date().toISOString(),
                result: result,
                cubes: cubes,
                deckId: null,
                opponent: null,
                snapped: 'NONE',
                source: 'log_import',
                notes: ''
              });
            }
          }
        }

        const unique = this.deduplicateMatches(matches);

        return {
          matches: unique,
          parseDate: new Date().toISOString(),
          rawLineCount: lines.length,
          matchCount: unique.length
        };
      },

      normalizeResult(result) {
        if (!result) return null;
        const r = String(result).toUpperCase();
        if (r.includes('WIN') || r === 'VICTORY') return 'WIN';
        if (r.includes('LOSS') || r.includes('LOSE') || r === 'DEFEAT') return 'LOSS';
        if (r.includes('RETREAT')) return 'LOSS';
        return null;
      },

      parseSnapState(data) {
        if (data.PlayerSnapped && data.OpponentSnapped) return 'BOTH';
        if (data.PlayerSnapped) return 'PLAYER';
        if (data.OpponentSnapped) return 'OPPONENT';
        return 'NONE';
      },

      deduplicateMatches(matches) {
        const seen = new Set();
        return matches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      },

      mergeWithExisting(newMatches, existingMatches) {
        const existingKeys = new Set(
          existingMatches.map(m => `${m.timestamp}-${m.result}-${m.cubes}`)
        );

        const toAdd = newMatches.filter(m => {
          const key = `${m.timestamp}-${m.result}-${m.cubes}`;
          return !existingKeys.has(key);
        });

        return {
          added: toAdd,
          skipped: newMatches.length - toAdd.length,
          merged: [...existingMatches, ...toAdd].sort((a, b) =>
            new Date(b.timestamp) - new Date(a.timestamp)
          )
        };
      }
    };

    // ==================== GAME DATA PARSER (Phase 5) ====================
    const GameDataParser = {
      /**
       * Parse CollectionState.json for owned cards
       * Now async to ensure card data is loaded before parsing
       */
      async parseCollection(json) {
        const cards = new Set();

        // Ensure full card data is loaded before building defId map
        // This is critical - fallback data doesn't have defId fields
        const cardData = await CardDataLoader.load();

        // Build defIdname lookup map from card database
        // Game stores CardDefId (e.g., "AntMan") but UI matches by name (e.g., "Ant Man")
        const defIdToName = new Map();
        cardData.forEach(card => {
          if (card.defId) {
            defIdToName.set(card.defId, card.name);
          }
          // Also map name directly in case some entries use display names
          defIdToName.set(card.name, card.name);
        });

        console.log(`[parseCollection] Built defId map with ${defIdToName.size} entries from ${cardData.length} cards`);

        // Helper to recursively find all CardDefId values
        const findCards = (obj) => {
          if (!obj || typeof obj !== 'object') return;

          if (obj.CardDefId && typeof obj.CardDefId === 'string') {
            const cardDefId = obj.CardDefId;
            // Filter out tokens/created cards (usually have special naming)
            if (!cardDefId.includes('Token') &&
                !cardDefId.includes('Stone') &&
                !cardDefId.includes('Shard') &&
                !cardDefId.startsWith('_')) {
              // Convert CardDefId to display name for UI matching
              const displayName = defIdToName.get(cardDefId);
              if (displayName) {
                cards.add(displayName);
              } else {
                // Card not in database - log but don't add (might be new card)
                console.log(`[parseCollection] Unknown CardDefId: ${cardDefId}`);
              }
            }
          }

          // Recurse into arrays and objects
          if (Array.isArray(obj)) {
            obj.forEach(findCards);
          } else {
            Object.values(obj).forEach(findCards);
          }
        };

        findCards(json);

        return {
          type: 'collection',
          cards: Array.from(cards).sort(),
          count: cards.size,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse ProfileState.json for stats and card performance
       */
      parseProfile(json) {
        const serverState = (json && json.ServerState) || {};
        const account = serverState.Account;
        if (!account) return null;

        // Parse card stats (net cubes per card)
        const cardStats = account.CardStats || {};
        const cardPerformance = Object.entries(cardStats)
          .map(([card, netCubes]) => ({ card, netCubes }))
          .sort((a, b) => b.netCubes - a.netCubes);

        // Parse wallet
        const wallet = serverState.Wallet || {};
        const currencies = wallet.Currencies || {};

        const wins = account.Wins || 0;
        const losses = account.Losses || 0;

        return {
          type: 'profile',
          player: {
            name: account.Name || 'Unknown',
            tag: account.Tag || 0,
            snapId: `${account.Name || 'Unknown'}#${account.Tag || 0}`
          },
          stats: {
            wins: wins,
            losses: losses,
            ties: account.Ties || 0,
            totalGames: wins + losses + (account.Ties || 0),
            winRate: wins > 0 ? ((wins / (wins + losses)) * 100).toFixed(1) : '0.0',
            snaps: account.Snaps || 0,
            concedes: account.Concedes || 0,
            opponentConcedes: account.OpponentConcedes || 0
          },
          cardPerformance: {
            top10: cardPerformance.filter(c => c.netCubes > 0).slice(0, 10),
            bottom10: cardPerformance.filter(c => c.netCubes < 0).slice(-10).reverse(),
            all: cardPerformance
          },
          currencies: {
            credits: (currencies.Credits && currencies.Credits.TotalAmount) || 0,
            gold: (currencies.Gold && currencies.Gold.TotalAmount) || 0,
            tokens: (currencies.CollectorsToken && currencies.CollectorsToken.TotalAmount) || 0
          },
          lastLogin: account.LastLogin,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse CharacterMasteryState.json for mastery levels
       */
      parseMastery(json) {
        const progress = safeGet(json, 'ServerState.CharacterMasteryProgress.CharacterProgressData', null);
        if (!progress) return null;

        const masteryData = Object.entries(progress)
          .map(([card, data]) => ({
            card,
            experience: data.Experience || 0,
            level: parseInt(data.LastClaimedLevel) || 1,
            levelCap: parseInt(data.LevelCap) || 30
          }))
          .sort((a, b) => b.level - a.level || b.experience - a.experience);

        return {
          type: 'mastery',
          cards: masteryData,
          totalCards: masteryData.length,
          avgLevel: masteryData.length > 0 ? (masteryData.reduce((sum, c) => sum + c.level, 0) / masteryData.length).toFixed(1) : '0',
          maxedCards: masteryData.filter(c => c.level >= c.levelCap).length,
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse BattlePassState.json for season pass progress
       */
      parseBattlePass(json) {
        const battlePass = safeGet(json, 'ServerState.BattlePass', null);
        if (!battlePass) return null;

        return {
          type: 'battlePass',
          season: battlePass.BattlePassDefId || 'Unknown',
          level: battlePass.Level || 0,
          xp: battlePass.Xp || 0,
          claimedLevels: battlePass.LevelsClaimed || [],
          parseDate: new Date().toISOString()
        };
      },

      /**
       * Parse RewardState.json for pity counters (Spotlight Oracle)
       * Critical for predicting S4/S5 drops and spotlight key efficiency
       */
      parseRewardState(json) {
        try {
          if (!json?.ServerState) return null;

          const collectorCache = json.ServerState?.CollectorsCacheAsset || {};
          const spotlightCache = json.ServerState?.SpotlightCacheState || {};

          // Extract pity counters - these track pulls since last S4/S5/Spotlight
          const pityCounters = {
            s4: collectorCache?.Series4Counter || collectorCache?.Counters?.Series4 || 0,
            s5: collectorCache?.Series5Counter || collectorCache?.Counters?.Series5 || 0,
            spotlight: spotlightCache?.Counter || spotlightCache?.PityCounter || 0,
            spotlightKey: spotlightCache?.KeyCounter || 0
          };

          // Extract cache opening history for analysis
          const cacheHistory = collectorCache?.History || spotlightCache?.History || [];

          // Pity thresholds (guaranteed drop rates)
          const pityThresholds = {
            s4: 20,   // Guaranteed S4 after 20 pulls
            s5: 60,   // Guaranteed S5 after 60 pulls
            spotlightKey: 4  // Guaranteed spotlight card every 4 keys
          };

          return {
            type: 'rewards',
            pityCounters,
            pityThresholds,
            cacheHistory: Array.isArray(cacheHistory) ? cacheHistory : [],
            isCloseToS4: pityCounters.s4 >= 15,
            isCloseToS5: pityCounters.s5 >= 50,
            isCloseToSpotlight: pityCounters.spotlightKey >= 3,
            parseDate: new Date().toISOString()
          };
        } catch (error) {
          console.error('Error parsing reward state:', error);
          return null;
        }
      },

      /**
       * Parse TokenShopState.json for token shop planning
       * Used for economy intelligence and purchase recommendations
       */
      parseTokenShopState(json) {
        try {
          if (!json?.ServerState) return null;

          const tokenShop = json.ServerState?.TokenShop || json.ServerState?.CollectorsTokenShop || {};
          const items = tokenShop?.Items || tokenShop?.AvailableItems || [];
          const refreshTime = tokenShop?.NextRefresh || tokenShop?.RefreshTime || null;

          // Parse items with costs
          const parsedItems = (Array.isArray(items) ? items : []).map(item => ({
            cardDefId: item?.CardDefId || item?.ItemId || 'Unknown',
            cost: item?.Cost || item?.TokenCost || 0,
            series: item?.Series || 'Unknown',
            purchased: item?.Purchased || false
          }));

          return {
            type: 'tokenShop',
            items: parsedItems,
            totalItems: parsedItems.length,
            availableItems: parsedItems.filter(i => !i.purchased).length,
            nextRefresh: refreshTime,
            parseDate: new Date().toISOString()
          };
        } catch (error) {
          console.error('Error parsing token shop state:', error);
          return null;
        }
      },

      /**
       * Parse MissionState.json for mission tracking
       * Used for mission tracker with deck suggestions
       */
      parseMissionState(json) {
        try {
          if (!json?.ServerState) return null;

          const missions = json.ServerState?.Missions || json.ServerState?.MissionProgress || {};

          // Parse daily missions
          const dailyMissions = (missions?.Daily || missions?.DailyMissions || []).map(m => ({
            id: m?.MissionDefId || m?.Id || 'Unknown',
            description: m?.Description || '',
            progress: m?.Progress || 0,
            target: m?.Target || m?.RequiredCount || 1,
            completed: m?.Completed || (m?.Progress >= (m?.Target || 1)),
            reward: m?.Reward || {}
          }));

          // Parse weekly missions
          const weeklyMissions = (missions?.Weekly || missions?.WeeklyMissions || []).map(m => ({
            id: m?.MissionDefId || m?.Id || 'Unknown',
            description: m?.Description || '',
            progress: m?.Progress || 0,
            target: m?.Target || m?.RequiredCount || 1,
            completed: m?.Completed || (m?.Progress >= (m?.Target || 1)),
            reward: m?.Reward || {}
          }));

          // Parse seasonal/featured missions
          const seasonalMissions = missions?.Seasonal || missions?.Featured || [];

          return {
            type: 'missions',
            daily: dailyMissions,
            weekly: weeklyMissions,
            seasonal: seasonalMissions,
            dailyCompleted: dailyMissions.filter(m => m.completed).length,
            weeklyCompleted: weeklyMissions.filter(m => m.completed).length,
            parseDate: new Date().toISOString()
          };
        } catch (error) {
          console.error('Error parsing mission state:', error);
          return null;
        }
      },

      /**
       * Parse TimeModelState.json for accurate server time
       * Used for reset countdowns (daily/weekly/season)
       */
      parseTimeModelState(json) {
        try {
          if (!json?.ServerState) return null;

          const timeModel = json.ServerState?.TimeModel || json.ServerState?.Time || {};

          // Server timestamp (Unix epoch or ISO string)
          const serverTimeRaw = timeModel?.ServerTime || timeModel?.CurrentTime || Date.now();
          const serverTime = typeof serverTimeRaw === 'string' ? new Date(serverTimeRaw) : new Date(serverTimeRaw);

          // Reset times
          const dailyResetRaw = timeModel?.DailyReset || timeModel?.NextDailyReset || null;
          const weeklyResetRaw = timeModel?.WeeklyReset || timeModel?.NextWeeklyReset || null;
          const seasonResetRaw = timeModel?.SeasonReset || timeModel?.SeasonEnd || null;

          return {
            type: 'timeModel',
            serverTime,
            serverTimeMs: serverTime.getTime(),
            dailyReset: dailyResetRaw ? new Date(dailyResetRaw) : null,
            weeklyReset: weeklyResetRaw ? new Date(weeklyResetRaw) : null,
            seasonReset: seasonResetRaw ? new Date(seasonResetRaw) : null,
            timezoneOffset: timeModel?.TimezoneOffset || 0,
            parseDate: new Date().toISOString()
          };
        } catch (error) {
          console.error('Error parsing time model state:', error);
          return null;
        }
      },

      /**
       * Parse RankState.json for rank information
       * Used for dashboard rank display
       */
      parseRankState(json) {
        try {
          if (!json?.ServerState) return null;

          const rank = json.ServerState?.Rank || json.ServerState?.CompetitiveRank || {};

          // Rank tiers: Bronze(0-29), Silver(30-39), Gold(40-49), Platinum(50-59),
          // Diamond(60-69), Vibranium(70-79), Omega(80-89), Galactic(90-100), Infinite(100+)
          const currentRank = rank?.CurrentRank || rank?.Rank || 0;
          const getTierName = (r) => {
            if (r >= 100) return 'Infinite';
            if (r >= 90) return 'Galactic';
            if (r >= 80) return 'Omega';
            if (r >= 70) return 'Vibranium';
            if (r >= 60) return 'Diamond';
            if (r >= 50) return 'Platinum';
            if (r >= 40) return 'Gold';
            if (r >= 30) return 'Silver';
            return 'Bronze';
          };

          return {
            type: 'rank',
            currentRank,
            tier: getTierName(currentRank),
            cubes: rank?.Cubes || 0,
            seasonBest: rank?.SeasonBest || rank?.HighestRank || currentRank,
            seasonBestTier: getTierName(rank?.SeasonBest || currentRank),
            parseDate: new Date().toISOString()
          };
        } catch (error) {
          console.error('Error parsing rank state:', error);
          return null;
        }
      },

      /**
       * Parse DeckState.json for saved decks
       * Used for deck management and mission suggestions
       */
      parseDeckState(json) {
        try {
          if (!json?.ServerState) return null;

          const decks = json.ServerState?.Decks || json.ServerState?.DeckList || [];

          const parsedDecks = (Array.isArray(decks) ? decks : []).map(deck => ({
            id: deck?.DeckId || deck?.Id || '',
            name: deck?.Name || 'Unnamed Deck',
            cards: (deck?.Cards || deck?.CardList || []).map(c =>
              typeof c === 'string' ? c : (c?.CardDefId || c?.Name || '')
            ).filter(Boolean),
            isFavorite: deck?.IsFavorite || false,
            lastUsed: deck?.LastUsed || null
          }));

          return {
            type: 'decks',
            decks: parsedDecks,
            totalDecks: parsedDecks.length,
            parseDate: new Date().toISOString()
          };
        } catch (error) {
          console.error('Error parsing deck state:', error);
          return null;
        }
      },

      /**
       * Enhanced parseCollection for Hall of Armor (variants, splits, boosters)
       * Extracts variant art IDs, surface effects, and booster counts
       */
      parseCollectionEnhanced(json) {
        try {
          const cards = new Map(); // cardDefId -> detailed card data
          const variants = [];
          const splits = [];

          const findCardDetails = (obj, path = '') => {
            if (!obj || typeof obj !== 'object') return;

            // Found a card entry with detailed info
            if (obj.CardDefId && typeof obj.CardDefId === 'string') {
              const cardId = obj.CardDefId;

              // Skip tokens and system cards
              if (cardId.includes('Token') || cardId.includes('Stone') ||
                  cardId.includes('Shard') || cardId.startsWith('_')) {
                return;
              }

              // Get or create card entry
              if (!cards.has(cardId)) {
                cards.set(cardId, {
                  cardDefId: cardId,
                  variants: [],
                  boosters: 0,
                  splitLevel: 0,
                  owned: true
                });
              }

              const cardData = cards.get(cardId);

              // Extract variant info
              if (obj.ArtVariantDefId || obj.SurfaceEffectDefId) {
                const variant = {
                  artVariantDefId: obj.ArtVariantDefId || null,
                  surfaceEffectDefId: obj.SurfaceEffectDefId || null,
                  isGodSplit: (obj.SurfaceEffectDefId || '').toLowerCase().includes('ink') ||
                              (obj.SurfaceEffectDefId || '').toLowerCase().includes('gold') ||
                              (obj.SurfaceEffectDefId || '').toLowerCase().includes('krackle'),
                  isInfinity: (obj.RarityDefId || '').toLowerCase().includes('infinity')
                };
                cardData.variants.push(variant);
                variants.push({ cardDefId: cardId, ...variant });

                if (variant.isGodSplit) {
                  splits.push({ cardDefId: cardId, effect: obj.SurfaceEffectDefId });
                }
              }

              // Extract boosters
              if (obj.Boosters !== undefined) {
                cardData.boosters = Math.max(cardData.boosters, obj.Boosters || 0);
              }

              // Extract split level
              if (obj.SplitLevel !== undefined || obj.RarityLevel !== undefined) {
                cardData.splitLevel = Math.max(cardData.splitLevel, obj.SplitLevel || obj.RarityLevel || 0);
              }
            }

            // Recurse
            if (Array.isArray(obj)) {
              obj.forEach(item => findCardDetails(item, path));
            } else {
              Object.entries(obj).forEach(([key, val]) => findCardDetails(val, `${path}.${key}`));
            }
          };

          findCardDetails(json);

          const cardList = Array.from(cards.values());

          return {
            type: 'collectionEnhanced',
            cards: cardList.sort((a, b) => a.cardDefId.localeCompare(b.cardDefId)),
            cardCount: cardList.length,
            variants: variants,
            variantCount: variants.length,
            godSplits: splits,
            godSplitCount: splits.length,
            totalBoosters: cardList.reduce((sum, c) => sum + c.boosters, 0),
            parseDate: new Date().toISOString()
          };
        } catch (error) {
          console.error('Error parsing enhanced collection:', error);
          return null;
        }
      }
    };

    // ==================== INDEXEDDB HELPER (Phase 5) ====================
    const openSyncDB = () => {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('SnapSyncDB', 1);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          const db = request.result;
          resolve({
            get: (store, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readonly');
              const req = tx.objectStore(store).get(key);
              req.onsuccess = () => res(req.result);
              req.onerror = () => rej(req.error);
            }),
            put: (store, value, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readwrite');
              const req = tx.objectStore(store).put(value, key);
              req.onsuccess = () => res();
              req.onerror = () => rej(req.error);
            }),
            delete: (store, key) => new Promise((res, rej) => {
              const tx = db.transaction(store, 'readwrite');
              const req = tx.objectStore(store).delete(key);
              req.onsuccess = () => res();
              req.onerror = () => rej(req.error);
            })
          });
        };

        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('settings')) {
            db.createObjectStore('settings');
          }
        };
      });
    };

    // Auto-import all data without preview (for linked folder sync)
    // Player OS: Stores data for all features
    const autoImportAll = (data) => {
      const timestamp = new Date().toISOString();
      const results = [];

      // Collection (basic card list)
      if (data.collection) {
        const existing = JSON.parse(localStorage.getItem('snap_collection') || '{"owned":[]}');
        const merged = [...new Set([...existing.owned, ...data.collection.cards])];
        localStorage.setItem('snap_collection', JSON.stringify({
          owned: merged,
          lastUpdated: timestamp,
          source: 'LinkedFolder'
        }));
        results.push(`Collection: ${merged.length} cards`);
      }

      // Enhanced Collection (Hall of Armor - variants, splits, boosters)
      if (data.collectionEnhanced) {
        localStorage.setItem('snap_collection_enhanced', JSON.stringify({
          ...data.collectionEnhanced,
          importedAt: timestamp
        }));
        results.push(`Hall of Armor: ${data.collectionEnhanced.godSplitCount} God Splits`);
      }

      // Profile & Wallet
      if (data.profile) {
        localStorage.setItem('snap_profile_stats', JSON.stringify({
          ...data.profile.stats,
          snapId: data.profile.player.snapId,
          currencies: data.profile.currencies,
          importedAt: timestamp
        }));
        results.push(`Stats: ${data.profile.stats.winRate}% win rate`);

        // Store wallet separately for easy access
        localStorage.setItem('snap_wallet', JSON.stringify({
          ...data.profile.currencies,
          importedAt: timestamp
        }));

        // Card performance
        if (data.profile.cardPerformance) {
          const performanceMap = {};
          data.profile.cardPerformance.all.forEach(({ card, netCubes }) => {
            performanceMap[card] = { netCubes };
          });
          localStorage.setItem('snap_card_performance', JSON.stringify({
            cards: performanceMap,
            importedAt: timestamp
          }));
          results.push(`Card Performance: ${data.profile.cardPerformance.all.length} cards`);
        }
      }

      // Mastery
      if (data.mastery) {
        localStorage.setItem('snap_mastery', JSON.stringify({
          cards: data.mastery.cards,
          importedAt: timestamp
        }));
        results.push(`Mastery: ${data.mastery.totalCards} cards`);
      }

      // Battle Pass
      if (data.battlePass) {
        localStorage.setItem('snap_battlepass', JSON.stringify({
          ...data.battlePass,
          importedAt: timestamp
        }));
        results.push(`Battle Pass: Level ${data.battlePass.level}`);
      }

      // Rewards / Pity Counters (Spotlight Oracle)
      if (data.rewards) {
        localStorage.setItem('snap_rewards', JSON.stringify({
          ...data.rewards,
          importedAt: timestamp
        }));
        const pity = data.rewards.pityCounters;
        results.push(`Pity: S4=${pity.s4}/20, S5=${pity.s5}/60`);
      }

      // Token Shop (Economy Intelligence)
      if (data.tokenShop) {
        localStorage.setItem('snap_tokenshop', JSON.stringify({
          ...data.tokenShop,
          importedAt: timestamp
        }));
        results.push(`Token Shop: ${data.tokenShop.availableItems} items`);
      }

      // Missions (Mission Tracker)
      if (data.missions) {
        localStorage.setItem('snap_missions', JSON.stringify({
          ...data.missions,
          importedAt: timestamp
        }));
        results.push(`Missions: ${data.missions.dailyCompleted}/? daily`);
      }

      // Time Model (Server Time for Countdowns)
      if (data.timeModel) {
        localStorage.setItem('snap_timemodel', JSON.stringify({
          serverTime: data.timeModel.serverTime?.toISOString?.() || data.timeModel.serverTime,
          dailyReset: data.timeModel.dailyReset?.toISOString?.() || data.timeModel.dailyReset,
          weeklyReset: data.timeModel.weeklyReset?.toISOString?.() || data.timeModel.weeklyReset,
          seasonReset: data.timeModel.seasonReset?.toISOString?.() || data.timeModel.seasonReset,
          importedAt: timestamp
        }));
        results.push(`Server Time: synced`);
      }

      // Rank
      if (data.rank) {
        localStorage.setItem('snap_rank', JSON.stringify({
          ...data.rank,
          importedAt: timestamp
        }));
        results.push(`Rank: ${data.rank.tier} (${data.rank.currentRank})`);
      }

      // Saved Decks
      if (data.decks) {
        localStorage.setItem('snap_saved_decks', JSON.stringify({
          ...data.decks,
          importedAt: timestamp
        }));
        results.push(`Decks: ${data.decks.totalDecks} saved`);
      }

      // Store unified player state for easy access by components
      const playerState = {
        collection: data.collection,
        collectionEnhanced: data.collectionEnhanced,
        profile: data.profile,
        mastery: data.mastery,
        battlePass: data.battlePass,
        rewards: data.rewards,
        tokenShop: data.tokenShop,
        missions: data.missions,
        timeModel: data.timeModel,
        rank: data.rank,
        decks: data.decks,
        lastSync: timestamp
      };
      localStorage.setItem('snap_player_state', JSON.stringify(playerState));

      return results;
    };

    // ==================== COLLECTION INFERRER ====================
    const CollectionInferrer = {
      inferFromMatches(matches) {
        const usedCards = new Set();
        for (const match of matches) {
          if (match.deckCards && Array.isArray(match.deckCards)) {
            match.deckCards.forEach(card => usedCards.add(card));
          }
        }
        return Array.from(usedCards);
      },

      mergeWithCollection(inferredCards, existingCollection) {
        const existing = new Set(existingCollection.owned || []);
        let addedCount = 0;

        for (const card of inferredCards) {
          if (!existing.has(card)) {
            existing.add(card);
            addedCount++;
          }
        }

        return {
          owned: Array.from(existing),
          addedCount,
          lastUpdated: new Date().toISOString()
        };
      }
    };

    // ==================== VAULT MANAGER ====================
    const VaultManager = {
      exportFullVault(collection, matches, settings) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const totalGames = matches.length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          version: '1.0',
          exportDate: new Date().toISOString(),
          collection: collection,
          matches: matches,
          settings: settings,
          stats: {
            totalGames,
            wins: totalWins,
            losses: totalGames - totalWins,
            winRate: totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0,
            netCubes
          }
        };
      },

      generateSyncData(collection, matches) {
        const totalWins = matches.filter(m => m.result === 'WIN').length;
        const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

        return {
          v: 1,
          c: collection.owned || [],
          s: {
            wins: totalWins,
            losses: matches.length - totalWins,
            cubes: netCubes
          }
        };
      },

      compressForQR(syncData) {
        try {
          return LZString.compressToEncodedURIComponent(JSON.stringify(syncData));
        } catch (e) {
          console.error('Compression failed:', e);
          return null;
        }
      },

      decompressFromQR(compressed) {
        try {
          const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
          return JSON.parse(decompressed);
        } catch (e) {
          console.error('Decompression failed:', e);
          return null;
        }
      },

      // Enhanced compression using card indices instead of names (v2 format)
      compressForQRv2(ownedCardNames, stats, cardIndex) {
        try {
          // Convert card names to indices (much smaller than full names)
          const indices = ownedCardNames
            .map(name => cardIndex[name])
            .filter(idx => idx !== undefined)
            .sort((a, b) => a - b);

          // Use delta encoding for sorted indices (even smaller)
          const deltas = indices.map((val, i) => i === 0 ? val : val - indices[i - 1]);

          const payload = {
            v: 2, // Version 2 format
            d: deltas, // Delta-encoded indices
            s: stats ? { w: stats.wins || 0, l: stats.losses || 0, c: stats.cubes || 0 } : null
          };

          return LZString.compressToEncodedURIComponent(JSON.stringify(payload));
        } catch (e) {
          console.error('V2 compression failed:', e);
          return null;
        }
      },

      decompressFromQRv2(compressed, cardList) {
        try {
          const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
          const payload = JSON.parse(decompressed);

          if (payload.v !== 2) {
            // Fallback to v1 format
            return payload;
          }

          // Reconstruct indices from deltas
          const indices = [];
          let currentIndex = 0;
          for (const delta of payload.d) {
            currentIndex += delta;
            indices.push(currentIndex);
          }

          // Convert indices back to card names
          const cardNames = indices
            .map(idx => cardList[idx]?.name)
            .filter(name => name);

          return {
            v: 1, // Convert to v1 format for downstream compatibility
            c: cardNames,
            s: payload.s ? {
              wins: payload.s.w || 0,
              losses: payload.s.l || 0,
              cubes: payload.s.c || 0
            } : null
          };
        } catch (e) {
          console.error('V2 decompression failed:', e);
          return null;
        }
      },

      // Calculate CRC16 checksum for integrity verification
      calculateChecksum(data) {
        let crc = 0xFFFF;
        for (let i = 0; i < data.length; i++) {
          crc ^= data.charCodeAt(i);
          for (let j = 0; j < 8; j++) {
            crc = (crc & 1) ? (crc >> 1) ^ 0xA001 : crc >> 1;
          }
        }
        return crc.toString(16).padStart(4, '0');
      },

      // Create multi-part QR payload with checksums
      createMultiPartPayload(compressed, partNum, totalParts) {
        const checksum = this.calculateChecksum(compressed);
        return {
          p: partNum,
          t: totalParts,
          k: checksum,
          d: compressed
        };
      },

      // Validate and merge multi-part payloads
      mergeMultiPartPayloads(parts) {
        const totalParts = parts[0]?.t;
        if (!totalParts || parts.length !== totalParts) {
          return { error: 'Missing parts', missing: this.findMissingParts(parts, totalParts) };
        }

        // Sort by part number and validate checksums
        const sorted = [...parts].sort((a, b) => a.p - b.p);
        for (const part of sorted) {
          const expectedChecksum = this.calculateChecksum(part.d);
          if (part.k !== expectedChecksum) {
            return { error: 'Checksum mismatch', part: part.p };
          }
        }

        // Merge data
        const merged = sorted.map(p => p.d).join('');
        return { data: merged };
      },

      findMissingParts(parts, totalParts) {
        const present = new Set(parts.map(p => p.p));
        const missing = [];
        for (let i = 1; i <= totalParts; i++) {
          if (!present.has(i)) missing.push(i);
        }
        return missing;
      }
    };

    // ==================== LOG ERROR MESSAGES ====================
    const LogErrors = {
      NO_MATCHES: 'No match data found. Make sure this is the Player.log file from Marvel Snap.',
      PARSE_FAILED: 'Could not parse log file. The game may have updated its format.',
      FILE_TOO_LARGE: 'File is too large (>50MB). Try using a more recent log file.',
      INVALID_FORMAT: 'This doesn\'t appear to be a Marvel Snap log file.',
      READ_ERROR: 'Could not read the file. Please try again.'
    };

    // ==================== UTILITY FUNCTIONS ====================
    const getSeriesBorderClass = (series) => `series-border-${series}`;

    const loadFromStorage = (key, defaultValue) => {
      try {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      } catch { return defaultValue; }
    };

    const saveToStorage = (key, value) => {
      try { localStorage.setItem(key, JSON.stringify(value)); }
      catch (e) { console.warn('Storage error:', e); }
    };

    const generateId = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });

    const formatDate = (dateString) => new Date(dateString).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
    });

    // Get Tailwind class for series color (supports series 1-10+)
    const getSeriesColorClass = (series, type = 'bg') => {
      const colors = {
        1: 'series-1', 2: 'series-2', 3: 'series-3', 4: 'series-4', 5: 'series-5',
        6: 'series-6', 7: 'series-7', 8: 'series-8', 9: 'series-9', 10: 'series-10'
      };
      const color = colors[series] || 'series-6'; // Default to series-6 (orange/spotlight) for unknown
      return `${type}-${color}`;
    };

    // Get all unique series from the card database
    const getAvailableSeries = () => {
      const series = new Set(uniqueCards.map(c => c.series).filter(s => s > 0));
      return Array.from(series).sort((a, b) => a - b);
    };

    // Map internal series numbers to player-friendly display names
    // Untapped.gg uses different numbering than in-game pools
    const getSeriesDisplayName = (series) => {
      const displayNames = {
        1: 'Pool 1',
        2: 'Pool 1',
        3: 'Pool 1',
        4: 'Pool 2',
        5: 'Pool 2',
        6: 'Pool 3',
        7: 'Pool 4',
        8: 'Pool 5',
        9: 'Spotlight',
        10: 'Spotlight'
      };
      return displayNames[series] || `Series ${series}`;
    };

    // Get series display label for UI (short form)
    const getSeriesLabel = (series) => {
      const labels = {
        1: 'P1', 2: 'P1', 3: 'P1',
        4: 'P2', 5: 'P2',
        6: 'P3', 7: 'P4', 8: 'P5',
        9: '', 10: ''
      };
      return labels[series] || `S${series}`;
    };

    // ==================== COMPONENTS ====================

    // Navigation Bar
    const NavBar = ({ activeTab, setActiveTab }) => {
      const primaryTabs = [
        { id: 'dashboard', label: 'Home', icon: 'home' },
        { id: 'collection', label: 'Cards', icon: 'style' },
        { id: 'decks', label: 'Decks', icon: 'auto_fix_high' },
        { id: 'history', label: 'History', icon: 'history' },
        { id: 'settings', label: 'More', icon: 'menu' }
      ];

      return (
        <nav className="fixed bottom-0 left-0 right-0 z-50 border-t border-stitch-border" style={{background: 'rgba(28,16,34,0.95)', backdropFilter: 'blur(20px)', WebkitBackdropFilter: 'blur(20px)'}} role="navigation" aria-label="Main navigation">
          <div className="flex justify-around items-center h-16 max-w-lg mx-auto" role="tablist" aria-label="App sections">
            {primaryTabs.map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)}
                role="tab"
                aria-selected={activeTab === tab.id}
                aria-controls={`panel-${tab.id}`}
                id={`tab-${tab.id}`}
                className={`flex flex-col items-center justify-center w-full h-full min-w-[44px] min-h-[44px] transition-colors duration-200 ${
                  activeTab === tab.id
                    ? 'text-cosmic-purple-text'
                    : 'text-stitch-muted hover:text-white'
                }`}>
                <span className="material-symbols-outlined" aria-hidden="true" style={{fontSize: '22px'}}>{tab.icon}</span>
                <span className="text-[10px] mt-0.5 font-medium font-display tracking-wide">{tab.label}</span>
              </button>
            ))}
          </div>
        </nav>
      );
    };

    // Header - Stitch Top Bar Style
    const Header = ({ title, subtitle, onBack }) => (
      <header className="stitch-topbar sticky top-0 z-40 py-3 px-4 mb-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            {onBack && (
              <button onClick={onBack} className="text-stitch-muted hover:text-white min-w-[44px] min-h-[44px] flex items-center justify-center">
                <span className="material-symbols-outlined" aria-hidden="true">arrow_back</span>
              </button>
            )}
            <div>
              <h1 className="text-lg font-display font-bold text-white tracking-wide">{title}</h1>
              {subtitle && <p className="text-xs text-cosmic-purple-text font-medium">{subtitle}</p>}
            </div>
          </div>
        </div>
      </header>
    );

    // Dashboard Component - Player OS Home
    const Dashboard = ({ collection, matches, onQuickMatch }) => {
      const [importedStats, setImportedStats] = useState(null);
      const [wallet, setWallet] = useState(null);
      const [rewards, setRewards] = useState(null);
      const [rank, setRank] = useState(null);
      const [timeModel, setTimeModel] = useState(null);

      // Load all Player OS data on mount and when data updates
      useEffect(() => {
        const loadPlayerData = () => {
          setImportedStats(loadFromStorage('snap_profile_stats', null));
          setWallet(loadFromStorage('snap_wallet', null));
          setRewards(loadFromStorage('snap_rewards', null));
          setRank(loadFromStorage('snap_rank', null));
          setTimeModel(loadFromStorage('snap_timemodel', null));
        };
        loadPlayerData();
        window.addEventListener('snap-data-updated', loadPlayerData);
        return () => window.removeEventListener('snap-data-updated', loadPlayerData);
      }, []);

      // Reset timer calculation
      const getTimeUntil = (resetTime) => {
        if (!resetTime) return null;
        const now = new Date();
        const reset = new Date(resetTime);
        const diff = reset.getTime() - now.getTime();
        if (diff <= 0) return 'Now!';
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        if (hours > 24) return `${Math.floor(hours / 24)}d ${hours % 24}h`;
        return `${hours}h ${minutes}m`;
      };

      const totalCards = uniqueCards.length;
      // Only count cards that exist in our database
      const ownedInDatabase = collection.owned.filter(name => uniqueCards.some(c => c.name === name)).length;
      const completionPercent = Math.min(100, Math.round((ownedInDatabase / totalCards) * 100));
      const today = new Date().toDateString();
      const todayMatches = matches.filter(m => new Date(m.timestamp).toDateString() === today);
      const todayCubes = todayMatches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);
      const totalWins = matches.filter(m => m.result === 'WIN').length;
      const totalGames = matches.length;
      const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      // Use imported stats if available, otherwise use local tracking
      const displayStats = importedStats ? {
        wins: importedStats.wins,
        losses: importedStats.losses,
        totalGames: importedStats.totalGames || (importedStats.wins + importedStats.losses),
        winRate: importedStats.winRate,
        hasImported: true,
        snapId: importedStats.snapId
      } : {
        wins: totalWins,
        losses: totalGames - totalWins,
        totalGames: totalGames,
        winRate: winRate,
        hasImported: false,
        snapId: null
      };

      const getStreak = () => {
        if (matches.length === 0) return { count: 0, type: 'none' };
        const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        const firstResult = sorted[0].result;
        let count = 0;
        for (const match of sorted) {
          if (match.result === firstResult) count++;
          else break;
        }
        return { count, type: firstResult };
      };
      const streak = getStreak();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAPAPOULOUS PRIME" />

          {/* Player OS: Wallet Widget */}
          {wallet && (
            <div className="stitch-card p-4 mb-4 border-l-4 border-cosmic-purple-text">
              <div className="flex items-center justify-between mb-2">
                <span className="stitch-label">Wallet</span>
                <span className="stitch-badge bg-mcu-gold/20 text-mcu-gold">Synced</span>
              </div>
              <div className="grid grid-cols-4 gap-2 text-center">
                <div>
                  <div className="text-lg font-bold text-blue-400">{(wallet.credits || 0).toLocaleString()}</div>
                  <div className="text-xs text-stitch-muted">Credits</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-yellow-400">{(wallet.gold || 0).toLocaleString()}</div>
                  <div className="text-xs text-stitch-muted">Gold</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-purple-400">{(wallet.tokens || 0).toLocaleString()}</div>
                  <div className="text-xs text-stitch-muted">Tokens</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-orange-400">{(wallet.keys || wallet.spotlightKeys || 0).toLocaleString()}</div>
                  <div className="text-xs text-stitch-muted">Keys</div>
                </div>
              </div>
            </div>
          )}

          {/* Player OS: Rank & Reset Timers */}
          {(rank || timeModel) && (
            <div className="grid grid-cols-2 gap-3 mb-4">
              {rank && (
                <div className="stitch-stat rank-glow border-l-4 border-series-3">
                  <div className="stitch-label">Rank</div>
                  <div className="text-2xl font-display font-bold text-white">{rank.tier}</div>
                  <div className="text-sm text-stitch-muted">Level {rank.currentRank}</div>
                </div>
              )}
              {timeModel && (
                <div className="stitch-stat border-l-4 border-cosmic-purple-text">
                  <div className="stitch-label">Resets</div>
                  <div className="text-sm text-cyan-400">Daily: {getTimeUntil(timeModel.dailyReset) || ''}</div>
                  <div className="text-sm text-cyan-300">Weekly: {getTimeUntil(timeModel.weeklyReset) || ''}</div>
                </div>
              )}
            </div>
          )}

          {/* Player OS: Pity Counters (Spotlight Oracle Preview) */}
          {rewards && (
            <div className="stitch-card p-4 mb-4 border-l-4 border-mcu-red">
              <div className="flex items-center justify-between mb-2">
                <span className="stitch-label">Pity Counters</span>
                {(rewards.isCloseToS4 || rewards.isCloseToS5 || rewards.isCloseToSpotlight) && (
                  <span className="text-xs px-2 py-0.5 bg-mcu-red/30 text-mcu-red rounded animate-pulse">Close!</span>
                )}
              </div>
              <div className="grid grid-cols-3 gap-2">
                <div className="text-center">
                  <div className="relative pt-1">
                    <div className="flex items-center justify-between mb-1">
                      <span className="text-xs text-stitch-muted">S4</span>
                      <span className="text-xs font-bold text-green-400">{rewards.pityCounters?.s4 || 0}/20</span>
                    </div>
                    <div className="w-full bg-[#1a1320] rounded-full h-2">
                      <div
                        className={`h-2 rounded-full ${rewards.isCloseToS4 ? 'bg-green-400' : 'bg-green-600'}`}
                        style={{ width: `${Math.min(100, ((rewards.pityCounters?.s4 || 0) / 20) * 100)}%` }}
                      ></div>
                    </div>
                  </div>
                </div>
                <div className="text-center">
                  <div className="relative pt-1">
                    <div className="flex items-center justify-between mb-1">
                      <span className="text-xs text-stitch-muted">S5</span>
                      <span className="text-xs font-bold text-purple-400">{rewards.pityCounters?.s5 || 0}/60</span>
                    </div>
                    <div className="w-full bg-[#1a1320] rounded-full h-2">
                      <div
                        className={`h-2 rounded-full ${rewards.isCloseToS5 ? 'bg-purple-400' : 'bg-purple-600'}`}
                        style={{ width: `${Math.min(100, ((rewards.pityCounters?.s5 || 0) / 60) * 100)}%` }}
                      ></div>
                    </div>
                  </div>
                </div>
                <div className="text-center">
                  <div className="relative pt-1">
                    <div className="flex items-center justify-between mb-1">
                      <span className="text-xs text-stitch-muted">Key</span>
                      <span className="text-xs font-bold text-orange-400">{rewards.pityCounters?.spotlightKey || 0}/4</span>
                    </div>
                    <div className="w-full bg-[#1a1320] rounded-full h-2">
                      <div
                        className={`h-2 rounded-full ${rewards.isCloseToSpotlight ? 'bg-orange-400' : 'bg-orange-600'}`}
                        style={{ width: `${Math.min(100, ((rewards.pityCounters?.spotlightKey || 0) / 4) * 100)}%` }}
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Lifetime Stats (from imported data) */}
          {displayStats.hasImported && (
            <div className="stitch-card p-4 mb-4 border-l-4 border-cosmic-purple-text">
              <div className="flex items-center justify-between mb-2">
                <span className="stitch-label">Lifetime Stats</span>
                <span className="stitch-badge">From Game</span>
              </div>
              <div className="grid grid-cols-4 gap-2 text-center">
                <div>
                  <div className="text-lg font-bold text-white">{displayStats.totalGames.toLocaleString()}</div>
                  <div className="text-xs text-stitch-muted">Games</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-stitch-green">{displayStats.wins.toLocaleString()}</div>
                  <div className="text-xs text-stitch-muted">Wins</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-red-400">{displayStats.losses.toLocaleString()}</div>
                  <div className="text-xs text-stitch-muted">Losses</div>
                </div>
                <div>
                  <div className="text-lg font-bold text-mcu-gold">{displayStats.winRate}%</div>
                  <div className="text-xs text-stitch-muted">Win Rate</div>
                </div>
              </div>
              {displayStats.snapId && (
                <div className="text-xs text-stitch-muted text-right mt-2">{displayStats.snapId}</div>
              )}
            </div>
          )}

          <div className="grid grid-cols-4 gap-3 mb-4">
            <div className="stitch-stat">
              <div className="stitch-label mb-1">Collection</div>
              <div className="text-2xl font-display font-bold text-white">{completionPercent}%</div>
              <div className="text-xs text-stitch-muted">{ownedInDatabase}/{totalCards}</div>
            </div>
            <div className="stitch-stat">
              <div className="stitch-label mb-1">Win Rate</div>
              <div className="text-2xl font-display font-bold text-white">{winRate}%</div>
              <div className="text-xs text-stitch-muted">{totalWins}/{totalGames}</div>
            </div>
            <div className="stitch-stat">
              <div className="stitch-label mb-1">Net Cubes</div>
              <div className={`text-2xl font-display font-bold ${netCubes >= 0 ? 'text-stitch-green' : 'text-red-500'}`}>
                {netCubes >= 0 ? '+' : ''}{netCubes}
              </div>
              <div className="text-xs text-stitch-muted">Today {todayCubes >= 0 ? '+' : ''}{todayCubes}</div>
            </div>
            <div className="stitch-stat">
              <div className="stitch-label mb-1">Streak</div>
              <div className={`text-2xl font-display font-bold ${streak.type === 'WIN' ? 'text-stitch-green' : streak.type === 'LOSS' ? 'text-red-500' : 'text-stitch-muted'}`}>
                {streak.count}{streak.type === 'WIN' ? 'W' : streak.type === 'LOSS' ? 'L' : '-'}
              </div>
              <div className="text-xs text-stitch-muted">Current</div>
            </div>
          </div>
          <div className="stitch-card p-5 mb-4">
            <div className="stitch-section-header">
              <span className="material-symbols-outlined" aria-hidden="true">bolt</span>
              Quick Match
            </div>
            <div className="mb-3" role="group" aria-label="Record win">
              <div className="text-sm text-stitch-green mb-2 font-bold" id="win-label">VICTORY</div>
              <div className="flex gap-2" role="group" aria-labelledby="win-label">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`win-${cubes}`} onClick={() => onQuickMatch('WIN', cubes)}
                    aria-label={`Record win of ${cubes} cube${cubes > 1 ? 's' : ''}`}
                    className="flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-xl transition-all active:scale-95">
                    +{cubes}
                  </button>
                ))}
              </div>
            </div>
            <div role="group" aria-label="Record loss">
              <div className="text-sm text-red-500 mb-2 font-bold" id="loss-label">DEFEAT</div>
              <div className="flex gap-2" role="group" aria-labelledby="loss-label">
                {[1, 2, 4, 8].map(cubes => (
                  <button key={`loss-${cubes}`} onClick={() => onQuickMatch('LOSS', cubes)}
                    aria-label={`Record loss of ${cubes} cube${cubes > 1 ? 's' : ''}`}
                    className="flex-1 bg-red-600 hover:bg-red-500 text-white font-bold py-3 rounded-xl transition-all active:scale-95">
                    -{cubes}
                  </button>
                ))}
              </div>
            </div>
          </div>
          <div className="stitch-card p-5">
            <div className="flex justify-between items-center mb-3">
              <div className="stitch-section-header mb-0">
                <span className="material-symbols-outlined" aria-hidden="true">history</span>
                Recent Matches
              </div>
              <button onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'history' }))} className="text-xs text-cosmic-purple-text hover:text-white transition-colors">View All &rarr;</button>
            </div>
            {matches.length === 0 ? (
              <p className="text-stitch-muted text-center py-4">No matches recorded yet</p>
            ) : (
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {matches.slice(-5).reverse().map(match => (
                  <div key={match.id} className={`stitch-list-item flex items-center justify-between border-l-4 ${
                    match.result === 'WIN' ? 'border-stitch-green' : 'border-red-500'
                  }`}>
                    <div className="flex items-center gap-3">
                      <span className={`stitch-badge ${match.result === 'WIN' ? 'bg-stitch-green/20 text-stitch-green' : 'bg-red-500/20 text-red-400'}`}>
                        {match.result === 'WIN' ? '+' : '-'}{match.cubes}
                      </span>
                      <span className={`text-sm font-bold ${match.result === 'WIN' ? 'text-stitch-green' : 'text-red-400'}`}>
                        {match.result === 'WIN' ? 'Victory' : 'Defeat'}
                      </span>
                    </div>
                    <span className="text-stitch-muted text-xs">{formatDate(match.timestamp)}</span>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    };

    // Match History Standalone View
    const MatchHistory = ({ matches }) => {
      const [expanded, setExpanded] = useState(null);
      const [filter, setFilter] = useState('all');

      const filteredMatches = useMemo(() => {
        const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        if (filter === 'wins') return sorted.filter(m => m.result === 'WIN');
        if (filter === 'losses') return sorted.filter(m => m.result === 'LOSS');
        return sorted;
      }, [matches, filter]);

      const todayStats = useMemo(() => {
        const today = new Date().toDateString();
        const todayMatches = matches.filter(m => new Date(m.timestamp).toDateString() === today);
        const net = todayMatches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);
        return { net, count: todayMatches.length };
      }, [matches]);

      const winRate = useMemo(() => {
        if (matches.length === 0) return 0;
        const wins = matches.filter(m => m.result === 'WIN').length;
        return Math.round((wins / matches.length) * 100);
      }, [matches]);

      const weekWinRate = useMemo(() => {
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        const weekMatches = matches.filter(m => new Date(m.timestamp) >= weekAgo);
        if (weekMatches.length === 0) return null;
        const wins = weekMatches.filter(m => m.result === 'WIN').length;
        return Math.round((wins / weekMatches.length) * 100);
      }, [matches]);

      const trendDiff = weekWinRate !== null ? weekWinRate - winRate : 0;

      const toggleExpand = (id) => {
        setExpanded(prev => prev === id ? null : id);
      };

      const snapLabel = (snapped) => {
        switch (snapped) {
          case 'PLAYER': return 'You Snapped';
          case 'OPPONENT': return 'Opp Snapped';
          case 'BOTH': return 'Both Snapped';
          default: return null;
        }
      };

      return (
        <div className="px-4 pb-20">
          <Header title="MATCH HISTORY" />

          {/* Stat Cards */}
          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="stitch-stat p-4">
              <div className="stitch-label mb-1">Today's Net</div>
              <div className={`text-3xl font-display font-bold ${todayStats.net >= 0 ? 'text-stitch-green' : 'text-red-500'}`}>
                {todayStats.net >= 0 ? '+' : ''}{todayStats.net}
              </div>
              <div className="text-xs text-stitch-muted">{todayStats.count} games played</div>
            </div>
            <div className="stitch-stat p-4">
              <div className="stitch-label mb-1">Win Rate</div>
              <div className="text-3xl font-display font-bold text-cosmic-purple-text">{winRate}%</div>
              <div className={`text-xs flex items-center gap-0.5 ${trendDiff >= 0 ? 'text-stitch-green' : 'text-red-400'}`}>
                {trendDiff !== 0 && (
                  <>
                    <span className="material-symbols-outlined" style={{ fontSize: '12px' }}>
                      {trendDiff > 0 ? 'trending_up' : 'trending_down'}
                    </span>
                    {trendDiff > 0 ? '+' : ''}{trendDiff}% 7d
                  </>
                )}
                {trendDiff === 0 && <span className="text-stitch-muted">Steady</span>}
              </div>
            </div>
          </div>
          <div className="stitch-card p-3 mb-4 flex items-center justify-between">
            <span className="stitch-label">Total Matches</span>
            <div className="flex items-center gap-3">
              <span className="text-lg font-display font-bold text-white">{matches.length}</span>
              <span className="text-xs text-stitch-muted">
                {matches.filter(m => m.result === 'WIN').length}W / {matches.filter(m => m.result === 'LOSS').length}L
              </span>
            </div>
          </div>

          {/* Filter Pills */}
          <div className="flex gap-2 mb-4">
            {['all', 'wins', 'losses'].map(f => (
              <button
                key={f}
                onClick={() => setFilter(f)}
                className={`stitch-pill ${filter === f ? 'active' : ''}`}
              >
                {f === 'all' ? 'All' : f === 'wins' ? 'Wins' : 'Losses'}
              </button>
            ))}
            <span className="ml-auto text-sm text-stitch-muted self-center">{filteredMatches.length} results</span>
          </div>

          {/* Match List */}
          {filteredMatches.length === 0 ? (
            <div className="stitch-card p-8 text-center">
              <span className="material-symbols-outlined text-4xl text-stitch-muted mb-2 block">history</span>
              <div className="text-stitch-muted">No matches recorded yet</div>
              <div className="text-stitch-muted/60 text-sm mt-1">Log matches from the Dashboard</div>
            </div>
          ) : (
            <div className="space-y-2">
              {filteredMatches.map(match => {
                const isWin = match.result === 'WIN';
                const isExpanded = expanded === match.id;
                const snap = snapLabel(match.snapped);

                return (
                  <button
                    key={match.id}
                    className={`w-full text-left stitch-list-item overflow-hidden border-l-4 transition-all cursor-pointer ${
                      isWin ? 'border-stitch-green' : 'border-red-500'
                    }`}
                    onClick={() => toggleExpand(match.id)}
                    aria-expanded={isExpanded}
                  >
                    {/* Main Row */}
                    <div className="flex items-center justify-between p-3">
                      <div className="flex items-center gap-3">
                        <span className={`stitch-badge text-xs uppercase tracking-wide ${
                          isWin
                            ? 'bg-stitch-green/20 text-stitch-green'
                            : 'bg-red-500/20 text-red-400'
                        }`}>
                          {isWin ? 'Victory' : 'Defeat'}
                        </span>
                        <span className={`text-lg font-display font-bold ${isWin ? 'text-stitch-green' : 'text-red-400'}`}>
                          {isWin ? '+' : '-'}{match.cubes}
                        </span>
                        {snap && (
                          <span className="text-xs px-1.5 py-0.5 rounded bg-[#ad2bee]/20 text-[#c75fff]">
                            {snap}
                          </span>
                        )}
                      </div>
                      <div className="flex items-center gap-2">
                        <span className="text-xs text-gray-500">{formatDate(match.timestamp)}</span>
                        <span className={`material-symbols-outlined text-gray-500 text-sm transition-transform ${isExpanded ? 'rotate-180' : ''}`}>
                          expand_more
                        </span>
                      </div>
                    </div>

                    {/* Expanded Details */}
                    {isExpanded && (
                      <div className="px-3 pb-3 pt-0 border-t border-[rgba(173,43,238,0.15)]">
                        <div className="grid grid-cols-2 gap-2 mt-2">
                          {match.opponent && (
                            <div>
                              <span className="text-gray-500 text-xs uppercase">Opponent</span>
                              <div className="text-sm text-white">{match.opponent}</div>
                            </div>
                          )}
                          {match.deck && (
                            <div>
                              <span className="text-gray-500 text-xs uppercase">Deck</span>
                              <div className="text-sm text-[#c75fff]">{match.deck}</div>
                            </div>
                          )}
                        </div>
                        {match.notes && (
                          <div className="mt-2">
                            <span className="text-gray-500 text-xs uppercase">Notes</span>
                            <div className="text-sm text-gray-300 mt-0.5">{match.notes}</div>
                          </div>
                        )}
                        {!match.opponent && !match.deck && !match.notes && (
                          <div className="text-gray-600 text-xs mt-2 italic">No additional details recorded</div>
                        )}
                      </div>
                    )}
                  </button>
                );
              })}
            </div>
          )}
        </div>
      );
    };

    // Card Substitution Utilities
    const findSubstitutes = (cardName, ownedCards, allCards) => {
      // Find the target card
      const targetCard = allCards.find(c => c.name.toLowerCase() === cardName.toLowerCase());
      if (!targetCard || !targetCard.tags || targetCard.tags.length === 0) {
        return [];
      }

      const targetTags = new Set(targetCard.tags);
      const ownedSet = new Set(ownedCards.map(c => c.toLowerCase()));

      // Find owned cards that share tags (excluding the target itself)
      const candidates = allCards
        .filter(c => {
          if (c.name.toLowerCase() === cardName.toLowerCase()) return false;
          if (!ownedSet.has(c.name.toLowerCase())) return false;
          if (!c.tags || c.tags.length === 0) return false;
          return c.tags.some(tag => targetTags.has(tag));
        })
        .map(c => {
          const matchingTags = c.tags.filter(tag => targetTags.has(tag));
          const costDiff = Math.abs(c.cost - targetCard.cost);
          return {
            name: c.name,
            cost: c.cost,
            power: c.power,
            matchingTags,
            matchCount: matchingTags.length,
            costDiff,
            // Score: prioritize tag matches, then similar cost
            score: matchingTags.length * 10 - costDiff
          };
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);

      return candidates.map(c => ({
        name: c.name,
        cost: c.cost,
        power: c.power,
        reason: `Shares ${c.matchingTags.join(', ')} tag${c.matchingTags.length > 1 ? 's' : ''}${c.costDiff === 0 ? ' (same cost)' : ''}`
      }));
    };

    const getSubstitutionContext = (userMessage, collection, allCards) => {
      if (!collection || !collection.owned || !allCards || allCards.length === 0) {
        return '';
      }

      const ownedSet = new Set(collection.owned.map(c => c.toLowerCase()));
      const messageLower = userMessage.toLowerCase();

      // Find card names mentioned in the message that user doesn't own
      const mentionedMissing = allCards
        .filter(c => {
          const nameLower = c.name.toLowerCase();
          return messageLower.includes(nameLower) && !ownedSet.has(nameLower);
        })
        .slice(0, 3); // Limit to 3 cards to avoid huge context

      if (mentionedMissing.length === 0) {
        return '';
      }

      let context = '\n\nSUBSTITUTION SUGGESTIONS (user is missing these cards):';

      for (const card of mentionedMissing) {
        const subs = findSubstitutes(card.name, collection.owned, allCards);
        context += `\n\n${card.name} (${card.cost}-cost, ${card.power} power):`;
        if (subs.length > 0) {
          context += '\nOwned alternatives:';
          for (const sub of subs) {
            context += `\n- ${sub.name} (${sub.cost}/${sub.power}): ${sub.reason}`;
          }
        } else {
          context += '\nNo direct substitutes found in collection.';
        }
      }

      return context;
    };

    // AI Chat Component
    const AIChat = ({ collection, matches, aiConfig, setActiveTab }) => {
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);
      const messagesEndRef = useRef(null);

      const scrollToBottom = () => {
        if (messagesEndRef.current) messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
      };

      useEffect(() => {
        scrollToBottom();
      }, [messages]);

      useEffect(() => {
        if (messages.length === 0) {
          setMessages([{
            id: generateId(),
            role: 'assistant',
            content: "Ready to climb the ranks? I'm Snapapoulous, your Marvel Snap tactical advisor. Ask me about deck building, meta matchups, snap decisions, or anything else about the game!"
          }]);
        }
      }, []);

      const isConfigured = () => {
        if (!aiConfig.provider) return false;
        if (aiConfig.provider === 'gemini-oauth') return isGoogleTokenValid();
        if (aiConfig.provider === 'local') return !!aiConfig.localEndpoint;
        return !!(aiConfig.apiKeys && aiConfig.apiKeys[aiConfig.provider]);
      };

      const sendMessage = async () => {
        if (!input.trim() || isLoading) return;
        if (!isConfigured()) {
          setError('Please configure an AI provider in Settings first.');
          return;
        }

        const userMessage = { id: generateId(), role: 'user', content: input.trim() };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);
        setError(null);

        try {
          const systemPrompt = buildSystemPrompt(collection, matches);
          // Add substitution context if user mentions cards they don't own
          const substitutionContext = getSubstitutionContext(userMessage.content, collection, uniqueCards);
          const enhancedSystemPrompt = systemPrompt + substitutionContext;
          const apiMessages = [
            { role: 'system', content: enhancedSystemPrompt },
            ...messages.filter(m => m.role !== 'assistant' || messages.indexOf(m) > 0).map(m => ({
              role: m.role, content: m.content
            })),
            { role: 'user', content: userMessage.content }
          ];

          let response;
          const model = aiConfig.model || (AIProviders[aiConfig.provider] && AIProviders[aiConfig.provider].defaultModel);

          switch (aiConfig.provider) {
            case 'gemini-oauth':
              // Pass full messages - callGeminiOAuth handles system instruction extraction
              response = await callGeminiOAuth(apiMessages, model);
              break;
            case 'gemini':
              // Pass full messages - callGeminiAPIKey handles system instruction extraction
              response = await callGeminiAPIKey(apiMessages, model, aiConfig.apiKeys && aiConfig.apiKeys.gemini);
              break;
            case 'groq':
              response = await callGroq(apiMessages, model, aiConfig.apiKeys && aiConfig.apiKeys.groq);
              break;
            case 'claude':
              response = await callClaude(apiMessages, model, aiConfig.apiKeys && aiConfig.apiKeys.claude);
              break;
            case 'openai':
              response = await callOpenAI(apiMessages, model, aiConfig.apiKeys && aiConfig.apiKeys.openai);
              break;
            case 'local':
              response = await callLocal(apiMessages, model, aiConfig.localEndpoint);
              break;
            default:
              throw new Error('Unknown provider');
          }

          setMessages(prev => [...prev, {
            id: generateId(),
            role: 'assistant',
            content: response
          }]);
        } catch (err) {
          setError(err.message || 'Failed to get response');
          console.error('AI error:', err);
        } finally {
          setIsLoading(false);
        }
      };

      const quickPrompts = [
        "Analyze my win rate",
        "Best deck for climbing?",
        "When should I snap?",
        "Counter Destroy decks"
      ];

      return (
        <div className="flex flex-col h-[calc(100vh-4rem)] pb-16">
          <Header title="SNAPAPOULOUS AI" />

          {!isConfigured() && (
            <div className="mx-4 mb-4 bg-yellow-900/50 border border-yellow-600 rounded-lg p-4">
              <p className="text-yellow-200 text-sm mb-2">AI not configured yet!</p>
              <button onClick={() => setActiveTab('settings')}
                className="bg-mcu-gold text-black px-4 py-2 rounded font-medium hover:bg-yellow-400">
                Configure AI Provider
              </button>
            </div>
          )}

          <div className="flex-1 overflow-y-auto px-4 space-y-4">
            {messages.map(msg => (
              <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                <div className={`max-w-[85%] p-3 chat-bubble ${
                  msg.role === 'user'
                    ? 'bg-mcu-blue text-white chat-bubble-user'
                    : 'bg-[#1a1320] text-white chat-bubble-ai'
                }`}>
                  <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                </div>
              </div>
            ))}

            {isLoading && (
              <div className="flex justify-start">
                <div className="bg-[#1a1320] p-4 rounded-lg chat-bubble chat-bubble-ai">
                  <div className="flex gap-1">
                    <span className="w-2 h-2 bg-mcu-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-mcu-red rounded-full typing-dot"></span>
                    <span className="w-2 h-2 bg-mcu-red rounded-full typing-dot"></span>
                  </div>
                </div>
              </div>
            )}

            {error && (
              <div className="bg-red-900/50 border border-red-500 rounded-lg p-3">
                <p className="text-red-300 text-sm">{error}</p>
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>

          {messages.length <= 1 && (
            <div className="px-4 py-2">
              <div className="flex flex-wrap gap-2">
                {quickPrompts.map(prompt => (
                  <button key={prompt} onClick={() => setInput(prompt)}
                    className="bg-[#1a1320] text-gray-300 text-xs px-4 py-2 rounded-full hover:bg-[#2b1933] touch-target-sm">
                    {prompt}
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="p-4 bg-gray-900 border-t border-[rgba(173,43,238,0.2)]">
            <div className="flex gap-2">
              <input type="text" value={input} onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && sendMessage()}
                placeholder="Ask Snapapoulous..."
                disabled={isLoading}
                className="flex-1 bg-[#120818] text-white rounded-lg px-4 py-3 border-2 border-[rgba(173,43,238,0.2)] focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20 disabled:opacity-50"
              />
              <button onClick={sendMessage} disabled={isLoading || !input.trim()}
                className="bg-mcu-blue text-white px-6 py-3 rounded-lg font-display font-medium hover:shadow-glow-blue transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed shadow-glass">
                Send
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Collection Component - Player-Centric: Shows YOUR cards, YOUR stats
    const Collection = ({ collection, setCollection }) => {
      const [search, setSearch] = useState('');
      const [seriesFilter, setSeriesFilter] = useState('all');
      const [viewMode, setViewMode] = useState('owned'); // 'owned' (default) or 'browse' (add cards)
      const [selectedCard, setSelectedCard] = useState(null);
      const [confirmDialog, setConfirmDialog] = useState({ isOpen: false, action: null });

      const handleClearAll = useCallback(() => {
        setConfirmDialog({
          isOpen: true,
          action: 'clearCollection'
        });
      }, []);

      const confirmClearCollection = useCallback(() => {
        setCollection({ owned: [], lastUpdated: new Date().toISOString() });
        setConfirmDialog({ isOpen: false, action: null });
      }, [setCollection]);

      // Get owned cards with full card data from database
      const ownedCards = useMemo(() => {
        const ownedSet = new Set(collection.owned || []);
        return uniqueCards.filter(card => ownedSet.has(card.name));
      }, [collection.owned]);

      // Calculate pool stats based on YOUR owned cards (aggregates internal series to player-facing pools)
      const poolStats = useMemo(() => {
        const stats = {};
        const ownedSet = new Set(collection.owned || []);

        // Initialize stats for player-facing pools
        const pools = ['Pool 1', 'Pool 2', 'Pool 3', 'Pool 4', 'Pool 5', 'Spotlight'];
        pools.forEach(pool => {
          stats[pool] = { owned: 0, total: 0, percent: 0, color: 'series-1' };
        });

        // Map pool to color class
        const poolColors = {
          'Pool 1': 'series-1',
          'Pool 2': 'series-4',
          'Pool 3': 'series-6',
          'Pool 4': 'series-7',
          'Pool 5': 'series-8',
          'Spotlight': 'series-9'
        };
        pools.forEach(pool => { stats[pool].color = poolColors[pool]; });

        uniqueCards.forEach(card => {
          const series = card.series;
          if (series > 0) {
            const poolName = getSeriesDisplayName(series);
            if (stats[poolName]) {
              stats[poolName].total++;
              if (ownedSet.has(card.name)) {
                stats[poolName].owned++;
              }
            }
          }
        });

        // Calculate percentages
        Object.keys(stats).forEach(pool => {
          stats[pool].percent = stats[pool].total > 0 ? Math.round((stats[pool].owned / stats[pool].total) * 100) : 0;
        });

        // Only return pools that have cards
        return Object.fromEntries(Object.entries(stats).filter(([_, v]) => v.total > 0));
      }, [collection.owned]);

      // Legacy seriesStats for filtering (keep internal series numbers for filtering)
      const seriesStats = useMemo(() => {
        const stats = {};
        const ownedSet = new Set(collection.owned || []);

        getAvailableSeries().forEach(s => {
          stats[s] = { owned: 0, total: 0, percent: 0 };
        });

        uniqueCards.forEach(card => {
          const series = card.series;
          if (series > 0 && stats[series]) {
            stats[series].total++;
            if (ownedSet.has(card.name)) {
              stats[series].owned++;
            }
          }
        });

        Object.keys(stats).forEach(s => {
          stats[s].percent = stats[s].total > 0 ? Math.round((stats[s].owned / stats[s].total) * 100) : 0;
        });

        return stats;
      }, [collection.owned]);

      // Filter cards based on view mode and filters
      const filteredCards = useMemo(() => {
        let cards;
        if (viewMode === 'owned') {
          // Show only YOUR cards
          cards = ownedCards;
        } else {
          // Browse mode: show cards you DON'T own (for adding)
          const ownedSet = new Set(collection.owned || []);
          cards = uniqueCards.filter(card => !ownedSet.has(card.name));
        }

        // Apply search filter
        if (search) {
          cards = cards.filter(card => card.name.toLowerCase().includes(search.toLowerCase()));
        }

        // Apply series filter
        if (seriesFilter !== 'all') {
          cards = cards.filter(card => card.series === parseInt(seriesFilter));
        }

        return cards;
      }, [viewMode, ownedCards, collection.owned, search, seriesFilter]);

      const toggleCard = (cardName) => {
        setCollection(prev => {
          const isOwned = prev.owned.includes(cardName);
          return {
            owned: isOwned ? prev.owned.filter(c => c !== cardName) : [...prev.owned, cardName],
            lastUpdated: new Date().toISOString()
          };
        });
      };

      // Series dropdown options - in 'owned' mode, only show series you have cards in
      const availableSeries = useMemo(() => {
        if (viewMode === 'browse') {
          return getAvailableSeries(); // All series when browsing
        }
        // In owned mode, only show series where you own at least 1 card
        const ownedSeries = new Set(ownedCards.map(c => c.series));
        return getAvailableSeries().filter(s => ownedSeries.has(s));
      }, [viewMode, ownedCards]);

      return (
        <div className="px-4 pb-20">
          <Header title="MY COLLECTION" />

          {/* Pool Completion Bars - YOUR progress per pool */}
          <div className="stitch-card p-5 mb-4">
            <div className="stitch-section-header">
              <span className="material-symbols-outlined" aria-hidden="true">pie_chart</span>
              Pool Completion
            </div>
            <div className="space-y-3">
              {Object.entries(poolStats).map(([poolName, stats]) => {
                const colorClasses = {
                  'series-1': 'bg-series-1',
                  'series-4': 'bg-series-4',
                  'series-6': 'bg-series-6',
                  'series-7': 'bg-series-7',
                  'series-8': 'bg-series-8',
                  'series-9': 'bg-series-9'
                };
                const bgClass = colorClasses[stats.color] || 'bg-series-6';
                return (
                  <div key={poolName} className="flex items-center gap-2">
                    <span className={`w-16 h-6 rounded-full text-xs font-bold flex items-center justify-center text-white ${bgClass}`}>{poolName === 'Spotlight' ? '' : poolName.replace('Pool ', 'P')}</span>
                    <div className="flex-1 stitch-progress">
                      <div className={`stitch-progress-fill ${bgClass}`} style={{ width: `${stats.percent}%` }} />
                    </div>
                    <span className="text-stitch-muted text-xs w-20 text-right">{stats.owned}/{stats.total} ({stats.percent}%)</span>
                  </div>
                );
              })}
            </div>
            <div className="text-center text-mcu-gold font-bold mt-3 text-sm">
              {ownedCards.length} cards owned
            </div>
          </div>

          {/* View Mode Toggle & Filters */}
          <div className="mb-4">
            {/* View Mode Pills */}
            <div className="flex gap-2 mb-3">
              <button
                onClick={() => setViewMode('owned')}
                className={`stitch-pill flex-1 justify-center ${viewMode === 'owned' ? 'active' : ''}`}>
                My Cards ({ownedCards.length})
              </button>
              <button
                onClick={() => setViewMode('browse')}
                className={`stitch-pill flex-1 justify-center ${viewMode === 'browse' ? 'active' : ''}`}>
                + Add Cards
              </button>
            </div>

            <input type="text" placeholder={viewMode === 'owned' ? "Search your cards..." : "Search cards to add..."} value={search}
              onChange={(e) => setSearch(e.target.value)}
              aria-label="Search cards"
              className="w-full bg-stitch-accent text-white rounded-xl px-4 py-2.5 mb-3 border border-stitch-border focus:border-cosmic-purple-text focus:outline-none focus:ring-2 focus:ring-cosmic-purple/20 placeholder-stitch-muted" />

            <div className="flex gap-2">
              <select value={seriesFilter} onChange={(e) => setSeriesFilter(e.target.value)}
                className="flex-1 bg-stitch-accent text-white rounded-xl px-3 py-2.5 border border-stitch-border focus:border-cosmic-purple-text focus:outline-none">
                <option value="all">{viewMode === 'owned' ? 'All My Pools' : 'All Pools'}</option>
                {availableSeries.map(s => (
                  <option key={s} value={s}>{getSeriesDisplayName(s)} {viewMode === 'owned' ? `(${seriesStats[s]?.owned || 0})` : ''}</option>
                ))}
              </select>
              {viewMode === 'owned' && (
                <button onClick={handleClearAll}
                  className="bg-red-600 text-white text-xs px-3 py-2.5 rounded-xl hover:opacity-80">Clear All</button>
              )}
            </div>
          </div>

          {/* Card Grid with Art */}
          <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
            {filteredCards.map(card => {
              const isOwned = collection.owned.includes(card.name);
              const artUrl = getCardArtUrl(card);
              return (
                <div key={card.name} className={`relative aspect-[3/4] rounded-xl border-2 overflow-hidden transition-all card-hover ${getSeriesBorderClass(card.series)} ${
                    isOwned ? 'border-opacity-100' : 'border-opacity-40 opacity-50 grayscale'
                  }`}>
                  {/* Card Art Background */}
                  <div className="absolute inset-0 card-art card-art-fallback" style={{ backgroundImage: `url(${artUrl})` }} />
                  {/* Gradient overlay for text readability */}
                  <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent" />

                  {/* Cost badge - top left */}
                  <div className="absolute top-1.5 left-1.5 w-7 h-7 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold text-white shadow-lg z-10">{card.cost}</div>
                  {/* Power badge - top right */}
                  <div className="absolute top-1.5 right-1.5 w-7 h-7 bg-orange-500 rounded-full flex items-center justify-center text-xs font-bold text-white shadow-lg z-10">{card.power}</div>

                  {/* Card name - bottom */}
                  <div className="absolute bottom-0 left-0 right-0 p-2 z-10">
                    <div className="text-sm font-bold text-white truncate drop-shadow-lg">{card.name}</div>
                  </div>

                  {/* Owned checkmark */}
                  {isOwned && viewMode === 'browse' && (
                    <div className="absolute top-1 right-1 w-6 h-6 bg-stitch-green rounded-full flex items-center justify-center z-20">
                      <span className="text-white text-xs font-bold"></span>
                    </div>
                  )}

                  {/* Unowned overlay in browse mode */}
                  {!isOwned && viewMode === 'browse' && (
                    <>
                      <div className="absolute inset-0 flex items-center justify-center z-10">
                        <span className="material-symbols-outlined text-white/60 text-3xl" aria-hidden="true">lock</span>
                      </div>
                      <div className="absolute top-1 right-1 w-6 h-6 bg-cosmic-purple rounded-full flex items-center justify-center z-20">
                        <span className="text-white text-xs font-bold">+</span>
                      </div>
                    </>
                  )}

                  {/* Click target */}
                  <button onClick={() => toggleCard(card.name)} className="absolute inset-0 z-10"
                    aria-pressed={isOwned}
                    aria-label={`${card.name}, ${card.cost} cost, ${card.power} power, ${isOwned ? 'owned' : 'not owned'}`} />

                  {/* Info button */}
                  <button onClick={(e) => { e.stopPropagation(); setSelectedCard(card); }}
                    className="absolute bottom-1.5 right-1.5 w-7 h-7 bg-black/60 hover:bg-cosmic-purple rounded-full flex items-center justify-center text-xs text-white z-20"
                    title="View card details">
                    <span className="material-symbols-outlined" style={{fontSize: '16px'}}>info</span>
                  </button>
                </div>
              );
            })}
          </div>
          {filteredCards.length === 0 && (
            <div className="text-center text-stitch-muted py-8">
              {viewMode === 'owned'
                ? (collection.owned.length === 0
                    ? 'No cards in your collection yet. Use "+ Add Cards" or import your game files!'
                    : 'No cards match your filters')
                : 'No more cards to add - you own them all!'}
            </div>
          )}

          {/* Card Detail Modal */}
          {selectedCard && (
            <div className="fixed inset-0 bg-black/85 z-50 flex items-center justify-center p-4" onClick={() => setSelectedCard(null)}>
              <div className="stitch-card max-w-sm w-full overflow-hidden" onClick={e => e.stopPropagation()}>
                {/* Card Art Header */}
                <div className="relative aspect-[3/4] max-h-64 overflow-hidden">
                  <div className="absolute inset-0 card-art" style={{ backgroundImage: `url(${getCardArtUrl(selectedCard)})` }} />
                  <div className="absolute inset-0 bg-gradient-to-t from-stitch-card via-transparent to-transparent" />
                  <button onClick={() => setSelectedCard(null)}
                    className="absolute top-3 right-3 w-8 h-8 bg-black/60 rounded-full flex items-center justify-center text-white hover:bg-black/80 z-10">
                    <span className="material-symbols-outlined" style={{fontSize: '20px'}}>close</span>
                  </button>
                  {/* Cost/Power badges on art */}
                  <div className="absolute top-3 left-3 w-10 h-10 bg-blue-600 rounded-full flex items-center justify-center text-lg font-bold text-white shadow-lg">{selectedCard.cost}</div>
                  <div className="absolute bottom-3 right-3 w-10 h-10 bg-orange-500 rounded-full flex items-center justify-center text-lg font-bold text-white shadow-lg">{selectedCard.power}</div>
                </div>
                {/* Card Info */}
                <div className="p-5 -mt-4 relative z-10">
                  <h3 className="text-xl font-display font-bold text-white mb-1">{selectedCard.name}</h3>
                  <div className="flex gap-2 mb-3">
                    <span className={`stitch-badge ${getSeriesColorClass(selectedCard.series)}`}>
                      {getSeriesDisplayName(selectedCard.series)}
                    </span>
                    {selectedCard.ability && selectedCard.ability.startsWith('Ongoing') && (
                      <span className="stitch-badge bg-blue-500/20 text-blue-400">Ongoing</span>
                    )}
                    {selectedCard.ability && selectedCard.ability.startsWith('On Reveal') && (
                      <span className="stitch-badge bg-yellow-500/20 text-yellow-400">On Reveal</span>
                    )}
                  </div>
                  <div className="bg-stitch-accent rounded-xl p-4 mb-4">
                    <p className="text-gray-300 text-sm leading-relaxed">{selectedCard.ability || 'No ability text available.'}</p>
                  </div>
                  <button onClick={() => { toggleCard(selectedCard.name); setSelectedCard(null); }}
                    className={`w-full py-3 rounded-xl font-bold transition-all ${
                      collection.owned.includes(selectedCard.name)
                        ? 'bg-red-600 hover:bg-red-700 text-white'
                        : 'bg-stitch-green hover:opacity-90 text-white'
                    }`}>
                    {collection.owned.includes(selectedCard.name) ? 'Remove from Collection' : 'Add to Collection'}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Clear Collection Confirmation Dialog */}
          <ConfirmDialog
            isOpen={confirmDialog.isOpen && confirmDialog.action === 'clearCollection'}
            title="Clear Collection"
            message="Are you sure you want to clear your entire collection? This cannot be undone."
            confirmText="Clear All"
            cancelText="Keep Cards"
            danger={true}
            onConfirm={confirmClearCollection}
            onCancel={() => setConfirmDialog({ isOpen: false, action: null })}
          />
        </div>
      );
    };

    // ==================== DECKS COMPONENT ====================
    const Decks = ({ decks, setDecks, collection }) => {
      const [view, setView] = useState('list'); // list, create, edit, import
      const [editingDeck, setEditingDeck] = useState(null);
      const [deckName, setDeckName] = useState('');
      const [selectedCards, setSelectedCards] = useState([]);
      const [importCode, setImportCode] = useState('');
      const [importUrl, setImportUrl] = useState('');
      const [importError, setImportError] = useState('');
      const [searchCard, setSearchCard] = useState('');
      const [seriesFilter, setSeriesFilter] = useState('all');
      const [deckToDelete, setDeckToDelete] = useState(null);

      // Memoized card lookup map to avoid repeated .find() in deck slot render
      const cardLookup = useMemo(() => {
        const map = new Map();
        uniqueCards.forEach(c => map.set(c.name, c));
        return map;
      }, [uniqueCards]);

      const startNewDeck = () => {
        setDeckName('');
        setSelectedCards([]);
        setEditingDeck(null);
        setView('create');
      };

      const editDeck = (deck) => {
        setDeckName(deck.name);
        setSelectedCards([...deck.cards]);
        setEditingDeck(deck.id);
        setView('create');
      };

      const toggleCardInDeck = (cardName) => {
        if (selectedCards.includes(cardName)) {
          setSelectedCards(prev => prev.filter(c => c !== cardName));
        } else if (selectedCards.length < 12) {
          setSelectedCards(prev => [...prev, cardName]);
        }
      };

      const saveDeck = () => {
        if (!deckName.trim() || selectedCards.length !== 12) {
          alert('Please name your deck and select exactly 12 cards.');
          return;
        }
        const newDeck = {
          id: editingDeck || generateId(),
          name: deckName.trim(),
          cards: selectedCards,
          createdAt: editingDeck ? decks.find(d => d.id === editingDeck)?.createdAt : new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        if (editingDeck) {
          setDecks(prev => prev.map(d => d.id === editingDeck ? newDeck : d));
        } else {
          setDecks(prev => [...prev, newDeck]);
        }
        setView('list');
        setEditingDeck(null);
      };

      const deleteDeck = useCallback((id) => {
        setDeckToDelete(id);
      }, []);

      const confirmDeleteDeck = useCallback(() => {
        if (deckToDelete) {
          setDecks(prev => prev.filter(d => d.id !== deckToDelete));
          setDeckToDelete(null);
        }
      }, [deckToDelete, setDecks]);

      // Decode deck code (base64 encoded card list)
      // Game uses abbreviated defIds like "Fntmx8" for Fantomex
      // Accepts full deck paste (with # comments) or just the base64 string
      const decodeDeckCode = async (input) => {
        try {
          // Ensure card data is loaded before matching (fallback data doesn't have defId)
          const cardData = await CardDataLoader.load();

          // Extract base64 line from full deck paste (line with 20+ alphanumeric chars, no spaces or #)
          const lines = input.trim().split('\n');
          const base64Line = lines.find(line => /^[A-Za-z0-9+/=]{20,}$/.test(line.trim()));
          const code = base64Line ? base64Line.trim() : input.trim();

          const decoded = atob(code);
          const cardCodes = decoded.split(',').map(s => s.trim()).filter(Boolean);
          if (cardCodes.length !== 12) throw new Error(`Deck must have 12 cards (found ${cardCodes.length})`);

          // Helper to match abbreviated code to card defId
          const matchCard = (abbrev) => {
            // Strip trailing numbers/letters (variant suffixes)
            const base = abbrev.replace(/[0-9A-Z]$/, '').toLowerCase();

            // Try exact defId match first (for simple names like "Blade")
            let match = cardData.find(c => c.defId?.toLowerCase() === abbrev.toLowerCase());
            if (match) return match.name;

            // Try matching by consonant pattern
            // Game abbreviations remove ALL vowels including 'y' (e.g., Lady -> Ld)
            const toConsonants = (s) => s.toLowerCase().replace(/[aeiouy\s\-\'\.]/g, '');
            const abbrConsonants = toConsonants(base);

            // Find best match by comparing consonant patterns
            match = cardData.find(c => {
              const defConsonants = toConsonants(c.defId || c.name);
              return defConsonants.startsWith(abbrConsonants) || abbrConsonants.startsWith(defConsonants);
            });

            if (match) return match.name;

            // Fallback: try partial name match
            match = cardData.find(c =>
              c.name.toLowerCase().replace(/[^a-z]/g, '').startsWith(base.replace(/[^a-z]/g, ''))
            );

            if (match) return match.name;
            throw new Error(`Unknown card code: ${abbrev}`);
          };

          return cardCodes.map(matchCard);
        } catch (e) {
          throw new Error('Invalid deck code: ' + e.message);
        }
      };

      // Import from MarvelSnapZone URL
      const importFromUrl = async () => {
        setImportError('');
        try {
          // Extract deck name and cards from URL
          // URL format: https://marvelsnapzone.com/decks/deck-name/
          const url = importUrl.trim();
          if (!url.includes('marvelsnapzone.com') && !url.includes('untapped.gg')) {
            throw new Error('Please enter a MarvelSnapZone or Untapped.gg deck URL');
          }

          // For demonstration, we'll parse the URL manually
          // In production, you'd fetch the page and parse the card list
          setImportError('URL import coming soon! For now, please use a deck code.');
        } catch (e) {
          setImportError(e.message);
        }
      };

      const importFromCode = async () => {
        setImportError('');
        try {
          const cards = await decodeDeckCode(importCode);
          setSelectedCards(cards);
          setDeckName('Imported Deck');
          setView('create');
        } catch (e) {
          setImportError(e.message);
        }
      };

      // Calculate deck stats
      const getDeckStats = (cardNames) => {
        const cards = cardNames.map(name => uniqueCards.find(c => c.name === name)).filter(Boolean);
        const avgCost = cards.length > 0 ? (cards.reduce((sum, c) => sum + c.cost, 0) / cards.length).toFixed(1) : 0;
        const totalPower = cards.reduce((sum, c) => sum + c.power, 0);
        const ownedCount = cardNames.filter(name => collection.owned.includes(name)).length;
        const curve = [0, 0, 0, 0, 0, 0, 0]; // 0-6+ cost
        cards.forEach(c => { curve[Math.min(c.cost, 6)]++; });
        return { avgCost, totalPower, ownedCount, curve, cards };
      };

      const filteredCards = useMemo(() => {
        return uniqueCards.filter(c => {
          if (searchCard && !c.name.toLowerCase().includes(searchCard.toLowerCase())) return false;
          if (seriesFilter !== 'all' && c.series !== parseInt(seriesFilter)) return false;
          return true;
        });
      }, [searchCard, seriesFilter]);

      // List View
      if (view === 'list') {
        return (
          <div className="px-4 pb-20">
            <Header title="MY DECKS" />
            <div className="flex gap-2 mb-4">
              <button onClick={startNewDeck}
                className="flex-1 bg-mcu-red text-white py-3 rounded-lg font-display font-semibold hover:shadow-glow-red transition-all duration-200">
                + Create Deck
              </button>
              <button onClick={() => setView('import')}
                className="flex-1 bg-series-3 text-white py-3 rounded-lg font-display font-semibold hover:shadow-glow-blue transition-all duration-200">
                Import Deck
              </button>
            </div>
            {decks.length === 0 ? (
              <div className="text-center text-stitch-muted py-12">
                <p className="text-lg mb-2">No decks yet</p>
                <p className="text-sm">Create a deck or import one from MarvelSnapZone</p>
              </div>
            ) : (
              <div className="space-y-3">
                {decks.map(deck => {
                  const stats = getDeckStats(deck.cards);
                  return (
                    <div key={deck.id} className="stitch-card p-5">
                      <div className="flex justify-between items-start mb-2">
                        <h3 className="text-lg font-display font-semibold text-white">{deck.name}</h3>
                        <div className="flex gap-2">
                          <button onClick={() => editDeck(deck)} className="text-mcu-blue hover:text-white text-sm">Edit</button>
                          <button onClick={() => deleteDeck(deck.id)} className="text-red-500 hover:text-red-400 text-sm">Delete</button>
                        </div>
                      </div>
                      <div className="flex gap-4 text-sm text-stitch-muted mb-3">
                        <span>Avg Cost: <span className="text-mcu-blue">{stats.avgCost}</span></span>
                        <span>Total Power: <span className="text-mcu-red">{stats.totalPower}</span></span>
                        <span>Owned: <span className={stats.ownedCount === 12 ? 'text-green-500' : 'text-yellow-500'}>{stats.ownedCount}/12</span></span>
                      </div>
                      {/* Mana Curve */}
                      <div className="flex gap-1 items-end h-8 mb-3">
                        {stats.curve.map((count, cost) => (
                          <div key={cost} className="flex-1 flex flex-col items-center">
                            <div className="bg-mcu-blue w-full rounded-t" style={{ height: count * 8 + 'px' }}></div>
                            <span className="text-xs text-gray-500">{cost}{cost === 6 ? '+' : ''}</span>
                          </div>
                        ))}
                      </div>
                      {/* Card Pills */}
                      <div className="flex flex-wrap gap-1">
                        {deck.cards.map(cardName => {
                          const card = uniqueCards.find(c => c.name === cardName);
                          const owned = collection.owned.includes(cardName);
                          return (
                            <span key={cardName} className={`text-xs px-2 py-1 rounded-full ${owned ? 'bg-[#1c1022] text-white' : 'bg-red-900 text-red-300'}`}>
                              {card?.cost || '?'}/{cardName}
                            </span>
                          );
                        })}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}

            {/* Delete Deck Confirmation Dialog */}
            <ConfirmDialog
              isOpen={!!deckToDelete}
              title="Delete Deck"
              message="Are you sure you want to delete this deck? This cannot be undone."
              confirmText="Delete"
              cancelText="Keep Deck"
              danger={true}
              onConfirm={confirmDeleteDeck}
              onCancel={() => setDeckToDelete(null)}
            />
          </div>
        );
      }

      // Import View
      if (view === 'import') {
        return (
          <div className="px-4 pb-20">
            <Header title="IMPORT DECK" />
            <button onClick={() => setView('list')} className="text-mcu-blue mb-4">&larr; Back to Decks</button>

            <div className="stitch-card p-5 mb-4">
              <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Import from Deck Code</h3>
              <p className="text-stitch-muted text-sm mb-2">Paste the full deck export from the game (includes # comments and code)</p>
              <textarea placeholder="# (1) Iron Man&#10;# (2) Hulk&#10;...&#10;base64code&#10;#"
                value={importCode} onChange={(e) => setImportCode(e.target.value)}
                rows={6}
                className="w-full bg-[#1a1320] text-white rounded px-3 py-2 mb-2 border-2 border-[rgba(173,43,238,0.3)] focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20 font-mono text-sm" />
              <button onClick={importFromCode}
                className="w-full bg-mcu-blue text-white py-2 rounded-lg hover:shadow-glow-blue transition-all duration-200">
                Import from Code
              </button>
            </div>

            <div className="stitch-card p-5">
              <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Import from URL</h3>
              <p className="text-stitch-muted text-sm mb-2">Paste a MarvelSnapZone or Untapped.gg deck URL</p>
              <input type="text" placeholder="https://marvelsnapzone.com/decks/..."
                value={importUrl} onChange={(e) => setImportUrl(e.target.value)}
                aria-label="Deck URL"
                className="w-full bg-[#1a1320] text-white rounded px-3 py-2 mb-2 border-2 border-[rgba(173,43,238,0.3)] focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20" />
              <button onClick={importFromUrl}
                className="w-full bg-series-3 text-white py-2 rounded hover:opacity-80">
                Import from URL
              </button>
            </div>

            {importError && (
              <div className="mt-4 bg-red-900 text-red-300 p-3 rounded-lg">{importError}</div>
            )}
          </div>
        );
      }

      // Create/Edit View
      return (
        <div className="px-4 pb-20">
          <Header title={editingDeck ? 'EDIT DECK' : 'CREATE DECK'} />
          <button onClick={() => setView('list')} className="text-mcu-blue mb-4">&larr; Back to Decks</button>

          <div className="stitch-card p-5 mb-4">
            <input type="text" placeholder="Deck name..."
              value={deckName} onChange={(e) => setDeckName(e.target.value)}
              aria-label="Deck name"
              className="w-full bg-stark-surface text-white rounded-lg px-4 py-3 mb-3 border border-mcu-blue/30 focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20 text-lg font-display" />
            <div className="flex justify-between items-center">
              <span className="text-stitch-muted">Cards: <span className={selectedCards.length === 12 ? 'text-green-500' : 'text-yellow-500'}>{selectedCards.length}/12</span></span>
              <button onClick={saveDeck} disabled={selectedCards.length !== 12 || !deckName.trim()}
                className="bg-mcu-blue text-white px-4 py-2 rounded-lg hover:shadow-glow-blue transition-all duration-200 disabled:opacity-50">
                Save Deck
              </button>
            </div>
          </div>

          {/* Selected Cards - 4x3 Grid with Art */}
          <div className="stitch-card p-5 mb-4">
            <div className="flex justify-between items-center mb-3">
              <div className="stitch-section-header mb-0">
                <span className="material-symbols-outlined" aria-hidden="true">grid_view</span>
                Deck Slots
              </div>
              <span className="stitch-badge">{selectedCards.length}/12</span>
            </div>
            <div className="grid grid-cols-4 gap-2">
              {Array.from({ length: 12 }).map((_, i) => {
                const cardName = selectedCards[i];
                const card = cardName ? cardLookup.get(cardName) || null : null;
                return cardName ? (
                  <button key={cardName} onClick={() => toggleCardInDeck(cardName)}
                    className="relative aspect-[3/4] rounded-xl overflow-hidden cursor-pointer hover:scale-105 transition-transform duration-150 group border-2 border-cosmic-purple/40 holo-glow">
                    <div className="absolute inset-0 card-art" style={{ backgroundImage: `url(${getCardArtUrl(card || { name: cardName })})` }} />
                    <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent" />
                    <span className="absolute top-1 left-1 w-5 h-5 rounded-full bg-blue-600 flex items-center justify-center text-[10px] font-bold text-white shadow">
                      {card?.cost ?? '?'}
                    </span>
                    <span className="absolute top-1 right-1 w-5 h-5 rounded-full bg-red-500/80 flex items-center justify-center text-[9px] text-white opacity-0 group-hover:opacity-100 transition-opacity">&times;</span>
                    <span className="absolute bottom-1 left-1 right-1 text-[10px] text-white text-center leading-tight truncate font-bold drop-shadow-lg">{cardName}</span>
                  </button>
                ) : (
                  <div key={`empty-${i}`} className="card-slot flex items-center justify-center border-stitch-border" aria-label={`Empty slot ${i + 1}`}>
                    <span className="material-symbols-outlined text-stitch-muted/30" style={{fontSize: '20px'}}>add</span>
                  </div>
                );
              })}
            </div>
            <div className="mt-3 pt-3 border-t border-stitch-border">
              <div className="flex justify-around text-center">
                <div>
                  <div className="stitch-label">Cards</div>
                  <div className={`text-sm font-bold ${selectedCards.length === 12 ? 'text-stitch-green' : 'text-mcu-gold'}`}>{selectedCards.length}/12</div>
                </div>
                <div>
                  <div className="stitch-label">Avg Energy</div>
                  <div className="text-sm font-bold text-cosmic-purple-text">{selectedCards.length > 0 ? getDeckStats(selectedCards).avgCost : '--'}</div>
                </div>
                <div>
                  <div className="stitch-label">Total Power</div>
                  <div className="text-sm font-bold text-orange-400">{selectedCards.length > 0 ? getDeckStats(selectedCards).totalPower : '--'}</div>
                </div>
              </div>
            </div>
          </div>

          {/* Card Picker */}
          <div className="stitch-card p-5">
            <div className="flex gap-2 mb-3">
              <input type="text" placeholder="Search cards..."
                value={searchCard} onChange={(e) => setSearchCard(e.target.value)}
                aria-label="Search cards to add"
                className="flex-1 bg-stitch-accent text-white rounded-xl px-4 py-2.5 border border-stitch-border focus:border-cosmic-purple-text focus:outline-none placeholder-stitch-muted" />
              <select value={seriesFilter} onChange={(e) => setSeriesFilter(e.target.value)}
                className="bg-stitch-accent text-white rounded-xl px-3 py-2.5 border border-stitch-border focus:border-cosmic-purple-text focus:outline-none">
                <option value="all">All</option>
                <option value="1">S1</option>
                <option value="2">S2</option>
                <option value="3">S3</option>
                <option value="4">S4</option>
                <option value="5">S5</option>
              </select>
            </div>
            <div className="grid grid-cols-3 sm:grid-cols-4 gap-2 max-h-96 overflow-y-auto">
              {filteredCards.map(card => {
                const isSelected = selectedCards.includes(card.name);
                const isOwned = collection.owned.includes(card.name);
                return (
                  <button key={card.name} onClick={() => toggleCardInDeck(card.name)}
                    disabled={!isSelected && selectedCards.length >= 12}
                    className={`relative p-2 rounded-lg border-2 transition-all ${
                      isSelected ? 'border-mcu-blue bg-[#2b1933]' :
                      isOwned ? 'border-[rgba(173,43,238,0.3)] bg-[#1a1320] hover:border-mcu-blue' :
                      'border-[rgba(173,43,238,0.2)] bg-[#120818] opacity-60'
                    } disabled:opacity-30`}>
                    <div className="absolute top-0 left-0 w-4 h-4 bg-mcu-blue rounded-br flex items-center justify-center text-xs text-white">{card.cost}</div>
                    <div className="absolute top-0 right-0 w-4 h-4 bg-mcu-red rounded-bl flex items-center justify-center text-xs text-white">{card.power}</div>
                    <div className="mt-4 text-xs text-white text-center truncate">{card.name}</div>
                    {isSelected && (
                      <div className="absolute -top-1 -right-1 w-6 h-6 bg-green-500 rounded-full flex items-center justify-center">
                        <span className="text-white text-xs"></span>
                      </div>
                    )}
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      );
    };

    // Spotlight Oracle Component - Predictive Economy Engine
    const SpotlightOracle = ({ collection }) => {
      const [schedule, setSchedule] = useState(null);
      const [rewards, setRewards] = useState(null);
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        const loadData = async () => {
          try {
            const response = await fetch('data/spotlight-schedule.json');
            const data = await response.json();
            setSchedule(data);
          } catch (err) { console.error('Could not load spotlight schedule:', err); }
          setRewards(loadFromStorage('snap_rewards', null));
          setLoading(false);
        };
        loadData();
      }, []);

      if (loading) return <div className="px-4 pb-20"><Header title="SPOTLIGHT ORACLE" /><div className="text-center py-8 text-stitch-muted">Loading...</div></div>;
      if (!schedule) return <div className="px-4 pb-20"><Header title="SPOTLIGHT ORACLE" /><div className="stitch-card p-6 text-center"><div className="text-4xl mb-4"></div><p className="text-stitch-muted">Schedule unavailable</p></div></div>;

      const ownedCards = new Set((collection?.owned || []).map(c => c.toLowerCase()));
      const pity = rewards?.pityCounters || { s4: 0, s5: 0, spotlightKey: 0 };

      const analyzedWeeks = schedule.weeks.map(week => {
        const allCards = [week.spotlight.mainCard, ...week.cacheCards.map(c => c.name)];
        const missingCards = allCards.filter(c => !ownedCards.has(c.toLowerCase()));
        const ev = missingCards.length > 0 ? (4 / missingCards.length).toFixed(1) : Infinity;
        const evRating = missingCards.length >= 3 ? 'excellent' : missingCards.length === 2 ? 'good' : missingCards.length === 1 ? 'fair' : 'skip';
        return { ...week, missingCards, totalCards: allCards.length, ev: parseFloat(ev), evRating };
      });

      return (
        <div className="px-4 pb-20">
          <Header title="SPOTLIGHT ORACLE" />
          <div className="stitch-card p-5 mb-4 border-l-4 border-mcu-gold">
            <h2 className="text-lg font-display font-semibold text-[#c75fff] mb-3"> Pity Status</h2>
            <div className="grid grid-cols-3 gap-4 text-center">
              <div><div className="text-2xl font-bold text-green-400">{pity.s4}/20</div><div className="text-xs text-stitch-muted">S4</div></div>
              <div><div className="text-2xl font-bold text-purple-400">{pity.s5}/60</div><div className="text-xs text-stitch-muted">S5</div></div>
              <div><div className="text-2xl font-bold text-orange-400">{pity.spotlightKey}/4</div><div className="text-xs text-stitch-muted">Key</div></div>
            </div>
          </div>
          <div className="space-y-4">
            {analyzedWeeks.map((week, idx) => (
              <div key={idx} className={`stitch-card p-5 border-l-4 ${week.evRating === 'excellent' ? 'border-green-500' : week.evRating === 'good' ? 'border-blue-500' : 'border-[rgba(173,43,238,0.3)]'}`}>
                <div className="flex justify-between items-start mb-2">
                  <div className="text-xs text-stitch-muted">Week {week.weekNumber}  {new Date(week.startDate).toLocaleDateString()}</div>
                  <div className={`text-xs px-2 py-1 rounded ${week.evRating === 'excellent' ? 'bg-green-500/30 text-green-400' : 'bg-[#1a1320] text-stitch-muted'}`}>{week.evRating === 'excellent' ? 'PRIME' : week.evRating.toUpperCase()}</div>
                </div>
                <div className="mb-2"><span className={`font-bold ${ownedCards.has(week.spotlight.mainCard.toLowerCase()) ? 'text-stitch-muted line-through' : 'text-white'}`}> {week.spotlight.mainCard}</span></div>
                <div className="flex flex-wrap gap-1 mb-2">{week.cacheCards.map((c, i) => <span key={i} className={`text-xs px-2 py-0.5 rounded ${ownedCards.has(c.name.toLowerCase()) ? 'bg-[#1a1320] text-stitch-muted line-through' : 'bg-[#1a1320] text-white'}`}>{c.name}</span>)}</div>
                <div className="flex justify-between text-xs pt-2 border-t border-[rgba(173,43,238,0.2)]"><span>Missing: {week.missingCards.length}/{week.totalCards}</span><span className={week.evRating === 'excellent' ? 'text-green-400' : ''}>EV: {week.ev === Infinity ? '' : week.ev}</span></div>
              </div>
            ))}
          </div>
        </div>
      );
    };

    // Hall of Armor Component - Variant Gallery & Achievement Showcase
    const HallOfArmor = () => {
      const [collectionEnhanced, setCollectionEnhanced] = useState(null);
      const [filter, setFilter] = useState('all');
      const [sortBy, setSortBy] = useState('name');

      useEffect(() => {
        const loadData = () => {
          const data = loadFromStorage('snap_collection_enhanced', null);
          setCollectionEnhanced(data);
        };
        loadData();
        window.addEventListener('snap-data-updated', loadData);
        return () => window.removeEventListener('snap-data-updated', loadData);
      }, []);

      if (!collectionEnhanced) {
        return (
          <div className="px-4 pb-20">
            <Header title="HALL OF ARMOR" />
            <div className="stitch-card p-6 text-center">
              <div className="text-4xl mb-4"></div>
              <h2 className="text-xl font-display font-semibold text-[#c75fff] mb-2">Sync Your Collection</h2>
              <p className="text-stitch-muted mb-4">
                Link your game folder to display your God Splits, variants, and collection achievements.
              </p>
              <p className="text-sm text-gray-500">
                Settings  Link Game Folder
              </p>
            </div>
          </div>
        );
      }

      const { cards, godSplits, variants, godSplitCount, variantCount, totalBoosters } = collectionEnhanced;

      // Filter cards based on selection
      const filteredCards = cards.filter(card => {
        switch (filter) {
          case 'godSplits':
            return card.variants?.some(v => v.isGodSplit);
          case 'infinity':
            return card.variants?.some(v => v.isInfinity);
          case 'highMastery':
            return card.splitLevel >= 4;
          default:
            return card.variants?.length > 0 || card.boosters > 100;
        }
      });

      // Sort cards
      const sortedCards = [...filteredCards].sort((a, b) => {
        switch (sortBy) {
          case 'boosters':
            return b.boosters - a.boosters;
          case 'variants':
            return (b.variants?.length || 0) - (a.variants?.length || 0);
          default:
            return a.cardDefId.localeCompare(b.cardDefId);
        }
      });

      // Identify God Split types
      const getGodSplitType = (effect) => {
        if (!effect) return null;
        const lower = effect.toLowerCase();
        if (lower.includes('ink')) return { name: 'Inked', color: 'text-blue-400', bg: 'bg-blue-900/30' };
        if (lower.includes('gold')) return { name: 'Gold', color: 'text-yellow-400', bg: 'bg-yellow-900/30' };
        if (lower.includes('krackle')) return { name: 'Krackle', color: 'text-pink-400', bg: 'bg-pink-900/30' };
        if (lower.includes('prism')) return { name: 'Prism', color: 'text-purple-400', bg: 'bg-purple-900/30' };
        return { name: 'Special', color: 'text-stitch-muted', bg: 'bg-gray-900/30' };
      };

      return (
        <div className="px-4 pb-20">
          <Header title="HALL OF ARMOR" />

          {/* Stats Overview */}
          <div className="grid grid-cols-3 gap-3 mb-4">
            <div className="stitch-card p-4 border-l-4 border-mcu-gold text-center">
              <div className="text-2xl font-display font-bold text-mcu-gold">{godSplitCount}</div>
              <div className="text-xs text-stitch-muted">God Splits</div>
            </div>
            <div className="stitch-card p-4 border-l-4 border-series-3 text-center">
              <div className="text-2xl font-display font-bold text-series-3">{variantCount}</div>
              <div className="text-xs text-stitch-muted">Variants</div>
            </div>
            <div className="stitch-card p-4 border-l-4 border-mcu-blue text-center">
              <div className="text-2xl font-display font-bold text-mcu-blue">{totalBoosters.toLocaleString()}</div>
              <div className="text-xs text-stitch-muted">Boosters</div>
            </div>
          </div>

          {/* God Splits Showcase */}
          {godSplitCount > 0 && (
            <div className="stitch-card p-5 mb-4">
              <h2 className="text-lg font-display font-semibold text-[#c75fff] mb-3 flex items-center gap-2">
                <span></span> God Splits
              </h2>
              <div className="flex flex-wrap gap-2">
                {godSplits.slice(0, 12).map((split, idx) => {
                  const type = getGodSplitType(split.effect);
                  return (
                    <div key={idx} className={`px-3 py-2 rounded-lg ${type?.bg || 'bg-[#1a1320]'} border border-[rgba(173,43,238,0.3)]`}>
                      <div className={`font-bold text-sm ${type?.color || 'text-white'}`}>
                        {split.cardDefId.replace(/_/g, ' ')}
                      </div>
                      <div className="text-xs text-stitch-muted">{type?.name || 'Special'}</div>
                    </div>
                  );
                })}
                {godSplitCount > 12 && (
                  <div className="px-3 py-2 rounded-lg bg-[#1a1320] flex items-center">
                    <span className="text-stitch-muted text-sm">+{godSplitCount - 12} more</span>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Filters */}
          <div className="flex gap-2 mb-4 flex-wrap">
            {[
              { id: 'all', label: 'All Notable' },
              { id: 'godSplits', label: 'God Splits' },
              { id: 'infinity', label: 'Infinity' },
              { id: 'highMastery', label: 'High Mastery' }
            ].map(f => (
              <button
                key={f.id}
                onClick={() => setFilter(f.id)}
                className={`px-3 py-1 rounded text-sm transition-colors ${
                  filter === f.id
                    ? 'bg-mcu-gold text-black font-bold'
                    : 'bg-[#1a1320] text-gray-300 hover:bg-[#2b1933]'
                }`}
              >
                {f.label}
              </button>
            ))}
          </div>

          {/* Card Grid */}
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
            {sortedCards.slice(0, 20).map((card, idx) => {
              const hasGodSplit = card.variants?.some(v => v.isGodSplit);
              const hasInfinity = card.variants?.some(v => v.isInfinity);

              return (
                <div
                  key={idx}
                  className={`stitch-card p-4 relative ${
                    hasGodSplit ? 'border-l-4 border-mcu-gold mcu-glow-gold' :
                    hasInfinity ? 'border-l-4 border-series-3' :
                    'border-l-4 border-[rgba(173,43,238,0.3)]'
                  }`}
                >
                  {/* Badges */}
                  <div className="absolute -top-1 -right-1 flex gap-1">
                    {hasGodSplit && (
                      <span className="w-5 h-5 bg-yellow-500 rounded-full flex items-center justify-center text-xs"></span>
                    )}
                    {hasInfinity && (
                      <span className="w-5 h-5 bg-purple-500 rounded-full flex items-center justify-center text-xs"></span>
                    )}
                  </div>

                  <div className="font-bold text-white text-sm truncate mb-1">
                    {card.cardDefId.replace(/_/g, ' ')}
                  </div>
                  <div className="flex justify-between text-xs text-stitch-muted">
                    <span>{card.variants?.length || 0} variants</span>
                    <span>{card.boosters} boosters</span>
                  </div>
                </div>
              );
            })}
          </div>

          {sortedCards.length === 0 && (
            <div className="stitch-card p-6 text-center">
              <p className="text-stitch-muted">No cards match this filter.</p>
            </div>
          )}

          {sortedCards.length > 20 && (
            <div className="text-center mt-4 text-stitch-muted text-sm">
              Showing 20 of {sortedCards.length} cards
            </div>
          )}
        </div>
      );
    };

    // Economy Intelligence Component
    const EconomyIntelligence = () => {
      const [wallet, setWallet] = useState(() => loadFromStorage('snap_wallet', { credits: 0, gold: 0, tokens: 0, keys: 0 }));
      const [tokenshop, setTokenshop] = useState(() => loadFromStorage('snap_tokenshop', { items: [] }));
      const [rewards, setRewards] = useState(() => loadFromStorage('snap_rewards', {}));

      // Listen for data updates
      useEffect(() => {
        const handleUpdate = () => {
          setWallet(loadFromStorage('snap_wallet', { credits: 0, gold: 0, tokens: 0, keys: 0 }));
          setTokenshop(loadFromStorage('snap_tokenshop', { items: [] }));
          setRewards(loadFromStorage('snap_rewards', {}));
        };
        window.addEventListener('snap-data-updated', handleUpdate);
        return () => window.removeEventListener('snap-data-updated', handleUpdate);
      }, []);

      // Calculate affordable token shop items
      const affordableItems = (tokenshop.items || []).filter(item => item.cost <= wallet.tokens);

      // Calculate pity progress percentages
      const s4Progress = rewards.series4 ? (rewards.series4.current / rewards.series4.max) * 100 : 0;
      const s5Progress = rewards.series5 ? (rewards.series5.current / rewards.series5.max) * 100 : 0;
      const keyProgress = rewards.spotlightKey ? (rewards.spotlightKey.current / rewards.spotlightKey.max) * 100 : 0;

      // Smart key allocation recommendation
      const getKeyRecommendation = () => {
        if (!rewards.spotlightKey || !rewards.series4) return { action: 'COLLECT_MORE', reason: 'Import game data to get recommendations' };

        const keysPity = rewards.spotlightKey.max - rewards.spotlightKey.current;
        const s4Pity = rewards.series4.max - rewards.series4.current;
        const s5Pity = rewards.series5 ? rewards.series5.max - rewards.series5.current : 50;

        // If close to spotlight key pity, open spotlights
        if (keysPity <= 1) {
          return { action: 'SPOTLIGHT', reason: `Only ${keysPity} cache away from guaranteed key!`, urgent: true };
        }
        // If close to S5 pity, open collector reserves
        if (s5Pity <= 10) {
          return { action: 'COLLECTOR', reason: `${s5Pity} caches from guaranteed S5 card`, urgent: s5Pity <= 5 };
        }
        // If close to S4 pity, open collector reserves
        if (s4Pity <= 5) {
          return { action: 'COLLECTOR', reason: `${s4Pity} reserves from guaranteed S4 card`, urgent: true };
        }
        // Default: save for spotlights if have cards you want
        return { action: 'SAVE', reason: 'Check Oracle tab for upcoming spotlight targets' };
      };

      const recommendation = getKeyRecommendation();

      // Credit burn optimizer - estimate upgrade availability
      const UPGRADE_COSTS = {
        common_uncommon: { credits: 5, boosters: 5, cl: 1 },
        uncommon_rare: { credits: 25, boosters: 10, cl: 2 },
        rare_epic: { credits: 100, boosters: 20, cl: 4 },
        epic_legendary: { credits: 200, boosters: 30, cl: 8 },
        legendary_ultra: { credits: 300, boosters: 40, cl: 16 },
        ultra_infinity: { credits: 400, boosters: 50, cl: 32 }
      };

      // Calculate how many upgrades can be done
      const cheapestUpgrade = UPGRADE_COSTS.common_uncommon;
      const maxCheapUpgrades = Math.floor(wallet.credits / cheapestUpgrade.credits);

      return (
        <div className="px-4 pb-20">
          <Header title="ECONOMY HQ" />

          {/* Resource Overview */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Current Resources</h3>
            <div className="grid grid-cols-4 gap-2">
              <div className="bg-[#1a1320] rounded-lg p-2 text-center">
                <div className="text-2xl"></div>
                <div className="text-white font-bold">{(wallet.credits || 0).toLocaleString()}</div>
                <div className="text-stitch-muted text-xs">Credits</div>
              </div>
              <div className="bg-[#1a1320] rounded-lg p-2 text-center">
                <div className="text-2xl"></div>
                <div className="text-yellow-400 font-bold">{(wallet.gold || 0).toLocaleString()}</div>
                <div className="text-stitch-muted text-xs">Gold</div>
              </div>
              <div className="bg-[#1a1320] rounded-lg p-2 text-center">
                <div className="text-2xl"></div>
                <div className="text-purple-400 font-bold">{(wallet.tokens || 0).toLocaleString()}</div>
                <div className="text-stitch-muted text-xs">Tokens</div>
              </div>
              <div className="bg-[#1a1320] rounded-lg p-2 text-center">
                <div className="text-2xl"></div>
                <div className="text-mcu-red font-bold">{wallet.keys || 0}</div>
                <div className="text-stitch-muted text-xs">Keys</div>
              </div>
            </div>
          </div>

          {/* Key Allocation Advisor */}
          <div className={`stitch-card p-5 mb-4 border-l-4 ${
            recommendation.urgent ? 'border-mcu-blue' : 'border-mcu-gold'
          }`}>
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-2">Key Allocation Advisor</h3>
            <div className={`text-lg font-bold mb-1 ${
              recommendation.action === 'SPOTLIGHT' ? 'text-yellow-400' :
              recommendation.action === 'COLLECTOR' ? 'text-purple-400' :
              'text-gray-300'
            }`}>
              {recommendation.action === 'SPOTLIGHT' && ' Open Spotlight Caches'}
              {recommendation.action === 'COLLECTOR' && ' Open Collector Reserves'}
              {recommendation.action === 'SAVE' && ' Save Your Keys'}
              {recommendation.action === 'COLLECT_MORE' && ' Need More Data'}
            </div>
            <p className="text-gray-300 text-sm">{recommendation.reason}</p>

            {/* Pity Progress Bars */}
            {rewards.series4 && (
              <div className="mt-3 space-y-2">
                <div>
                  <div className="flex justify-between text-xs text-stitch-muted mb-1">
                    <span>Spotlight Key Pity</span>
                    <span>{rewards.spotlightKey?.current || 0}/{rewards.spotlightKey?.max || 4}</span>
                  </div>
                  <div className="h-2 bg-[#1a1320] rounded-full overflow-hidden">
                    <div className="h-full bg-yellow-500 transition-all" style={{ width: `${keyProgress}%` }}></div>
                  </div>
                </div>
                <div>
                  <div className="flex justify-between text-xs text-stitch-muted mb-1">
                    <span>S4 Pity</span>
                    <span>{rewards.series4?.current || 0}/{rewards.series4?.max || 40}</span>
                  </div>
                  <div className="h-2 bg-[#1a1320] rounded-full overflow-hidden">
                    <div className="h-full bg-green-500 transition-all" style={{ width: `${s4Progress}%` }}></div>
                  </div>
                </div>
                {rewards.series5 && (
                  <div>
                    <div className="flex justify-between text-xs text-stitch-muted mb-1">
                      <span>S5 Pity</span>
                      <span>{rewards.series5?.current || 0}/{rewards.series5?.max || 50}</span>
                    </div>
                    <div className="h-2 bg-[#1a1320] rounded-full overflow-hidden">
                      <div className="h-full bg-red-500 transition-all" style={{ width: `${s5Progress}%` }}></div>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Token Shop Planner */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Token Shop</h3>
            {affordableItems.length > 0 ? (
              <div className="space-y-2">
                <p className="text-green-400 text-sm mb-2">You can afford {affordableItems.length} item(s)!</p>
                {affordableItems.slice(0, 5).map((item, i) => (
                  <div key={i} className="flex justify-between items-center bg-[#1a1320] rounded p-2">
                    <span className="text-white">{item.name}</span>
                    <span className="text-purple-400">{item.cost} tokens</span>
                  </div>
                ))}
              </div>
            ) : tokenshop.items?.length > 0 ? (
              <div>
                <p className="text-stitch-muted text-sm mb-2">Saving up for:</p>
                {tokenshop.items.slice(0, 3).map((item, i) => (
                  <div key={i} className="flex justify-between items-center text-sm mb-1">
                    <span className="text-gray-300">{item.name}</span>
                    <span className="text-gray-500">{item.cost - wallet.tokens} more needed</span>
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-stitch-muted">Import game data to see token shop items.</p>
            )}
          </div>

          {/* Credit Burn Optimizer */}
          <div className="stitch-card p-5">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Credit Optimizer</h3>
            <div className="text-white mb-2">
              With <span className="text-green-400 font-bold">{wallet.credits?.toLocaleString()}</span> credits, you can do:
            </div>
            <div className="grid grid-cols-2 gap-2 text-sm">
              <div className="bg-[#1a1320] rounded p-2">
                <div className="text-stitch-muted">Common  Uncommon</div>
                <div className="text-white font-bold">{maxCheapUpgrades}x</div>
                <div className="text-green-400 text-xs">+{maxCheapUpgrades} CL</div>
              </div>
              <div className="bg-[#1a1320] rounded p-2">
                <div className="text-stitch-muted">Rare  Epic</div>
                <div className="text-white font-bold">{Math.floor(wallet.credits / 100)}x</div>
                <div className="text-green-400 text-xs">+{Math.floor(wallet.credits / 100) * 4} CL</div>
              </div>
            </div>
            <p className="text-stitch-muted text-xs mt-2">
              Check the Plan tab for booster-optimized upgrade suggestions.
            </p>
          </div>
        </div>
      );
    };

    // Board Snapshot Tool (Danger Room Lite)
    const BoardSnapshot = () => {
      const [lanes, setLanes] = useState([[], [], []]);
      const [searchQuery, setSearchQuery] = useState('');
      const [opponentPower, setOpponentPower] = useState([0, 0, 0]);
      const [selectedCard, setSelectedCard] = useState(null); // Card waiting to be placed
      const collection = loadFromStorage('snap_collection', { owned: [] });

      // Get card list
      const allCards = [...(typeof uniqueCards !== 'undefined' ? uniqueCards : [])];
      const filteredCards = searchQuery
        ? allCards.filter(c => c.name.toLowerCase().includes(searchQuery.toLowerCase())).slice(0, 12)
        : allCards.slice(0, 12);

      const addCardToLane = (laneIndex, card) => {
        if (lanes[laneIndex].length >= 4) return; // Max 4 cards per lane
        setLanes(prev => {
          const newLanes = [...prev];
          newLanes[laneIndex] = [...newLanes[laneIndex], { name: card.name, power: card.power }];
          return newLanes;
        });
        setSelectedCard(null); // Clear selection after placing
      };

      const selectCard = (card) => {
        setSelectedCard(card);
      };

      const cancelSelection = () => {
        setSelectedCard(null);
      };

      const removeCardFromLane = (laneIndex, cardIndex) => {
        setLanes(prev => {
          const newLanes = [...prev];
          newLanes[laneIndex] = newLanes[laneIndex].filter((_, i) => i !== cardIndex);
          return newLanes;
        });
      };

      const clearBoard = () => {
        setLanes([[], [], []]);
        setOpponentPower([0, 0, 0]);
      };

      // Calculate lane powers
      const lanePowers = lanes.map(lane => lane.reduce((sum, card) => sum + (card.power || 0), 0));
      const totalPower = lanePowers.reduce((a, b) => a + b, 0);
      const totalOpponentPower = opponentPower.reduce((a, b) => a + b, 0);

      // Generate text description for AI
      const generateDescription = () => {
        const laneDescriptions = lanes.map((lane, i) => {
          const cards = lane.map(c => c.name).join(', ') || 'empty';
          const myPower = lanePowers[i];
          const oppPower = opponentPower[i];
          return `Lane ${i + 1}: [${cards}] (My: ${myPower}, Opp: ${oppPower})`;
        });
        return `Board State:\n${laneDescriptions.join('\n')}\nTotal Power - Me: ${totalPower}, Opponent: ${totalOpponentPower}`;
      };

      const copyToClipboard = async () => {
        const description = generateDescription();
        try {
          await navigator.clipboard.writeText(description);
          showToast('Board copied to clipboard!');
        } catch {
          // Fallback for older browsers
          const textarea = document.createElement('textarea');
          textarea.value = description;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
          showToast('Board copied!');
        }
      };

      return (
        <div className="px-4 pb-20">
          <Header title="BOARD SNAPSHOT" />

          {/* Instructions */}
          <div className="stitch-card p-4 mb-4 text-sm">
            <p className="text-gray-300">
              <span className="text-mcu-gold font-bold">How to use:</span> Tap cards below to add them to lanes.
              Set opponent power, then copy to share with AI advisor.
            </p>
          </div>

          {/* Board - 3 Lanes */}
          <div className="grid grid-cols-3 gap-2 mb-4">
            {lanes.map((lane, laneIndex) => (
              <div key={laneIndex} className="stitch-card p-3 min-h-32">
                <div className="text-center text-stitch-muted text-xs mb-2">Lane {laneIndex + 1}</div>

                {/* Cards in lane */}
                <div className="space-y-1 mb-2">
                  {lane.map((card, cardIndex) => (
                    <div
                      key={cardIndex}
                      onClick={() => removeCardFromLane(laneIndex, cardIndex)}
                      className="bg-[#1a1320] rounded px-2 py-1 text-xs text-white cursor-pointer hover:bg-red-900 flex justify-between"
                    >
                      <span className="truncate">{card.name}</span>
                      <span className="text-mcu-gold ml-1">{card.power}</span>
                    </div>
                  ))}
                  {lane.length < 4 && (
                    <div className="border-2 border-dashed border-[rgba(173,43,238,0.3)] rounded h-6 flex items-center justify-center text-gray-500 text-xs">
                      +
                    </div>
                  )}
                </div>

                {/* Lane totals */}
                <div className="text-center border-t border-[rgba(173,43,238,0.2)] pt-2">
                  <div className="text-mcu-blue font-bold">{lanePowers[laneIndex]}</div>
                  <div className="flex items-center justify-center gap-1 mt-1">
                    <span className="text-xs text-stitch-muted">vs</span>
                    <input
                      type="number"
                      value={opponentPower[laneIndex]}
                      onChange={(e) => {
                        const newOpp = [...opponentPower];
                        newOpp[laneIndex] = parseInt(e.target.value) || 0;
                        setOpponentPower(newOpp);
                      }}
                      className="w-12 bg-[#1a1320] rounded text-center text-red-400 text-sm p-1"
                      min="0"
                    />
                  </div>
                </div>
              </div>
            ))}
          </div>

          {/* Power Summary */}
          <div className="flex justify-between items-center stitch-card p-4 mb-4">
            <div className="text-center">
              <div className="text-mcu-blue text-xl font-bold">{totalPower}</div>
              <div className="text-stitch-muted text-xs">Your Power</div>
            </div>
            <div className="text-stitch-muted text-lg">vs</div>
            <div className="text-center">
              <div className="text-red-400 text-xl font-bold">{totalOpponentPower}</div>
              <div className="text-stitch-muted text-xs">Opponent</div>
            </div>
          </div>

          {/* Action Buttons */}
          <div className="flex gap-2 mb-4">
            <button
              onClick={copyToClipboard}
              className="flex-1 bg-mcu-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600"
            >
               Copy for AI
            </button>
            <button
              onClick={clearBoard}
              className="bg-[#1a1320] text-white px-4 py-3 rounded-lg font-medium hover:bg-[#2b1933]"
            >
               Clear
            </button>
          </div>

          {/* Lane Selector (shows when card is selected) */}
          {selectedCard && (
            <div className="bg-mcu-blue/20 border-2 border-mcu-blue rounded-lg p-4 mb-4">
              <div className="text-center mb-3">
                <span className="text-white">Place </span>
                <span className="text-mcu-gold font-bold">{selectedCard.name}</span>
                <span className="text-stitch-muted"> ({selectedCard.power} power)</span>
              </div>
              <div className="grid grid-cols-3 gap-2 mb-2">
                {[0, 1, 2].map(laneIdx => (
                  <button
                    key={laneIdx}
                    onClick={() => addCardToLane(laneIdx, selectedCard)}
                    disabled={lanes[laneIdx].length >= 4}
                    className={`py-3 rounded-lg font-bold transition-colors ${
                      lanes[laneIdx].length >= 4
                        ? 'bg-[#1a1320] text-gray-500 cursor-not-allowed'
                        : 'bg-mcu-blue text-white hover:bg-blue-500'
                    }`}
                  >
                    Lane {laneIdx + 1}
                    {lanes[laneIdx].length >= 4 && <span className="block text-xs">(Full)</span>}
                  </button>
                ))}
              </div>
              <button
                onClick={cancelSelection}
                className="w-full py-2 bg-[#1a1320] text-gray-300 rounded-lg hover:bg-[#2b1933]"
              >
                Cancel
              </button>
            </div>
          )}

          {/* Card Search & Selection */}
          <div className="stitch-card p-5">
            <input
              type="text"
              placeholder="Search cards..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full bg-[#1a1320] rounded-lg px-4 py-2 text-white placeholder-gray-400 mb-3"
            />

            <div className="grid grid-cols-4 gap-2">
              {filteredCards.map((card, i) => (
                <button
                  key={i}
                  onClick={() => selectCard(card)}
                  className={`bg-[#1a1320] rounded-lg p-2 text-center transition-colors hover:bg-[#2b1933] ${
                    selectedCard?.name === card.name ? 'ring-2 ring-mcu-gold' : ''
                  }`}
                >
                  <div className="text-white text-sm truncate">{card.name}</div>
                  <div className="text-mcu-gold text-xs">{card.power}</div>
                </button>
              ))}
            </div>
            {!selectedCard && (
              <p className="text-gray-500 text-xs text-center mt-3">Tap a card, then choose which lane</p>
            )}
          </div>
        </div>
      );
    };

    // Calculator Component
    const Calculator = () => {
      const [turn, setTurn] = useState(4);
      const [confidence, setConfidence] = useState(50);
      const [cardsToDraw, setCardsToDraw] = useState(1);
      const [copiesInDeck, setCopiesInDeck] = useState(1);

      const cardsSeen = Math.min(12, 3 + turn);

      const hypergeometric = (N, K, n) => {
        const factorial = (num) => { if (num <= 1) return 1; let r = 1; for (let i = 2; i <= num; i++) r *= i; return r; };
        const comb = (a, b) => { if (b > a) return 0; if (b === 0 || b === a) return 1; return factorial(a) / (factorial(b) * factorial(a - b)); };
        return 1 - (comb(N - K, n) / comb(N, n));
      };

      const drawProbability = hypergeometric(12, copiesInDeck, cardsToDraw) * 100;

      const getRecommendation = () => {
        const turnRiskFactor = turn <= 3 ? 0.9 : turn <= 5 ? 1.0 : 1.1;
        const adj = confidence / turnRiskFactor;
        if (adj >= 70) return { action: 'SNAP', bgColor: 'bg-green-600', animate: true };
        if (adj >= 45) return { action: 'HOLD', bgColor: 'bg-yellow-600', animate: false };
        return { action: 'RETREAT', bgColor: 'bg-red-600', animate: false };
      };
      const rec = getRecommendation();

      return (
        <div className="px-4 pb-20">
          <Header title="SNAP CALCULATOR" />
          <div className={`stitch-card ${rec.bgColor} p-6 mb-4 text-center ${rec.animate ? 'arc-pulse' : ''}`}>
            <div className="text-4xl font-hero text-white mb-2 mcu-text-glow">{rec.action}</div>
            <div className="text-white/80">
              {rec.action === 'SNAP' && 'The odds favor you. Make your move!'}
              {rec.action === 'HOLD' && 'Wait for more information.'}
              {rec.action === 'RETREAT' && 'Live to fight another match.'}
            </div>
          </div>
          <div className="stitch-card p-5 mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Current Turn</span>
              <span className="text-mcu-gold font-bold text-xl">{turn}</span>
            </div>
            <input type="range" min="1" max="7" value={turn} onChange={(e) => setTurn(parseInt(e.target.value))} className="w-full" />
            <div className="text-center text-sm text-stitch-muted mt-2">Cards seen: {cardsSeen}/12</div>
          </div>
          <div className="stitch-card p-5 mb-4">
            <div className="flex justify-between items-center mb-2">
              <span className="text-white font-medium">Win Confidence</span>
              <span className={`font-bold text-xl ${confidence >= 70 ? 'text-green-400' : confidence >= 45 ? 'text-yellow-400' : 'text-red-400'}`}>{confidence}%</span>
            </div>
            <input type="range" min="0" max="100" value={confidence} onChange={(e) => setConfidence(parseInt(e.target.value))} className="w-full" />
          </div>
          <div className="stitch-card p-5">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Draw Probability</h3>
            <div className="grid grid-cols-2 gap-3 mb-4">
              <div>
                <label htmlFor="cards-to-draw" className="text-sm text-stitch-muted">Cards to Draw</label>
                <input id="cards-to-draw" type="number" min="1" max="12" value={cardsToDraw}
                  onChange={(e) => setCardsToDraw(Math.max(1, Math.min(12, parseInt(e.target.value) || 1)))}
                  className="w-full bg-[#1a1320] text-white rounded px-3 py-2 mt-1 border-2 border-[rgba(173,43,238,0.3)] focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20" />
              </div>
              <div>
                <label htmlFor="copies-in-deck" className="text-sm text-stitch-muted">Copies in Deck</label>
                <input id="copies-in-deck" type="number" min="1" max="4" value={copiesInDeck}
                  onChange={(e) => setCopiesInDeck(Math.max(1, Math.min(4, parseInt(e.target.value) || 1)))}
                  className="w-full bg-[#1a1320] text-white rounded px-3 py-2 mt-1 border-2 border-[rgba(173,43,238,0.3)] focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20" />
              </div>
            </div>
            <div className="bg-[#1a1320] rounded-lg p-4 text-center">
              <div className="text-stitch-muted text-sm mb-1">Probability of drawing at least 1:</div>
              <div className={`text-3xl font-display font-bold ${drawProbability >= 70 ? 'text-green-400' : drawProbability >= 40 ? 'text-mcu-gold' : 'text-mcu-red'}`}>
                {drawProbability.toFixed(1)}%
              </div>
            </div>
          </div>
        </div>
      );
    };

    // ==================== DECK SIMULATOR ====================
    // Simulation Engine - Pure math functions
    const SimulationEngine = {
      // Factorial with memoization for performance
      _factorialCache: [1, 1],
      factorial(n) {
        if (n < 0) return 0;
        if (n < this._factorialCache.length) return this._factorialCache[n];
        let result = this._factorialCache[this._factorialCache.length - 1];
        for (let i = this._factorialCache.length; i <= n; i++) {
          result *= i;
          this._factorialCache[i] = result;
        }
        return result;
      },

      // Combination C(n, k) = n! / (k! * (n-k)!)
      combination(n, k) {
        if (k < 0 || k > n) return 0;
        if (k === 0 || k === n) return 1;
        // Optimize for large numbers
        k = Math.min(k, n - k);
        let result = 1;
        for (let i = 0; i < k; i++) {
          result = result * (n - i) / (i + 1);
        }
        return Math.round(result);
      },

      // Hypergeometric probability: P(X >= 1) = 1 - P(X = 0)
      // N = population size (deck), K = success states (copies), n = draws
      hypergeometricAtLeastOne(N, K, n) {
        if (K <= 0 || n <= 0 || N <= 0) return 0;
        if (K >= N || n >= N) return 1;
        // P(X = 0) = C(K,0) * C(N-K, n) / C(N, n)
        const pZero = this.combination(N - K, n) / this.combination(N, n);
        return Math.max(0, Math.min(1, 1 - pZero));
      },

      // Probability of drawing ALL of k specific cards by drawing n cards
      // Uses inclusion-exclusion principle
      hypergeometricAllCards(N, targetCards, n) {
        const k = targetCards.length;
        if (k === 0) return 1;
        if (k > n) return 0;
        if (n >= N) return 1;

        // P(have all k cards in n draws) = C(N-k, n-k) / C(N, n)
        return this.combination(N - k, n - k) / this.combination(N, n);
      },

      // Opening hand probabilities for each card
      openingHandProbabilities(deckSize, handSize) {
        // P(specific card in hand) = 1 - C(deckSize-1, handSize) / C(deckSize, handSize)
        // Simplifies to: handSize / deckSize
        return handSize / deckSize;
      },

      // Probability of having specific card by turn T
      cardByTurnProbability(deckSize, handSize, turn) {
        const cardsSeen = Math.min(deckSize, handSize + turn);
        return cardsSeen / deckSize;
      }
    };

    // Seeded Random Number Generator (Mulberry32)
    const createSeededRNG = (seed) => {
      let state = seed;
      return () => {
        state |= 0;
        state = state + 0x6D2B79F5 | 0;
        let t = Math.imul(state ^ state >>> 15, 1 | state);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    };

    // Monte Carlo Simulation Runner (runs in main thread for small counts, worker for large)
    const MonteCarloEngine = {
      // Shuffle array using Fisher-Yates with provided RNG
      shuffle(array, rng) {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      },

      // Simulate single game and return results
      simulateGame(deck, options, rng) {
        const {
          handSize = 3,
          turnsToSimulate = 6,
          extraDrawsPerTurn = 0,
          thinningPerTurn = 0,
          junkInsertsPerTurn = 0,
          handSizeLimit = Infinity
        } = options;

        let currentDeck = this.shuffle([...deck], rng);
        let hand = currentDeck.splice(0, handSize);
        const drawnCards = [...hand];
        const handByTurn = [{ turn: 0, hand: [...hand], deckSize: currentDeck.length }];

        for (let turn = 1; turn <= turnsToSimulate; turn++) {
          // Apply thinning (remove cards from deck)
          for (let i = 0; i < thinningPerTurn && currentDeck.length > 0; i++) {
            const idx = Math.floor(rng() * currentDeck.length);
            currentDeck.splice(idx, 1);
          }

          // Apply junk inserts
          for (let i = 0; i < junkInsertsPerTurn; i++) {
            currentDeck.push({ name: `Junk_${turn}_${i}`, cost: 99, power: 0, isJunk: true });
          }

          // Draw cards
          const drawCount = 1 + extraDrawsPerTurn;
          for (let i = 0; i < drawCount && currentDeck.length > 0; i++) {
            const card = currentDeck.shift();
            hand.push(card);
            drawnCards.push(card);
          }

          // Apply hand size limit
          while (hand.length > handSizeLimit && hand.length > 0) {
            const idx = Math.floor(rng() * hand.length);
            hand.splice(idx, 1);
          }

          handByTurn.push({ turn, hand: [...hand], deckSize: currentDeck.length });
        }

        return { hand, drawnCards, handByTurn };
      },

      // Run Monte Carlo simulation
      runSimulation(deck, options, numRuns, onProgress, seed = null) {
        const results = {
          openingHands: {},
          cardByTurn: {},
          curveAnalysis: [],
          comboResults: {},
          sampleHands: []
        };

        const rng = seed !== null ? createSeededRNG(seed) : Math.random;
        const comboCards = options.comboCards || [];
        const deckCardNames = deck.map(c => c.name);

        // Initialize tracking
        deckCardNames.forEach(name => {
          results.openingHands[name] = 0;
          results.cardByTurn[name] = Array(7).fill(0);
        });

        for (let turn = 1; turn <= 6; turn++) {
          results.curveAnalysis.push({
            turn,
            onCurvePlays: 0,
            brickCount: 0,
            totalPlayableEnergy: 0
          });
        }

        if (comboCards.length > 0) {
          for (let turn = 1; turn <= 6; turn++) {
            results.comboResults[turn] = 0;
          }
        }

        // Run simulations
        for (let i = 0; i < numRuns; i++) {
          const simRng = seed !== null ? createSeededRNG(seed + i) : () => Math.random();
          const { handByTurn } = this.simulateGame(deck, options, simRng);

          // Opening hand analysis
          const openingHand = handByTurn[0].hand;
          openingHand.forEach(card => {
            if (results.openingHands[card.name] !== undefined) {
              results.openingHands[card.name]++;
            }
          });

          // Store sample hands (first 10 runs)
          if (i < 10) {
            results.sampleHands.push(openingHand.map(c => c.name));
          }

          // Card by turn analysis
          const seenCards = new Set();
          handByTurn.forEach(({ turn, hand }) => {
            hand.forEach(card => {
              if (!seenCards.has(card.name) && results.cardByTurn[card.name]) {
                seenCards.add(card.name);
                for (let t = turn; t <= 6; t++) {
                  results.cardByTurn[card.name][t]++;
                }
              }
            });
          });

          // Curve analysis
          handByTurn.slice(1).forEach(({ turn, hand }) => {
            const analysis = results.curveAnalysis[turn - 1];
            const playableCosts = hand.filter(c => !c.isJunk && c.cost <= turn).map(c => c.cost);

            if (playableCosts.length > 0) {
              analysis.onCurvePlays++;
              analysis.totalPlayableEnergy += Math.max(...playableCosts);
            } else {
              analysis.brickCount++;
            }
          });

          // Combo analysis
          if (comboCards.length > 0) {
            handByTurn.slice(1).forEach(({ turn, hand }) => {
              const handNames = new Set(hand.map(c => c.name));
              if (comboCards.every(name => handNames.has(name))) {
                results.comboResults[turn]++;
              }
            });
          }

          // Progress callback
          if (onProgress && i % Math.max(1, Math.floor(numRuns / 100)) === 0) {
            onProgress(i / numRuns);
          }
        }

        // Convert counts to percentages
        Object.keys(results.openingHands).forEach(name => {
          results.openingHands[name] = (results.openingHands[name] / numRuns) * 100;
        });

        Object.keys(results.cardByTurn).forEach(name => {
          results.cardByTurn[name] = results.cardByTurn[name].map(count => (count / numRuns) * 100);
        });

        results.curveAnalysis = results.curveAnalysis.map(a => ({
          ...a,
          onCurveRate: (a.onCurvePlays / numRuns) * 100,
          brickRate: (a.brickCount / numRuns) * 100,
          avgPlayableEnergy: a.totalPlayableEnergy / numRuns
        }));

        if (comboCards.length > 0) {
          Object.keys(results.comboResults).forEach(turn => {
            results.comboResults[turn] = (results.comboResults[turn] / numRuns) * 100;
          });
        }

        return results;
      }
    };

    // Web Worker code as string for inline Blob worker
    const workerCode = `
      // Seeded RNG (Mulberry32)
      const createSeededRNG = (seed) => {
        let state = seed;
        return () => {
          state |= 0;
          state = state + 0x6D2B79F5 | 0;
          let t = Math.imul(state ^ state >>> 15, 1 | state);
          t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
      };

      const shuffle = (array, rng) => {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      };

      const simulateGame = (deck, options, rng) => {
        const { handSize = 3, turnsToSimulate = 6, extraDrawsPerTurn = 0, thinningPerTurn = 0, junkInsertsPerTurn = 0, handSizeLimit = Infinity } = options;
        let currentDeck = shuffle([...deck], rng);
        let hand = currentDeck.splice(0, handSize);
        const handByTurn = [{ turn: 0, hand: [...hand], deckSize: currentDeck.length }];

        for (let turn = 1; turn <= turnsToSimulate; turn++) {
          for (let i = 0; i < thinningPerTurn && currentDeck.length > 0; i++) {
            currentDeck.splice(Math.floor(rng() * currentDeck.length), 1);
          }
          for (let i = 0; i < junkInsertsPerTurn; i++) {
            currentDeck.push({ name: 'Junk_' + turn + '_' + i, cost: 99, power: 0, isJunk: true });
          }
          const drawCount = 1 + extraDrawsPerTurn;
          for (let i = 0; i < drawCount && currentDeck.length > 0; i++) {
            hand.push(currentDeck.shift());
          }
          while (hand.length > handSizeLimit && hand.length > 0) {
            hand.splice(Math.floor(rng() * hand.length), 1);
          }
          handByTurn.push({ turn, hand: [...hand], deckSize: currentDeck.length });
        }
        return { hand, handByTurn };
      };

      self.onmessage = function(e) {
        const { deck, options, numRuns, seed, chunkSize = 1000 } = e.data;
        const results = {
          openingHands: {},
          cardByTurn: {},
          curveAnalysis: [],
          comboResults: {},
          sampleHands: []
        };

        const comboCards = options.comboCards || [];
        const deckCardNames = deck.map(c => c.name);

        deckCardNames.forEach(name => {
          results.openingHands[name] = 0;
          results.cardByTurn[name] = Array(7).fill(0);
        });

        for (let turn = 1; turn <= 6; turn++) {
          results.curveAnalysis.push({ turn, onCurvePlays: 0, brickCount: 0, totalPlayableEnergy: 0 });
        }

        if (comboCards.length > 0) {
          for (let turn = 1; turn <= 6; turn++) results.comboResults[turn] = 0;
        }

        let completed = 0;
        const runChunk = () => {
          const chunkEnd = Math.min(completed + chunkSize, numRuns);

          for (let i = completed; i < chunkEnd; i++) {
            const simRng = seed !== null ? createSeededRNG(seed + i) : () => Math.random();
            const { handByTurn } = simulateGame(deck, options, simRng);

            const openingHand = handByTurn[0].hand;
            openingHand.forEach(card => {
              if (results.openingHands[card.name] !== undefined) results.openingHands[card.name]++;
            });

            if (i < 10) results.sampleHands.push(openingHand.map(c => c.name));

            const seenCards = new Set();
            handByTurn.forEach(({ turn, hand }) => {
              hand.forEach(card => {
                if (!seenCards.has(card.name) && results.cardByTurn[card.name]) {
                  seenCards.add(card.name);
                  for (let t = turn; t <= 6; t++) results.cardByTurn[card.name][t]++;
                }
              });
            });

            handByTurn.slice(1).forEach(({ turn, hand }) => {
              const analysis = results.curveAnalysis[turn - 1];
              const playableCosts = hand.filter(c => !c.isJunk && c.cost <= turn).map(c => c.cost);
              if (playableCosts.length > 0) {
                analysis.onCurvePlays++;
                analysis.totalPlayableEnergy += Math.max(...playableCosts);
              } else {
                analysis.brickCount++;
              }
            });

            if (comboCards.length > 0) {
              handByTurn.slice(1).forEach(({ turn, hand }) => {
                const handNames = new Set(hand.map(c => c.name));
                if (comboCards.every(name => handNames.has(name))) results.comboResults[turn]++;
              });
            }
          }

          completed = chunkEnd;
          self.postMessage({ type: 'progress', progress: completed / numRuns });

          if (completed < numRuns) {
            setTimeout(runChunk, 0);
          } else {
            // Finalize results
            Object.keys(results.openingHands).forEach(name => {
              results.openingHands[name] = (results.openingHands[name] / numRuns) * 100;
            });
            Object.keys(results.cardByTurn).forEach(name => {
              results.cardByTurn[name] = results.cardByTurn[name].map(count => (count / numRuns) * 100);
            });
            results.curveAnalysis = results.curveAnalysis.map(a => ({
              ...a,
              onCurveRate: (a.onCurvePlays / numRuns) * 100,
              brickRate: (a.brickCount / numRuns) * 100,
              avgPlayableEnergy: a.totalPlayableEnergy / numRuns
            }));
            if (comboCards.length > 0) {
              Object.keys(results.comboResults).forEach(turn => {
                results.comboResults[turn] = (results.comboResults[turn] / numRuns) * 100;
              });
            }
            self.postMessage({ type: 'complete', results });
          }
        };

        runChunk();
      };
    `;

    // Create Web Worker from Blob
    const createSimulationWorker = () => {
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    };

    // Simulator Component
    const Simulator = ({ decks, collection }) => {
      const [selectedDeckId, setSelectedDeckId] = useState(() => {
        const saved = localStorage.getItem('snap_simulator_deck');
        return saved || (decks.length > 0 ? decks[0].id : '');
      });
      const [mode, setMode] = useState('opening');
      const [numRuns, setNumRuns] = useState(10000);
      const [isRunning, setIsRunning] = useState(false);
      const [progress, setProgress] = useState(0);
      const [results, setResults] = useState(null);
      const [useSeed, setUseSeed] = useState(false);
      const [seed, setSeed] = useState(12345);
      const [comboCards, setComboCards] = useState([]);
      const [showAdvanced, setShowAdvanced] = useState(false);
      const [advancedOptions, setAdvancedOptions] = useState({
        handSize: 3,
        deckSizeOverride: 12,
        extraDrawsPerTurn: 0,
        thinningPerTurn: 0,
        junkInsertsPerTurn: 0,
        handSizeLimit: 0
      });

      // Interactive play-through state
      const [playState, setPlayState] = useState(null);
      const [playHistory, setPlayHistory] = useState([]);

      const workerRef = useRef(null);

      const selectedDeck = decks.find(d => d.id === selectedDeckId);
      const deckCards = selectedDeck ? selectedDeck.cards.map(name => {
        const card = uniqueCards.find(c => c.name === name);
        return card || { name, cost: 0, power: 0, series: 0 };
      }) : [];

      const isAdvancedModified = advancedOptions.handSize !== 3 ||
        advancedOptions.extraDrawsPerTurn !== 0 ||
        advancedOptions.thinningPerTurn !== 0 ||
        advancedOptions.junkInsertsPerTurn !== 0 ||
        advancedOptions.handSizeLimit !== 0;

      // Save deck selection to localStorage
      useEffect(() => {
        if (selectedDeckId) {
          localStorage.setItem('snap_simulator_deck', selectedDeckId);
        }
      }, [selectedDeckId]);

      // Save simulator settings
      useEffect(() => {
        localStorage.setItem('snap_simulator_settings', JSON.stringify({
          numRuns, useSeed, seed, advancedOptions
        }));
      }, [numRuns, useSeed, seed, advancedOptions]);

      // Load saved settings
      useEffect(() => {
        try {
          const saved = JSON.parse(localStorage.getItem('snap_simulator_settings') || '{}');
          if (saved.numRuns) setNumRuns(saved.numRuns);
          if (saved.useSeed !== undefined) setUseSeed(saved.useSeed);
          if (saved.seed) setSeed(saved.seed);
          if (saved.advancedOptions) setAdvancedOptions(prev => ({ ...prev, ...saved.advancedOptions }));
        } catch (e) {}
      }, []);

      // Cleanup worker on unmount
      useEffect(() => {
        return () => {
          if (workerRef.current) {
            workerRef.current.terminate();
          }
        };
      }, []);

      const runSimulation = useCallback(() => {
        if (!selectedDeck || deckCards.length !== 12) {
          alert('Please select a valid 12-card deck');
          return;
        }

        setIsRunning(true);
        setProgress(0);
        setResults(null);

        const options = {
          handSize: advancedOptions.handSize,
          turnsToSimulate: 6,
          extraDrawsPerTurn: advancedOptions.extraDrawsPerTurn,
          thinningPerTurn: advancedOptions.thinningPerTurn,
          junkInsertsPerTurn: advancedOptions.junkInsertsPerTurn,
          handSizeLimit: advancedOptions.handSizeLimit || Infinity,
          comboCards
        };

        // Use worker for large simulations
        if (numRuns >= 5000) {
          if (workerRef.current) {
            workerRef.current.terminate();
          }

          const worker = createSimulationWorker();
          workerRef.current = worker;

          worker.onmessage = (e) => {
            if (e.data.type === 'progress') {
              setProgress(e.data.progress);
            } else if (e.data.type === 'complete') {
              setResults(e.data.results);
              setIsRunning(false);
              setProgress(1);
              worker.terminate();
              workerRef.current = null;
            }
          };

          worker.onerror = (err) => {
            console.error('Worker error:', err);
            setIsRunning(false);
            worker.terminate();
            workerRef.current = null;
          };

          worker.postMessage({
            deck: deckCards,
            options,
            numRuns,
            seed: useSeed ? seed : null,
            chunkSize: Math.min(1000, Math.ceil(numRuns / 100))
          });
        } else {
          // Small runs - use main thread with RAF chunking
          requestAnimationFrame(() => {
            const results = MonteCarloEngine.runSimulation(
              deckCards,
              options,
              numRuns,
              (p) => setProgress(p),
              useSeed ? seed : null
            );
            setResults(results);
            setIsRunning(false);
            setProgress(1);
          });
        }
      }, [selectedDeck, deckCards, numRuns, useSeed, seed, advancedOptions, comboCards]);

      const cancelSimulation = () => {
        if (workerRef.current) {
          workerRef.current.terminate();
          workerRef.current = null;
        }
        setIsRunning(false);
        setProgress(0);
      };

      // Interactive play-through functions
      const startNewGame = () => {
        if (!selectedDeck || deckCards.length !== 12) return;

        const rng = useSeed ? createSeededRNG(seed) : () => Math.random();
        const shuffledDeck = MonteCarloEngine.shuffle([...deckCards], rng);
        const hand = shuffledDeck.splice(0, advancedOptions.handSize);

        const state = {
          turn: 0,
          hand,
          deck: shuffledDeck,
          drawnThisTurn: [...hand]
        };

        setPlayState(state);
        setPlayHistory([{ ...state, action: 'start' }]);
      };

      const drawNext = () => {
        if (!playState || playState.deck.length === 0 || playState.turn >= 6) return;

        const newDeck = [...playState.deck];
        const newHand = [...playState.hand];
        const drawCount = 1 + advancedOptions.extraDrawsPerTurn;
        const drawnCards = [];

        for (let i = 0; i < drawCount && newDeck.length > 0; i++) {
          const card = newDeck.shift();
          newHand.push(card);
          drawnCards.push(card);
        }

        const newState = {
          turn: playState.turn + 1,
          hand: newHand,
          deck: newDeck,
          drawnThisTurn: drawnCards
        };

        setPlayState(newState);
        setPlayHistory(prev => [...prev, { ...newState, action: 'draw' }]);
      };

      const undoAction = () => {
        if (playHistory.length <= 1) return;
        const newHistory = playHistory.slice(0, -1);
        setPlayHistory(newHistory);
        setPlayState(newHistory[newHistory.length - 1]);
      };

      const autoPlay = async () => {
        if (!playState) return;

        let currentState = playState;
        while (currentState.turn < 6 && currentState.deck.length > 0) {
          await new Promise(r => setTimeout(r, 500));
          drawNext();
          currentState = { ...currentState, turn: currentState.turn + 1 };
        }
      };

      const toggleComboCard = (cardName) => {
        setComboCards(prev =>
          prev.includes(cardName)
            ? prev.filter(c => c !== cardName)
            : [...prev, cardName]
        );
      };

      // Exact math results for comparison
      const exactResults = useMemo(() => {
        if (!selectedDeck || deckCards.length !== 12) return null;

        const deckSize = 12;
        const handSize = advancedOptions.handSize;

        const openingHandProb = SimulationEngine.openingHandProbabilities(deckSize, handSize) * 100;

        const cardByTurn = {};
        deckCards.forEach(card => {
          cardByTurn[card.name] = [];
          for (let turn = 0; turn <= 6; turn++) {
            const cardsSeen = Math.min(deckSize, handSize + turn);
            cardByTurn[card.name].push((cardsSeen / deckSize) * 100);
          }
        });

        const comboByTurn = {};
        if (comboCards.length >= 2) {
          for (let turn = 1; turn <= 6; turn++) {
            const cardsSeen = Math.min(deckSize, handSize + turn);
            comboByTurn[turn] = SimulationEngine.hypergeometricAllCards(deckSize, comboCards, cardsSeen) * 100;
          }
        }

        return { openingHandProb, cardByTurn, comboByTurn };
      }, [selectedDeck, deckCards, advancedOptions.handSize, comboCards]);

      // Progress bar component
      const ProgressBar = ({ value }) => (
        <div className="w-full bg-[#1a1320] rounded-full h-4 overflow-hidden">
          <div
            className="bg-mcu-blue h-full transition-all duration-200 ease-out"
            style={{ width: `${value * 100}%` }}
          />
        </div>
      );

      // Percentage bar component
      const PercentBar = ({ value, color = 'bg-mcu-blue', label }) => (
        <div className="flex items-center gap-2">
          <div className="flex-1 bg-[#1a1320] rounded h-4 overflow-hidden">
            <div className={`${color} h-full`} style={{ width: `${Math.min(100, value)}%` }} />
          </div>
          <span className="text-white text-sm w-16 text-right">{value.toFixed(1)}%</span>
          {label && <span className="text-stitch-muted text-xs">{label}</span>}
        </div>
      );

      return (
        <div className="px-4 pb-20">
          <Header title="DECK SIMULATOR" />

          {/* Deck Selector */}
          <div className="stitch-card p-5 mb-4">
            <label className="block text-sm text-stitch-muted mb-2">Select Deck</label>
            {decks.length === 0 ? (
              <div className="text-center text-stitch-muted py-4">
                <p className="mb-2">No decks created yet</p>
                <p className="text-sm">Go to Decks tab to create a 12-card deck</p>
              </div>
            ) : (
              <select
                value={selectedDeckId}
                onChange={(e) => setSelectedDeckId(e.target.value)}
                className="w-full bg-[#1a1320] text-white rounded px-3 py-2 border-2 border-[rgba(173,43,238,0.3)] focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20"
              >
                <option value="">Select a deck...</option>
                {decks.map(deck => (
                  <option key={deck.id} value={deck.id}>{deck.name} ({deck.cards.length} cards)</option>
                ))}
              </select>
            )}

            {selectedDeck && (
              <div className="mt-3 flex flex-wrap gap-1">
                {selectedDeck.cards.map(cardName => {
                  const card = uniqueCards.find(c => c.name === cardName);
                  const owned = collection.owned.includes(cardName);
                  return (
                    <span
                      key={cardName}
                      className={`text-xs px-2 py-1 rounded-full ${owned ? 'bg-[#1a1320] text-white' : 'bg-red-900 text-red-300'}`}
                    >
                      {card?.cost || '?'}/{cardName}
                    </span>
                  );
                })}
              </div>
            )}
          </div>

          {/* Mode Selector */}
          <div className="stitch-card p-5 mb-4">
            <label className="block text-sm text-stitch-muted mb-2">Simulation Mode</label>
            <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
              {[
                { id: 'opening', label: 'Opening Hand', icon: '' },
                { id: 'draw', label: 'Draw by Turn', icon: '' },
                { id: 'curve', label: 'Curve Analysis', icon: '' },
                { id: 'combo', label: 'Combo Finder', icon: '' },
                { id: 'play', label: 'Play Through', icon: '' },
                { id: 'advanced', label: 'All Results', icon: '' }
              ].map(m => (
                <button
                  key={m.id}
                  onClick={() => setMode(m.id)}
                  className={`p-3 rounded-lg text-sm font-medium transition-colors ${
                    mode === m.id
                      ? 'bg-mcu-blue text-white'
                      : 'bg-[#1a1320] text-gray-300 hover:bg-[#2b1933]'
                  }`}
                >
                  <span className="block text-lg mb-1">{m.icon}</span>
                  {m.label}
                </button>
              ))}
            </div>
          </div>

          {/* Run Controls (not for play-through mode) */}
          {mode !== 'play' && (
            <div className="stitch-card p-5 mb-4">
              <div className="flex gap-2 mb-3">
                <button
                  onClick={() => setNumRuns(1000)}
                  className={`px-3 py-1 rounded text-sm ${numRuns === 1000 ? 'bg-mcu-blue text-white' : 'bg-[#1a1320] text-gray-300'}`}
                >1K</button>
                <button
                  onClick={() => setNumRuns(10000)}
                  className={`px-3 py-1 rounded text-sm ${numRuns === 10000 ? 'bg-mcu-blue text-white' : 'bg-[#1a1320] text-gray-300'}`}
                >10K</button>
                <button
                  onClick={() => setNumRuns(50000)}
                  className={`px-3 py-1 rounded text-sm ${numRuns === 50000 ? 'bg-mcu-blue text-white' : 'bg-[#1a1320] text-gray-300'}`}
                >50K</button>
                <input
                  type="number"
                  value={numRuns}
                  onChange={(e) => setNumRuns(Math.max(100, Math.min(200000, parseInt(e.target.value) || 1000)))}
                  className="flex-1 bg-[#1a1320] text-white rounded px-2 py-1 text-sm border border-[rgba(173,43,238,0.3)]"
                  placeholder="Custom"
                />
              </div>

              <div className="flex items-center gap-3 mb-3">
                <label className="flex items-center gap-2 text-sm text-gray-300">
                  <input
                    type="checkbox"
                    checked={useSeed}
                    onChange={(e) => setUseSeed(e.target.checked)}
                    className="w-4 h-4 accent-mcu-blue"
                  />
                  Use seed for reproducibility
                </label>
                {useSeed && (
                  <input
                    type="number"
                    value={seed}
                    onChange={(e) => setSeed(parseInt(e.target.value) || 0)}
                    className="w-24 bg-[#1a1320] text-white rounded px-2 py-1 text-sm border border-[rgba(173,43,238,0.3)]"
                  />
                )}
              </div>

              {isRunning ? (
                <div className="space-y-2">
                  <ProgressBar value={progress} />
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-stitch-muted">{Math.round(progress * 100)}% complete</span>
                    <button
                      onClick={cancelSimulation}
                      className="px-4 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              ) : (
                <button
                  onClick={runSimulation}
                  disabled={!selectedDeck || deckCards.length !== 12}
                  className="w-full bg-mcu-red text-white py-3 rounded-lg font-display font-semibold hover:shadow-glow-red transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                   RUN SIMULATION ({numRuns.toLocaleString()} runs)
                </button>
              )}
            </div>
          )}

          {/* Advanced Rules Panel */}
          <div className="stitch-card mb-4 overflow-hidden">
            <button
              onClick={() => setShowAdvanced(!showAdvanced)}
              className="w-full p-4 flex justify-between items-center text-left"
            >
              <span className="text-white font-medium">
                Advanced Rules {isAdvancedModified && <span className="text-mcu-gold text-xs ml-2">(Modified)</span>}
              </span>
              <span className="text-stitch-muted">{showAdvanced ? '' : ''}</span>
            </button>

            {showAdvanced && (
              <div className="px-4 pb-4 space-y-3 border-t border-[rgba(173,43,238,0.2)] pt-3">
                {isAdvancedModified && (
                  <div className="bg-yellow-900/30 border border-yellow-600 rounded p-2 text-xs text-yellow-300">
                     Advanced rules active - Exact math disabled, Monte Carlo only
                  </div>
                )}

                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="block text-xs text-stitch-muted mb-1">Starting Hand Size</label>
                    <input
                      type="number"
                      value={advancedOptions.handSize}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, handSize: Math.max(1, Math.min(12, parseInt(e.target.value) || 3)) }))}
                      className="w-full bg-[#1a1320] text-white rounded px-2 py-1 text-sm border border-[rgba(173,43,238,0.3)]"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-stitch-muted mb-1">Extra Draws/Turn</label>
                    <input
                      type="number"
                      value={advancedOptions.extraDrawsPerTurn}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, extraDrawsPerTurn: Math.max(0, Math.min(5, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-[#1a1320] text-white rounded px-2 py-1 text-sm border border-[rgba(173,43,238,0.3)]"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-stitch-muted mb-1">Thinning/Turn</label>
                    <input
                      type="number"
                      value={advancedOptions.thinningPerTurn}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, thinningPerTurn: Math.max(0, Math.min(5, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-[#1a1320] text-white rounded px-2 py-1 text-sm border border-[rgba(173,43,238,0.3)]"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-stitch-muted mb-1">Junk Inserts/Turn</label>
                    <input
                      type="number"
                      value={advancedOptions.junkInsertsPerTurn}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, junkInsertsPerTurn: Math.max(0, Math.min(5, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-[#1a1320] text-white rounded px-2 py-1 text-sm border border-[rgba(173,43,238,0.3)]"
                    />
                  </div>
                  <div className="col-span-2">
                    <label className="block text-xs text-stitch-muted mb-1">Hand Size Limit (0 = unlimited)</label>
                    <input
                      type="number"
                      value={advancedOptions.handSizeLimit}
                      onChange={(e) => setAdvancedOptions(prev => ({ ...prev, handSizeLimit: Math.max(0, Math.min(20, parseInt(e.target.value) || 0)) }))}
                      className="w-full bg-[#1a1320] text-white rounded px-2 py-1 text-sm border border-[rgba(173,43,238,0.3)]"
                    />
                  </div>
                </div>

                <button
                  onClick={() => setAdvancedOptions({ handSize: 3, deckSizeOverride: 12, extraDrawsPerTurn: 0, thinningPerTurn: 0, junkInsertsPerTurn: 0, handSizeLimit: 0 })}
                  className="text-sm text-mcu-blue hover:underline"
                >
                  Reset to defaults
                </button>
              </div>
            )}
          </div>

          {/* Combo Card Selector (for combo mode) */}
          {mode === 'combo' && selectedDeck && (
            <div className="stitch-card p-5 mb-4">
              <label className="block text-sm text-stitch-muted mb-2">Select Combo Pieces (click cards)</label>
              <div className="flex flex-wrap gap-1 mb-3">
                {selectedDeck.cards.map(cardName => {
                  const isSelected = comboCards.includes(cardName);
                  const card = uniqueCards.find(c => c.name === cardName);
                  return (
                    <button
                      key={cardName}
                      onClick={() => toggleComboCard(cardName)}
                      className={`text-xs px-2 py-1 rounded-full transition-colors ${
                        isSelected
                          ? 'bg-mcu-gold text-black font-medium'
                          : 'bg-[#1a1320] text-gray-300 hover:bg-[#2b1933]'
                      }`}
                    >
                      {card?.cost || '?'}/{cardName}
                    </button>
                  );
                })}
              </div>
              {comboCards.length < 2 && (
                <p className="text-sm text-stitch-muted">Select at least 2 cards to analyze combo probability</p>
              )}
              {comboCards.length >= 2 && (
                <p className="text-sm text-mcu-gold">Combo: {comboCards.join(' + ')}</p>
              )}
            </div>
          )}

          {/* Results Display */}
          {results && mode !== 'play' && (
            <div className="space-y-4">
              {/* Opening Hand Results */}
              {(mode === 'opening' || mode === 'advanced') && (
                <div className="stitch-card p-5">
                  <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Opening Hand Probability</h3>
                  <p className="text-xs text-stitch-muted mb-3">Chance of each card in starting hand ({advancedOptions.handSize} cards)</p>

                  {!isAdvancedModified && exactResults && (
                    <div className="mb-3 p-2 bg-[#1a1320] rounded text-xs text-gray-300">
                      <span className="text-mcu-blue">Exact math:</span> {exactResults.openingHandProb.toFixed(1)}% per card
                    </div>
                  )}

                  <div className="space-y-2">
                    {Object.entries(results.openingHands)
                      .sort((a, b) => b[1] - a[1])
                      .map(([name, prob]) => (
                        <div key={name}>
                          <div className="flex justify-between text-sm mb-1">
                            <span className="text-white">{name}</span>
                            <span className="text-stitch-muted">{prob.toFixed(1)}%</span>
                          </div>
                          <PercentBar value={prob} />
                        </div>
                      ))}
                  </div>

                  {results.sampleHands.length > 0 && (
                    <div className="mt-4 pt-4 border-t border-[rgba(173,43,238,0.2)]">
                      <h4 className="text-sm text-stitch-muted mb-2">Sample Opening Hands</h4>
                      <div className="space-y-1 max-h-40 overflow-y-auto">
                        {results.sampleHands.slice(0, 5).map((hand, i) => (
                          <div key={i} className="flex gap-1 flex-wrap">
                            <span className="text-xs text-gray-500 w-6">#{i+1}</span>
                            {hand.map((name, j) => (
                              <span key={j} className="text-xs px-2 py-0.5 bg-[#1a1320] rounded text-white">{name}</span>
                            ))}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}

              {/* Draw by Turn Results */}
              {(mode === 'draw' || mode === 'advanced') && (
                <div className="stitch-card p-5">
                  <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Draw by Turn Probability</h3>
                  <p className="text-xs text-stitch-muted mb-3">Chance of having each card by end of turn</p>

                  <div className="overflow-x-auto">
                    <table className="w-full text-sm">
                      <thead>
                        <tr className="text-stitch-muted">
                          <th className="text-left py-1">Card</th>
                          {[1,2,3,4,5,6].map(t => (
                            <th key={t} className="text-center py-1 w-12">T{t}</th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {Object.entries(results.cardByTurn).map(([name, turns]) => (
                          <tr key={name} className="border-t border-[rgba(173,43,238,0.2)]">
                            <td className="py-1 text-white text-xs">{name}</td>
                            {turns.slice(1).map((prob, i) => (
                              <td key={i} className={`text-center py-1 ${prob >= 70 ? 'text-green-400' : prob >= 40 ? 'text-yellow-400' : 'text-stitch-muted'}`}>
                                {prob.toFixed(0)}%
                              </td>
                            ))}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {/* Curve Analysis Results */}
              {(mode === 'curve' || mode === 'advanced') && (
                <div className="stitch-card p-5">
                  <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Curve / Brick Analysis</h3>
                  <p className="text-xs text-stitch-muted mb-3">On-curve = have at least one playable card that turn</p>

                  <div className="space-y-3">
                    {results.curveAnalysis.map(({ turn, onCurveRate, brickRate, avgPlayableEnergy }) => (
                      <div key={turn}>
                        <div className="flex justify-between text-sm mb-1">
                          <span className="text-white">Turn {turn}</span>
                          <span className="text-stitch-muted">
                            <span className={onCurveRate >= 90 ? 'text-green-400' : onCurveRate >= 70 ? 'text-yellow-400' : 'text-red-400'}>
                              {onCurveRate.toFixed(1)}% playable
                            </span>
                            <span className="mx-2">|</span>
                            <span className={brickRate <= 5 ? 'text-green-400' : brickRate <= 15 ? 'text-yellow-400' : 'text-red-400'}>
                              {brickRate.toFixed(1)}% brick
                            </span>
                          </span>
                        </div>
                        <div className="flex gap-1 h-4">
                          <div className="bg-green-600 h-full rounded-l" style={{ width: `${onCurveRate}%` }} />
                          <div className="bg-red-600 h-full rounded-r" style={{ width: `${brickRate}%` }} />
                        </div>
                        <div className="text-xs text-gray-500 mt-0.5">
                          Avg playable cost: {avgPlayableEnergy.toFixed(1)} energy
                        </div>
                      </div>
                    ))}
                  </div>

                  <div className="mt-4 pt-4 border-t border-[rgba(173,43,238,0.2)] grid grid-cols-2 gap-4">
                    <div className="text-center">
                      <div className="text-2xl font-bold text-green-400">
                        {(results.curveAnalysis.reduce((sum, a) => sum + a.onCurveRate, 0) / 6).toFixed(1)}%
                      </div>
                      <div className="text-xs text-stitch-muted">Avg On-Curve Rate</div>
                    </div>
                    <div className="text-center">
                      <div className="text-2xl font-bold text-red-400">
                        {(results.curveAnalysis.reduce((sum, a) => sum + a.brickRate, 0) / 6).toFixed(1)}%
                      </div>
                      <div className="text-xs text-stitch-muted">Avg Brick Rate</div>
                    </div>
                  </div>
                </div>
              )}

              {/* Combo Results */}
              {(mode === 'combo' || mode === 'advanced') && comboCards.length >= 2 && (
                <div className="stitch-card p-5">
                  <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Combo Finder Results</h3>
                  <p className="text-xs text-stitch-muted mb-3">Chance of having ALL pieces: {comboCards.join(' + ')}</p>

                  <div className="space-y-2">
                    {Object.entries(results.comboResults).map(([turn, prob]) => (
                      <div key={turn}>
                        <div className="flex justify-between text-sm mb-1">
                          <span className="text-white">By Turn {turn}</span>
                          <div className="text-right">
                            <span className={prob >= 50 ? 'text-green-400' : prob >= 25 ? 'text-yellow-400' : 'text-red-400'}>
                              {prob.toFixed(1)}%
                            </span>
                            {!isAdvancedModified && exactResults?.comboByTurn?.[turn] && (
                              <span className="text-xs text-gray-500 ml-2">(exact: {exactResults.comboByTurn[turn].toFixed(1)}%)</span>
                            )}
                          </div>
                        </div>
                        <PercentBar
                          value={prob}
                          color={prob >= 50 ? 'bg-green-600' : prob >= 25 ? 'bg-yellow-600' : 'bg-red-600'}
                        />
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Interactive Play-Through Mode */}
          {mode === 'play' && (
            <div className="space-y-4">
              <div className="stitch-card p-5">
                <div className="flex gap-2 mb-4">
                  <button
                    onClick={startNewGame}
                    disabled={!selectedDeck}
                    className="flex-1 bg-mcu-blue text-white py-2 rounded-lg font-display font-medium hover:shadow-glow-blue transition-all duration-200 disabled:opacity-50"
                  >
                    New Game
                  </button>
                  <button
                    onClick={drawNext}
                    disabled={!playState || playState.turn >= 6 || playState.deck.length === 0}
                    className="flex-1 bg-mcu-blue text-white py-2 rounded font-medium hover:opacity-90 disabled:opacity-50"
                  >
                    Draw Next
                  </button>
                  <button
                    onClick={undoAction}
                    disabled={playHistory.length <= 1}
                    className="px-4 bg-[#2b1933] text-white py-2 rounded font-medium hover:opacity-90 disabled:opacity-50"
                  >
                    Undo
                  </button>
                </div>

                {playState && (
                  <>
                    <div className="flex justify-between text-sm text-stitch-muted mb-3">
                      <span>Turn: <span className="text-white font-bold">{playState.turn}</span></span>
                      <span>Deck: <span className="text-white">{playState.deck.length} cards</span></span>
                    </div>

                    <div className="mb-4">
                      <h4 className="text-sm text-stitch-muted mb-2">Your Hand ({playState.hand.length} cards)</h4>
                      <div className="flex flex-wrap gap-2">
                        {playState.hand.map((card, i) => (
                          <div
                            key={i}
                            className={`relative p-2 rounded-lg border-2 bg-[#1a1320] min-w-16 ${
                              playState.drawnThisTurn.includes(card) && playState.turn > 0
                                ? 'border-mcu-gold'
                                : 'border-[rgba(173,43,238,0.3)]'
                            }`}
                          >
                            <div className="absolute top-0 left-0 w-5 h-5 bg-mcu-blue rounded-br flex items-center justify-center text-xs text-white font-bold">
                              {card.cost}
                            </div>
                            <div className="absolute top-0 right-0 w-5 h-5 bg-mcu-red rounded-bl flex items-center justify-center text-xs text-white font-bold">
                              {card.power}
                            </div>
                            <div className="mt-5 text-xs text-white text-center">{card.name}</div>
                          </div>
                        ))}
                      </div>
                    </div>

                    {playState.turn > 0 && playState.drawnThisTurn.length > 0 && (
                      <div className="text-sm text-mcu-gold">
                        Drew this turn: {playState.drawnThisTurn.map(c => c.name).join(', ')}
                      </div>
                    )}

                    <div className="mt-4 pt-4 border-t border-[rgba(173,43,238,0.2)]">
                      <h4 className="text-sm text-stitch-muted mb-2">Remaining Deck</h4>
                      <div className="flex flex-wrap gap-1">
                        {playState.deck.map((card, i) => (
                          <span key={i} className="text-xs px-2 py-0.5 bg-[#1a1320] text-stitch-muted rounded">
                            ?
                          </span>
                        ))}
                      </div>
                    </div>
                  </>
                )}

                {!playState && selectedDeck && (
                  <div className="text-center text-stitch-muted py-8">
                    <p className="mb-2">Click "New Game" to start a simulation</p>
                    <p className="text-sm">Deck: {selectedDeck.name}</p>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Info Panel */}
          {!results && mode !== 'play' && selectedDeck && (
            <div className="stitch-card p-5">
              <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-2">Simulation Info</h3>
              <p className="text-sm text-stitch-muted mb-3">
                Marvel Snap draws 3 cards initially, then 1 per turn. By turn 6, you've seen 9 of 12 cards.
              </p>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div className="bg-[#1a1320] rounded p-2 text-center">
                  <div className="text-mcu-blue font-bold">12</div>
                  <div className="text-stitch-muted text-xs">Deck Size</div>
                </div>
                <div className="bg-[#1a1320] rounded p-2 text-center">
                  <div className="text-mcu-blue font-bold">3</div>
                  <div className="text-stitch-muted text-xs">Starting Hand</div>
                </div>
                <div className="bg-[#1a1320] rounded p-2 text-center">
                  <div className="text-mcu-blue font-bold">1</div>
                  <div className="text-stitch-muted text-xs">Draw/Turn</div>
                </div>
                <div className="bg-[#1a1320] rounded p-2 text-center">
                  <div className="text-mcu-blue font-bold">9</div>
                  <div className="text-stitch-muted text-xs">Cards by T6</div>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    // Log Preview Modal Component
    const LogPreviewModal = ({ matches, skippedCount, onConfirm, onCancel }) => {
      const wins = matches.filter(m => m.result === 'WIN').length;
      const losses = matches.filter(m => m.result === 'LOSS').length;
      const totalCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);

      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-display font-semibold text-[#c75fff] mb-4 text-center">Log Analysis Complete</h3>

            <div className="grid grid-cols-2 gap-3 mb-4">
              <div className="bg-[#1a1320] rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">{matches.length}</div>
                <div className="text-xs text-stitch-muted">New Matches</div>
              </div>
              <div className="bg-[#1a1320] rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-stitch-muted">{skippedCount}</div>
                <div className="text-xs text-stitch-muted">Duplicates Skipped</div>
              </div>
              <div className="bg-green-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-green-400">{wins}</div>
                <div className="text-xs text-stitch-muted">Wins</div>
              </div>
              <div className="bg-red-900/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-red-400">{losses}</div>
                <div className="text-xs text-stitch-muted">Losses</div>
              </div>
            </div>

            <div className="bg-[#1a1320] rounded-lg p-3 mb-4 text-center">
              <div className="text-xs text-stitch-muted mb-1">Net Cubes from Import</div>
              <div className={`text-2xl font-bold ${totalCubes >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {totalCubes >= 0 ? '+' : ''}{totalCubes}
              </div>
            </div>

            {matches.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-300 mb-2">Preview (Recent 5):</h4>
                <div className="space-y-1 max-h-32 overflow-y-auto">
                  {matches.slice(0, 5).map((m, i) => (
                    <div key={i} className={`flex items-center justify-between p-2 rounded text-sm ${
                      m.result === 'WIN' ? 'bg-green-900/30' : 'bg-red-900/30'
                    }`}>
                      <span className={m.result === 'WIN' ? 'text-green-400' : 'text-red-400'}>{m.result}</span>
                      <span className="text-white">{m.result === 'WIN' ? '+' : '-'}{m.cubes}</span>
                      <span className="text-stitch-muted text-xs">{formatDate(m.timestamp)}</span>
                    </div>
                  ))}
                  {matches.length > 5 && (
                    <div className="text-center text-stitch-muted text-xs py-1">...and {matches.length - 5} more</div>
                  )}
                </div>
              </div>
            )}

            <div className="flex gap-2">
              <button onClick={() => onConfirm(matches)}
                className="flex-1 bg-mcu-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import {matches.length} Matches
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-[#2b1933] text-white py-3 rounded-lg font-medium hover:bg-[#3c2348]">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Sync Confirm Modal Component
    const SyncConfirmModal = ({ syncData, onConfirm, onCancel }) => {
      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal p-4" onClick={e => e.stopPropagation()}>
            <h3 className="text-xl font-display font-semibold text-[#c75fff] mb-4 text-center">Sync Data Received</h3>

            <div className="bg-[#1a1320] rounded-lg p-4 mb-4">
              <div className="text-center mb-3">
                <div className="text-3xl font-bold text-mcu-blue">{syncData.c?.length || 0}</div>
                <div className="text-sm text-stitch-muted">Cards in Collection</div>
              </div>
              {syncData.s && (
                <div className="grid grid-cols-3 gap-2 text-center text-sm">
                  <div>
                    <div className="text-green-400 font-bold">{syncData.s.wins || 0}</div>
                    <div className="text-stitch-muted text-xs">Wins</div>
                  </div>
                  <div>
                    <div className="text-red-400 font-bold">{syncData.s.losses || 0}</div>
                    <div className="text-stitch-muted text-xs">Losses</div>
                  </div>
                  <div>
                    <div className={`font-bold ${(syncData.s.cubes || 0) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                      {(syncData.s.cubes || 0) >= 0 ? '+' : ''}{syncData.s.cubes || 0}
                    </div>
                    <div className="text-stitch-muted text-xs">Cubes</div>
                  </div>
                </div>
              )}
            </div>

            <p className="text-stitch-muted text-sm mb-4 text-center">
              This will merge the synced collection with your current data.
            </p>

            <div className="flex gap-2">
              <button onClick={onConfirm}
                className="flex-1 bg-mcu-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600">
                Import Collection
              </button>
              <button onClick={onCancel}
                className="flex-1 bg-[#2b1933] text-white py-3 rounded-lg font-medium hover:bg-[#3c2348]">
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Phase 5: Toast notification helper
    const showToast = (message) => {
      const existing = document.querySelector('.toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.setAttribute('role', 'alert');
      toast.setAttribute('aria-live', 'polite');
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.remove(), 3500);
    };

    // Phase 5: Linked Folder Sync Component (Chrome/Edge only)
    const LinkedFolderSync = ({ onSyncComplete }) => {
      const [folderHandle, setFolderHandle] = useState(null);
      const [isLinked, setIsLinked] = useState(false);
      const [lastSync, setLastSync] = useState(null);
      const [syncing, setSyncing] = useState(false);
      const [error, setError] = useState(null);

      // Check if File System Access API is supported
      const isSupported = typeof window !== 'undefined' && 'showDirectoryPicker' in window;

      // On mount, try to restore saved folder handle
      useEffect(() => {
        restoreFolderHandle();
      }, []);

      async function restoreFolderHandle() {
        try {
          const db = await openSyncDB();
          const handle = await db.get('settings', 'folderHandle');
          if (handle) {
            const permission = await handle.queryPermission({ mode: 'read' });
            if (permission === 'granted') {
              setFolderHandle(handle);
              setIsLinked(true);
              const syncTime = await db.get('settings', 'lastSyncTime');
              if (syncTime) setLastSync(new Date(syncTime));
            }
          }
        } catch (err) {
          console.log('No saved folder handle or permission expired');
        }
      }

      async function handleLinkFolder() {
        try {
          setError(null);

          const handle = await window.showDirectoryPicker({
            id: 'snap-nvprod',
            mode: 'read',
            startIn: 'desktop'
          });

          // Verify it looks like the right folder
          const files = [];
          for await (const entry of handle.values()) {
            files.push(entry.name);
          }

          const expectedFiles = ['CollectionState.json', 'ProfileState.json'];
          const hasExpectedFiles = expectedFiles.some(f => files.includes(f));

          if (!hasExpectedFiles) {
            setError("This doesn't look like the nvprod folder. Please select the folder containing CollectionState.json");
            return;
          }

          const db = await openSyncDB();
          await db.put('settings', handle, 'folderHandle');

          setFolderHandle(handle);
          setIsLinked(true);

          await syncFromFolder(handle);
        } catch (err) {
          if (err.name === 'AbortError') return;
          setError(`Failed to link folder: ${err.message}`);
        }
      }

      async function handleUnlink() {
        try {
          const db = await openSyncDB();
          await db.delete('settings', 'folderHandle');
          await db.delete('settings', 'lastSyncTime');

          setFolderHandle(null);
          setIsLinked(false);
          setLastSync(null);
        } catch (err) {
          console.error('Failed to unlink:', err);
        }
      }

      async function syncFromFolder(handle = folderHandle) {
        if (!handle) return;

        setSyncing(true);
        setError(null);

        try {
          const permission = await handle.requestPermission({ mode: 'read' });
          if (permission !== 'granted') {
            setError('Permission denied. Please re-link the folder.');
            setIsLinked(false);
            return;
          }

          // Player OS: Parse all 10 core state files
          const results = {
            collection: null,
            collectionEnhanced: null,  // For Hall of Armor (variants, splits)
            profile: null,
            mastery: null,
            battlePass: null,
            rewards: null,       // Pity counters for Spotlight Oracle
            tokenShop: null,     // Token shop for Economy Intelligence
            missions: null,      // Mission tracking
            timeModel: null,     // Server time for accurate countdowns
            rank: null,          // Rank info
            decks: null          // Saved decks
          };

          // Map state files to parser methods
          const fileMap = {
            'CollectionState.json': 'collection',
            'ProfileState.json': 'profile',
            'CharacterMasteryState.json': 'mastery',
            'BattlePassState.json': 'battlePass',
            'SeasonPassState.json': 'battlePass',  // Alternative filename
            'RewardState.json': 'rewards',
            'TokenShopState.json': 'tokenShop',
            'CollectorsTokenShopState.json': 'tokenShop',  // Alternative
            'MissionState.json': 'missions',
            'TimeModelState.json': 'timeModel',
            'RankState.json': 'rank',
            'CompetitiveRankState.json': 'rank',  // Alternative
            'DeckState.json': 'decks'
          };

          // Parse each available file
          for (const [filename, key] of Object.entries(fileMap)) {
            try {
              const fileHandle = await handle.getFileHandle(filename);
              const file = await fileHandle.getFile();
              const content = await file.text();
              const json = JSON.parse(content);

              switch (key) {
                case 'collection':
                  results.collection = await GameDataParser.parseCollection(json);
                  // Also parse enhanced collection for Hall of Armor
                  results.collectionEnhanced = GameDataParser.parseCollectionEnhanced(json);
                  break;
                case 'profile':
                  results.profile = GameDataParser.parseProfile(json);
                  break;
                case 'mastery':
                  results.mastery = GameDataParser.parseMastery(json);
                  break;
                case 'battlePass':
                  results.battlePass = GameDataParser.parseBattlePass(json);
                  break;
                case 'rewards':
                  results.rewards = GameDataParser.parseRewardState(json);
                  break;
                case 'tokenShop':
                  results.tokenShop = GameDataParser.parseTokenShopState(json);
                  break;
                case 'missions':
                  results.missions = GameDataParser.parseMissionState(json);
                  break;
                case 'timeModel':
                  results.timeModel = GameDataParser.parseTimeModelState(json);
                  break;
                case 'rank':
                  results.rank = GameDataParser.parseRankState(json);
                  break;
                case 'decks':
                  results.decks = GameDataParser.parseDeckState(json);
                  break;
              }
            } catch (err) {
              // File may not exist - that's OK, continue with others
              console.log(`Could not read ${filename}:`, err.message);
            }
          }

          const importResults = autoImportAll(results);

          const now = new Date();
          const db = await openSyncDB();
          await db.put('settings', now.toISOString(), 'lastSyncTime');
          setLastSync(now);

          showToast(`Sync complete!\n${importResults.map(r => ' ' + r).join('\n')}`);

          if (onSyncComplete) onSyncComplete();
          window.dispatchEvent(new Event('snap-data-updated'));
        } catch (err) {
          setError(`Sync failed: ${err.message}`);
        } finally {
          setSyncing(false);
        }
      }

      if (!isSupported) {
        return (
          <div className="linked-folder-section" style={{ opacity: 0.7 }}>
            <h4>Link Game Folder</h4>
            <div className="not-supported-msg">
              Folder linking requires Chrome or Edge browser.
              <br />
              Use drag & drop below instead.
            </div>
          </div>
        );
      }

      return (
        <div className="linked-folder-section">
          <h4>Link Game Folder</h4>
          <p className="description">
            Link your game data folder once, then sync with one click anytime.
          </p>

          {!isLinked ? (
            <div>
              <button className="link-folder-btn" onClick={handleLinkFolder}>
                Select nvprod Folder
              </button>
              <p style={{ fontSize: '0.75em', color: '#9CA3AF', marginTop: '8px' }}>
                Navigate to:<br />
                <code style={{ background: '#120818', padding: '2px 6px', borderRadius: '4px', color: '#ffd700' }}>
                  %AppData%\LocalLow\Second Dinner\SNAP\Standalone\States\nvprod
                </code>
              </p>
            </div>
          ) : (
            <div className="linked-status">
              <div className="status-row">
                <span className="status-badge linked">Folder Linked</span>
                <button className="unlink-btn" onClick={handleUnlink}>Unlink</button>
              </div>

              <button className="sync-btn" onClick={() => syncFromFolder()} disabled={syncing}>
                {syncing ? 'Syncing...' : 'Sync Now'}
              </button>

              {lastSync && (
                <p className="last-sync">
                  Last synced: {lastSync.toLocaleString()}
                </p>
              )}
            </div>
          )}

          {error && (
            <div style={{ marginTop: '10px', padding: '10px', background: 'rgba(239,68,68,0.2)', borderRadius: '8px', color: '#ef4444', fontSize: '0.85em' }}>
              {error}
            </div>
          )}
        </div>
      );
    };

    // Phase 5: JSON Sync Preview Modal
    const JSONSyncPreviewModal = ({ data, onConfirm, onCancel }) => {
      const [selectedImports, setSelectedImports] = useState({
        collection: !!data.collection,
        stats: !!data.profile,
        cardPerformance: !!data.profile?.cardPerformance,
        mastery: !!data.mastery
      });

      return (
        <div className="modal-overlay">
          <div className="modal sync-preview-modal" style={{ padding: '20px' }}>
            <h3 style={{ margin: '0 0 16px 0', color: '#ffd700', fontFamily: 'Spline Sans, Inter, sans-serif' }}>
              Game Data Found!
            </h3>

            {/* Collection Preview */}
            {data.collection && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.collection}
                    onChange={(e) => setSelectedImports(s => ({...s, collection: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Collection</span>
                </label>
                <div className="preview-stats-grid" style={{ gridTemplateColumns: '1fr' }}>
                  <div className="preview-stat">
                    <span className="value">{data.collection.count}</span>
                    <span className="label">cards found</span>
                  </div>
                </div>
              </div>
            )}

            {/* Profile Stats Preview */}
            {data.profile && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.stats}
                    onChange={(e) => setSelectedImports(s => ({...s, stats: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Lifetime Stats</span>
                </label>
                <div className="preview-stats-grid">
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.totalGames.toLocaleString()}</span>
                    <span className="label">Total Games</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value" style={{ color: '#22c55e' }}>{data.profile.stats.winRate}%</span>
                    <span className="label">Win Rate</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.wins.toLocaleString()}</span>
                    <span className="label">Wins</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.profile.stats.snaps.toLocaleString()}</span>
                    <span className="label">Snaps</span>
                  </div>
                </div>
              </div>
            )}

            {/* Card Performance Preview */}
            {data.profile?.cardPerformance && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.cardPerformance}
                    onChange={(e) => setSelectedImports(s => ({...s, cardPerformance: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Card Performance</span>
                </label>
                <div className="card-performance-preview">
                  <div>
                    <h5 style={{ margin: '0 0 6px 0', fontSize: '0.8em', color: '#22c55e' }}>Best</h5>
                    {data.profile.cardPerformance.top10.slice(0, 3).map((c, i) => (
                      <div key={i} className="card-stat positive">
                        <span className="card-name">{c.card}</span>
                        <span className="cubes">+{c.netCubes}</span>
                      </div>
                    ))}
                  </div>
                  <div>
                    <h5 style={{ margin: '0 0 6px 0', fontSize: '0.8em', color: '#ef4444' }}>Worst</h5>
                    {data.profile.cardPerformance.bottom10.slice(0, 3).map((c, i) => (
                      <div key={i} className="card-stat negative">
                        <span className="card-name">{c.card}</span>
                        <span className="cubes">{c.netCubes}</span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* Mastery Preview */}
            {data.mastery && (
              <div className="preview-section">
                <label className="import-toggle">
                  <input
                    type="checkbox"
                    checked={selectedImports.mastery}
                    onChange={(e) => setSelectedImports(s => ({...s, mastery: e.target.checked}))}
                  />
                  <span style={{ fontWeight: 'bold' }}>Character Mastery</span>
                </label>
                <div className="preview-stats-grid" style={{ gridTemplateColumns: 'repeat(3, 1fr)' }}>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.totalCards}</span>
                    <span className="label">Cards</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.avgLevel}</span>
                    <span className="label">Avg Level</span>
                  </div>
                  <div className="preview-stat">
                    <span className="value">{data.mastery.maxedCards}</span>
                    <span className="label">Maxed</span>
                  </div>
                </div>
              </div>
            )}

            <div style={{ display: 'flex', gap: '10px', marginTop: '16px' }}>
              <button
                onClick={() => onConfirm(data, selectedImports)}
                style={{ flex: 1, padding: '12px', background: '#ad2bee', color: 'white', border: 'none', borderRadius: '8px', fontWeight: 'bold', cursor: 'pointer' }}
              >
                Import Selected
              </button>
              <button
                onClick={onCancel}
                style={{ flex: 1, padding: '12px', background: '#4B5563', color: 'white', border: 'none', borderRadius: '8px', cursor: 'pointer' }}
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Phase 5: Drag & Drop JSON Sync Component
    const DragDropJSONSync = ({ onDataParsed }) => {
      const [dragOver, setDragOver] = useState(false);
      const [processing, setProcessing] = useState(false);
      const fileInputRef = useRef(null);

      const handleFileDrop = async (e) => {
        e.preventDefault();
        setDragOver(false);
        const files = Array.from(e.dataTransfer?.files || []);
        if (files.length > 0) processFiles(files);
      };

      const handleFileSelect = (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length > 0) processFiles(files);
      };

      const processFiles = async (files) => {
        setProcessing(true);

        const results = {
          collection: null,
          profile: null,
          mastery: null,
          battlePass: null
        };

        for (const file of files) {
          try {
            const content = await file.text();
            const json = JSON.parse(content);

            if (file.name === 'CollectionState.json' || file.name.includes('Collection')) {
              results.collection = await GameDataParser.parseCollection(json);
            } else if (file.name === 'ProfileState.json' || file.name.includes('Profile')) {
              results.profile = GameDataParser.parseProfile(json);
            } else if (file.name === 'CharacterMasteryState.json' || file.name.includes('Mastery')) {
              results.mastery = GameDataParser.parseMastery(json);
            } else if (file.name === 'BattlePassState.json' || file.name.includes('BattlePass')) {
              results.battlePass = GameDataParser.parseBattlePass(json);
            } else {
              // Try to detect file type from content
              if (json?.ServerState?.CardInventory) {
                results.collection = await GameDataParser.parseCollection(json);
              } else if (json?.ServerState?.Account) {
                results.profile = GameDataParser.parseProfile(json);
              } else if (json?.ServerState?.CharacterMasteryProgress) {
                results.mastery = GameDataParser.parseMastery(json);
              } else if (json?.ServerState?.BattlePass) {
                results.battlePass = GameDataParser.parseBattlePass(json);
              }
            }
          } catch (err) {
            console.error(`Failed to parse ${file.name}:`, err);
          }
        }

        setProcessing(false);

        if (Object.values(results).some(v => v !== null)) {
          onDataParsed(results);
        } else {
          showToast('No valid game data found in the selected files');
        }
      };

      return (
        <div className="drag-drop-section">
          <h4>Drag & Drop Files</h4>
          <p className="description">Works in all browsers</p>

          <div
            className={`drop-zone-json ${dragOver ? 'drag-over' : ''}`}
            onDrop={handleFileDrop}
            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
            onDragLeave={() => setDragOver(false)}
            onClick={() => fileInputRef.current?.click()}
          >
            {processing ? (
              <div>
                <div className="spinner" style={{ margin: '0 auto 10px' }}></div>
                <span>Processing files...</span>
              </div>
            ) : (
              <>
                <span style={{ fontSize: '2.5em', display: 'block', marginBottom: '8px' }}></span>
                <p style={{ margin: '0 0 8px 0', fontWeight: 'bold' }}>Drop JSON files here</p>
                <p style={{ margin: 0, fontSize: '0.85em', color: '#9CA3AF' }}>
                  CollectionState.json, ProfileState.json, etc.
                </p>
                <code>%AppData%\LocalLow\Second Dinner\SNAP\Standalone\States\nvprod\</code>
              </>
            )}
          </div>

          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileSelect}
            accept=".json"
            multiple
            style={{ display: 'none' }}
          />

          <div style={{ marginTop: '12px', padding: '10px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
            <p style={{ margin: '0 0 6px 0', fontSize: '0.85em', fontWeight: 'bold', color: '#ffd700' }}>Supported Files:</p>
            <ul style={{ margin: 0, paddingLeft: '18px', fontSize: '0.8em', color: '#aaa' }}>
              <li><strong>CollectionState.json</strong> - Your card collection</li>
              <li><strong>ProfileState.json</strong> - Lifetime stats & card performance</li>
              <li><strong>CharacterMasteryState.json</strong> - Card mastery levels</li>
              <li><strong>BattlePassState.json</strong> - Season pass progress</li>
              <li><strong>DeckState.json</strong> - Your saved decks (17+ decks supported)</li>
            </ul>
            <p style={{ margin: '8px 0 0 0', fontSize: '0.8em', color: '#c75fff' }}>
              Tip: Select all 5 files and drop them together!
            </p>
          </div>
        </div>
      );
    };

    // Phase 5: Card Performance View (Analytics Tab)
    const CardPerformanceView = () => {
      const [performanceData, setPerformanceData] = useState(null);
      const [profileStats, setProfileStats] = useState(null);
      const [sortBy, setSortBy] = useState('netCubes');
      const [filterType, setFilterType] = useState('all');

      useEffect(() => {
        loadData();
        window.addEventListener('snap-data-updated', loadData);
        return () => window.removeEventListener('snap-data-updated', loadData);
      }, []);

      const loadData = () => {
        const perfData = loadFromStorage('snap_card_performance', null);
        const stats = loadFromStorage('snap_profile_stats', null);
        setPerformanceData(perfData);
        setProfileStats(stats);
      };

      if (!performanceData && !profileStats) {
        return (
          <div className="px-4 pb-20">
            <Header title="ANALYTICS" />
            <div className="import-prompt" style={{ padding: '40px 20px' }}>
              <p style={{ fontSize: '1.1em', marginBottom: '12px' }}>No game data imported yet.</p>
              <p style={{ fontSize: '0.9em' }}>
                Import your game files from<br />
                <a href="#" onClick={(e) => { e.preventDefault(); }}>Settings &rarr; PC Game Data Sync</a>
              </p>
            </div>
          </div>
        );
      }

      const cards = performanceData ? Object.entries(performanceData.cards)
        .map(([card, data]) => ({ card, ...data }))
        .filter(c => {
          if (filterType === 'positive') return c.netCubes > 0;
          if (filterType === 'negative') return c.netCubes < 0;
          return true;
        })
        .sort((a, b) => {
          if (sortBy === 'name') return a.card.localeCompare(b.card);
          return b.netCubes - a.netCubes;
        }) : [];

      const totalPositive = cards.filter(c => c.netCubes > 0).reduce((sum, c) => sum + c.netCubes, 0);
      const totalNegative = cards.filter(c => c.netCubes < 0).reduce((sum, c) => sum + c.netCubes, 0);

      return (
        <div className="px-4 pb-20">
          <Header title="ANALYTICS" />

          {/* Lifetime Stats */}
          {profileStats && (
            <div className="stats-section">
              <h3>Lifetime Stats</h3>
              <div className="stats-grid">
                <div className="stat-card">
                  <span className="stat-value">{(profileStats.totalGames || profileStats.wins + profileStats.losses).toLocaleString()}</span>
                  <span className="stat-label">Total Games</span>
                </div>
                <div className="stat-card highlight">
                  <span className="stat-value">{profileStats.winRate}%</span>
                  <span className="stat-label">Win Rate</span>
                </div>
                <div className="stat-card positive">
                  <span className="stat-value">{(profileStats.wins || 0).toLocaleString()}</span>
                  <span className="stat-label">Wins</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value">{(profileStats.snaps || 0).toLocaleString()}</span>
                  <span className="stat-label">Snaps</span>
                </div>
              </div>
              {profileStats.snapId && (
                <p className="data-source">
                  {profileStats.snapId}  Imported {new Date(profileStats.importedAt || Date.now()).toLocaleDateString()}
                </p>
              )}
            </div>
          )}

          {/* Currency Stats */}
          {profileStats?.currencies && (
            <div className="stats-section">
              <h3>Currencies</h3>
              <div className="stats-grid" style={{ gridTemplateColumns: 'repeat(3, 1fr)' }}>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#22c55e' }}>{(profileStats.currencies.credits || 0).toLocaleString()}</span>
                  <span className="stat-label">Credits</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#ffd700' }}>{(profileStats.currencies.gold || 0).toLocaleString()}</span>
                  <span className="stat-label">Gold</span>
                </div>
                <div className="stat-card">
                  <span className="stat-value" style={{ color: '#8B5CF6' }}>{(profileStats.currencies.tokens || 0).toLocaleString()}</span>
                  <span className="stat-label">Tokens</span>
                </div>
              </div>
            </div>
          )}

          {/* Card Performance */}
          {performanceData && cards.length > 0 && (
            <>
              <div className="stats-section" style={{ padding: '12px 16px' }}>
                <h3 style={{ marginBottom: '8px' }}>Card Performance</h3>
                <p style={{ margin: 0, fontSize: '0.8em', color: '#9CA3AF' }}>Net cubes earned/lost per card (lifetime)</p>

                <div className="performance-summary" style={{ marginTop: '12px' }}>
                  <div className="summary-stat positive">
                    <span className="label">Gained</span>
                    <span className="value">+{totalPositive.toLocaleString()}</span>
                  </div>
                  <div className="summary-stat negative">
                    <span className="label">Lost</span>
                    <span className="value">{totalNegative.toLocaleString()}</span>
                  </div>
                  <div className="summary-stat net">
                    <span className="label">Net</span>
                    <span className="value">{(totalPositive + totalNegative).toLocaleString()}</span>
                  </div>
                </div>

                <div style={{ display: 'flex', gap: '8px', marginBottom: '12px' }}>
                  <select
                    value={filterType}
                    onChange={(e) => setFilterType(e.target.value)}
                    style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
                  >
                    <option value="all">All Cards ({Object.keys(performanceData.cards).length})</option>
                    <option value="positive">Winners Only</option>
                    <option value="negative">Losers Only</option>
                  </select>
                  <select
                    value={sortBy}
                    onChange={(e) => setSortBy(e.target.value)}
                    style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
                  >
                    <option value="netCubes">By Cubes</option>
                    <option value="name">By Name</option>
                  </select>
                </div>

                <div style={{ maxHeight: '350px', overflowY: 'auto' }}>
                  {cards.map((card, i) => (
                    <div
                      key={card.card}
                      className={`performance-card ${card.netCubes >= 0 ? 'positive' : 'negative'}`}
                    >
                      <span className="rank">#{i + 1}</span>
                      <span className="card-name">{card.card}</span>
                      <span className="net-cubes">
                        {card.netCubes >= 0 ? '+' : ''}{card.netCubes}
                      </span>
                    </div>
                  ))}
                </div>
              </div>

              <p style={{ textAlign: 'center', fontSize: '0.75em', color: '#9CA3AF' }}>
                Data from: {new Date(performanceData.importedAt).toLocaleDateString()}
              </p>
            </>
          )}
        </div>
      );
    };

    // Upgrade Planner Component - Recommends optimal card upgrades
    const UpgradePlanner = () => {
      const [enhancedCollection, setEnhancedCollection] = useState(null);
      const [mastery, setMastery] = useState(null);
      const [sortBy, setSortBy] = useState('efficiency');
      const [filterType, setFilterType] = useState('upgradeable');

      // Upgrade tiers with costs and CL rewards
      const UPGRADE_TIERS = [
        { from: 'Common', to: 'Uncommon', credits: 5, boosters: 5, cl: 1 },
        { from: 'Uncommon', to: 'Rare', credits: 25, boosters: 10, cl: 2 },
        { from: 'Rare', to: 'Epic', credits: 100, boosters: 20, cl: 4 },
        { from: 'Epic', to: 'Legendary', credits: 200, boosters: 30, cl: 8 },
        { from: 'Legendary', to: 'Ultra', credits: 300, boosters: 40, cl: 16 },
        { from: 'Ultra', to: 'Infinity', credits: 400, boosters: 50, cl: 32 }
      ];

      const TIER_ORDER = ['Common', 'Uncommon', 'Rare', 'Epic', 'Legendary', 'Ultra', 'Infinity'];

      useEffect(() => {
        loadData();
        window.addEventListener('snap-data-updated', loadData);
        return () => window.removeEventListener('snap-data-updated', loadData);
      }, []);

      const loadData = () => {
        const enhanced = loadFromStorage('snap_collection_enhanced', null);
        const masteryData = loadFromStorage('snap_mastery', null);
        setEnhancedCollection(enhanced);
        setMastery(masteryData);
      };

      // Get current tier from split level or mastery
      const getCurrentTier = (cardDefId, splitLevel) => {
        // Split levels roughly correspond to tiers: 0=Common, 1=Uncommon, 2=Rare, etc.
        const tierIndex = Math.min(splitLevel || 0, TIER_ORDER.length - 1);
        return TIER_ORDER[tierIndex];
      };

      // Calculate upgrade info for a card
      const getUpgradeInfo = (card) => {
        const currentTierIndex = Math.min(card.splitLevel || 0, TIER_ORDER.length - 2);
        const nextTier = UPGRADE_TIERS[currentTierIndex];

        if (!nextTier) return null; // Already at Infinity

        const boosters = card.boosters || 0;
        const canUpgrade = boosters >= nextTier.boosters;
        const boosterProgress = Math.min(boosters / nextTier.boosters, 1);
        const efficiency = nextTier.cl / nextTier.boosters; // CL per booster spent

        return {
          ...card,
          currentTier: TIER_ORDER[currentTierIndex],
          nextTier: nextTier.to,
          boostersNeeded: nextTier.boosters,
          creditsNeeded: nextTier.credits,
          clGain: nextTier.cl,
          canUpgrade,
          boosterProgress,
          efficiency,
          boostersAvailable: boosters,
          boostersShort: Math.max(0, nextTier.boosters - boosters)
        };
      };

      if (!enhancedCollection) {
        return (
          <div className="px-4 pb-20">
            <Header title="UPGRADE PLANNER" />
            <div className="import-prompt" style={{ padding: '40px 20px', textAlign: 'center' }}>
              <p style={{ fontSize: '3em', marginBottom: '16px' }}>&#x2B06;</p>
              <p style={{ fontSize: '1.1em', marginBottom: '12px' }}>No collection data found.</p>
              <p style={{ fontSize: '0.9em', color: '#9CA3AF' }}>
                Import your CollectionState.json from<br />
                <strong>Settings &rarr; PC Game Data Sync</strong>
              </p>
            </div>
          </div>
        );
      }

      // Process cards with upgrade info
      const cards = (enhancedCollection.cards || [])
        .map(card => getUpgradeInfo(card))
        .filter(card => card !== null);

      // Apply filters
      const filteredCards = cards.filter(card => {
        if (filterType === 'upgradeable') return card.canUpgrade;
        if (filterType === 'close') return !card.canUpgrade && card.boosterProgress >= 0.5;
        return true;
      });

      // Apply sorting
      const sortedCards = [...filteredCards].sort((a, b) => {
        if (sortBy === 'efficiency') return b.efficiency - a.efficiency;
        if (sortBy === 'cl') return b.clGain - a.clGain;
        if (sortBy === 'boosters') return b.boostersAvailable - a.boostersAvailable;
        if (sortBy === 'progress') return b.boosterProgress - a.boosterProgress;
        return a.cardDefId.localeCompare(b.cardDefId);
      });

      // Calculate totals
      const upgradeableCards = cards.filter(c => c.canUpgrade);
      const totalPotentialCL = upgradeableCards.reduce((sum, c) => sum + c.clGain, 0);
      const totalBoosters = enhancedCollection.totalBoosters ||
        cards.reduce((sum, c) => sum + (c.boostersAvailable || 0), 0);
      const totalCreditsNeeded = upgradeableCards.reduce((sum, c) => sum + c.creditsNeeded, 0);

      // Get tier color
      const getTierColor = (tier) => {
        const colors = {
          'Common': '#6B7280',
          'Uncommon': '#22C55E',
          'Rare': '#3B82F6',
          'Epic': '#8B5CF6',
          'Legendary': '#F59E0B',
          'Ultra': '#EC4899',
          'Infinity': '#06B6D4'
        };
        return colors[tier] || '#6B7280';
      };

      return (
        <div className="px-4 pb-20">
          <Header title="UPGRADE PLANNER" />

          {/* Summary Stats */}
          <div className="stats-section" style={{ marginBottom: '16px' }}>
            <div className="stats-grid" style={{ gridTemplateColumns: 'repeat(2, 1fr)' }}>
              <div className="stat-card highlight">
                <span className="stat-value" style={{ color: '#22C55E' }}>+{totalPotentialCL}</span>
                <span className="stat-label">Potential CL</span>
              </div>
              <div className="stat-card">
                <span className="stat-value">{upgradeableCards.length}</span>
                <span className="stat-label">Ready to Upgrade</span>
              </div>
              <div className="stat-card">
                <span className="stat-value" style={{ color: '#8B5CF6' }}>{totalBoosters.toLocaleString()}</span>
                <span className="stat-label">Total Boosters</span>
              </div>
              <div className="stat-card">
                <span className="stat-value" style={{ color: '#ffd700' }}>{totalCreditsNeeded.toLocaleString()}</span>
                <span className="stat-label">Credits Needed</span>
              </div>
            </div>
          </div>

          {/* Top Recommendations */}
          {upgradeableCards.length > 0 && (
            <div style={{
              background: 'linear-gradient(135deg, rgba(34,197,94,0.15), rgba(34,197,94,0.05))',
              border: '2px solid #22C55E',
              borderRadius: '12px',
              padding: '16px',
              marginBottom: '16px'
            }}>
              <h3 style={{ margin: '0 0 12px 0', color: '#22C55E', fontSize: '0.95em' }}>
                &#x1F31F; TOP RECOMMENDATIONS
              </h3>
              {sortedCards.filter(c => c.canUpgrade).slice(0, 3).map((card, i) => (
                <div key={card.cardDefId} style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  padding: '8px 0',
                  borderBottom: i < 2 ? '1px solid rgba(255,255,255,0.1)' : 'none'
                }}>
                  <div>
                    <span style={{ fontWeight: 'bold' }}>{card.cardDefId}</span>
                    <span style={{
                      marginLeft: '8px',
                      fontSize: '0.8em',
                      color: getTierColor(card.currentTier)
                    }}>
                      {card.currentTier} &rarr; {card.nextTier}
                    </span>
                  </div>
                  <div style={{ textAlign: 'right' }}>
                    <span style={{ color: '#22C55E', fontWeight: 'bold' }}>+{card.clGain} CL</span>
                    <span style={{
                      display: 'block',
                      fontSize: '0.75em',
                      color: '#9CA3AF'
                    }}>
                      {card.creditsNeeded} credits
                    </span>
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* Filters and Sort */}
          <div style={{ display: 'flex', gap: '8px', marginBottom: '12px' }}>
            <select
              value={filterType}
              onChange={(e) => setFilterType(e.target.value)}
              style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
            >
              <option value="all">All Cards ({cards.length})</option>
              <option value="upgradeable">Ready ({upgradeableCards.length})</option>
              <option value="close">Close (50%+)</option>
            </select>
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value)}
              style={{ flex: 1, background: '#374151', color: 'white', border: 'none', borderRadius: '6px', padding: '8px' }}
            >
              <option value="efficiency">By Efficiency</option>
              <option value="cl">By CL Gain</option>
              <option value="boosters">By Boosters</option>
              <option value="progress">By Progress</option>
              <option value="name">By Name</option>
            </select>
          </div>

          {/* Card List */}
          <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
            {sortedCards.map((card) => (
              <div
                key={card.cardDefId}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  padding: '12px',
                  marginBottom: '8px',
                  background: card.canUpgrade ? 'rgba(34,197,94,0.1)' : 'rgba(55,65,81,0.5)',
                  borderRadius: '8px',
                  border: card.canUpgrade ? '1px solid rgba(34,197,94,0.3)' : '1px solid transparent'
                }}
              >
                <div style={{ flex: 1 }}>
                  <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>{card.cardDefId}</div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', fontSize: '0.85em' }}>
                    <span style={{ color: getTierColor(card.currentTier) }}>{card.currentTier}</span>
                    <span style={{ color: '#6B7280' }}>&rarr;</span>
                    <span style={{ color: getTierColor(card.nextTier) }}>{card.nextTier}</span>
                  </div>
                  {/* Booster progress bar */}
                  <div style={{
                    marginTop: '6px',
                    background: '#1F2937',
                    borderRadius: '4px',
                    height: '6px',
                    overflow: 'hidden'
                  }}>
                    <div style={{
                      width: `${card.boosterProgress * 100}%`,
                      height: '100%',
                      background: card.canUpgrade ? '#22C55E' : '#8B5CF6',
                      transition: 'width 0.3s'
                    }} />
                  </div>
                  <div style={{ fontSize: '0.75em', color: '#9CA3AF', marginTop: '2px' }}>
                    {card.boostersAvailable}/{card.boostersNeeded} boosters
                    {!card.canUpgrade && card.boostersShort > 0 && (
                      <span style={{ color: '#EF4444' }}> (need {card.boostersShort} more)</span>
                    )}
                  </div>
                </div>
                <div style={{ textAlign: 'right', marginLeft: '12px' }}>
                  <div style={{
                    color: '#22C55E',
                    fontWeight: 'bold',
                    fontSize: '1.1em'
                  }}>+{card.clGain} CL</div>
                  <div style={{ fontSize: '0.75em', color: '#ffd700' }}>{card.creditsNeeded} credits</div>
                  <div style={{
                    fontSize: '0.7em',
                    color: '#9CA3AF',
                    marginTop: '2px'
                  }}>
                    {(card.efficiency).toFixed(2)} CL/booster
                  </div>
                </div>
              </div>
            ))}

            {sortedCards.length === 0 && (
              <div style={{ textAlign: 'center', padding: '40px 20px', color: '#9CA3AF' }}>
                <p>No cards match the current filter.</p>
              </div>
            )}
          </div>

          {/* Efficiency Guide */}
          <div style={{
            marginTop: '16px',
            padding: '12px',
            background: 'rgba(55,65,81,0.3)',
            borderRadius: '8px',
            fontSize: '0.8em'
          }}>
            <h4 style={{ margin: '0 0 8px 0', color: '#ffd700' }}>Upgrade Efficiency Guide</h4>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '4px', color: '#9CA3AF' }}>
              {UPGRADE_TIERS.map(tier => (
                <div key={tier.from} style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span>{tier.from} &rarr; {tier.to}</span>
                  <span style={{ color: '#22C55E' }}>{(tier.cl / tier.boosters).toFixed(2)} CL/b</span>
                </div>
              ))}
            </div>
            <p style={{ margin: '8px 0 0 0', fontSize: '0.9em', color: '#6B7280' }}>
              Tip: Lower tier upgrades are more efficient. Prioritize them for faster CL gains!
            </p>
          </div>
        </div>
      );
    };

    // Settings Component
    const Settings = ({ settings, setSettings, collection, matches, setCollection, setMatches, aiConfig, setAiConfig, decks, setDecks }) => {
      const [showImport, setShowImport] = useState(false);
      const [importData, setImportData] = useState('');
      const [showAdvanced, setShowAdvanced] = useState(false);
      const [testStatus, setTestStatus] = useState({});
      const [rapidApiKey, setRapidApiKey] = useState(loadFromStorage('snap_rapidapi_key', ''));
      const [isRefreshingCards, setIsRefreshingCards] = useState(false);

      // Phase 4: Log Ingestor state
      const [isDragOver, setIsDragOver] = useState(false);
      const [isProcessingLog, setIsProcessingLog] = useState(false);
      const [logError, setLogError] = useState(null);
      const [showLogPreview, setShowLogPreview] = useState(false);
      const [parsedMatches, setParsedMatches] = useState([]);
      const [skippedCount, setSkippedCount] = useState(0);
      const fileInputRef = useRef(null);

      // Phase 4: QR Sync state (generation)
      const [qrDataUrl, setQrDataUrl] = useState(null);
      const [qrCodeParts, setQrCodeParts] = useState([]);
      const [qrPartIndex, setQrPartIndex] = useState(0);

      // Phase 4: QR Sync state (receiving multi-part)
      const [qrScanProgress, setQrScanProgress] = useState(null); // { scanned: [], total: number, missing: [] }
      const [showMultiPartProgress, setShowMultiPartProgress] = useState(false);

      // Performance mode state
      const [performanceMode, setPerformanceMode] = useState(() => {
        const stored = localStorage.getItem('snap_performance_mode');
        return stored || 'auto';
      });
      const [qrError, setQrError] = useState(null);

      // Phase 5: JSON Sync state
      const [showJSONSyncPreview, setShowJSONSyncPreview] = useState(false);
      const [jsonSyncData, setJSONSyncData] = useState(null);

      // Google OAuth 2.0 state
      const [googleSignedIn, setGoogleSignedIn] = useState(isGoogleTokenValid());

      // Google OAuth initialization
      useEffect(() => {
        // Initialize OAuth 2.0 token client
        const initOAuth = () => {
          if (isGoogleOAuthAvailable()) {
            initGoogleOAuth((accessToken) => {
              // Token received callback
              setGoogleSignedIn(true);
              setAiConfig(prev => ({
                ...prev,
                provider: 'gemini-oauth',
                model: AIProviders['gemini-oauth'].defaultModel
              }));
              setTestStatus(prev => ({ ...prev, 'gemini-oauth': 'success' }));
              showToast('Signed in with Google');
            });
          }
        };

        // Try to init now, or wait for script to load
        if (isGoogleOAuthAvailable()) {
          initOAuth();
        } else {
          const checkGoogle = setInterval(() => {
            if (isGoogleOAuthAvailable()) {
              clearInterval(checkGoogle);
              initOAuth();
            }
          }, 500);
          // Stop checking after 10 seconds
          setTimeout(() => clearInterval(checkGoogle), 10000);
        }

        // Check if we have a valid token
        if (isGoogleTokenValid()) {
          setGoogleSignedIn(true);
        }
      }, []);

      const handleGoogleSignIn = async () => {
        try {
          await requestGoogleAccessToken();
          setGoogleSignedIn(true);
          setAiConfig(prev => ({
            ...prev,
            provider: 'gemini-oauth',
            model: AIProviders['gemini-oauth'].defaultModel
          }));
          setTestStatus(prev => ({ ...prev, 'gemini-oauth': 'success' }));
        } catch (err) {
          if (err.message !== 'popup_closed') {
            showToast('Google sign-in failed: ' + err.message);
          }
        }
      };

      const handleGoogleSignOut = () => {
        signOutGoogle();
        setGoogleSignedIn(false);
        setAiConfig(prev => ({ ...prev, provider: '' }));
        setTestStatus(prev => ({ ...prev, 'gemini-oauth': null }));
        showToast('Signed out from Google');
      };

      const setApiKey = (provider, key) => {
        setAiConfig(prev => ({
          ...prev,
          apiKeys: { ...prev.apiKeys, [provider]: key }
        }));
      };

      const selectProvider = (providerId) => {
        const provider = AIProviders[providerId];
        setAiConfig(prev => ({
          ...prev,
          provider: providerId,
          model: provider.defaultModel
        }));
      };

      const testConnection = async (providerId) => {
        setTestStatus(prev => ({ ...prev, [providerId]: 'testing' }));
        try {
          const testMessages = [{ role: 'user', content: 'Say "Connection successful!" in 5 words or less.' }];
          const providerConfig = AIProviders[providerId] || {};
          const model = aiConfig.model || providerConfig.defaultModel;
          const apiKeys = aiConfig.apiKeys || {};

          switch (providerId) {
            case 'gemini-oauth':
              if (!isGoogleTokenValid()) {
                throw new Error('Please sign in with Google first');
              }
              await callGeminiOAuth(testMessages, model);
              break;
            case 'gemini':
              await callGeminiAPIKey(testMessages, model, apiKeys.gemini);
              break;
            case 'groq':
              await callGroq(testMessages, model, apiKeys.groq);
              break;
            case 'claude':
              await callClaude(testMessages, model, apiKeys.claude);
              break;
            case 'openai':
              await callOpenAI(testMessages, model, apiKeys.openai);
              break;
            case 'local':
              await callLocal(testMessages, model, aiConfig.localEndpoint);
              break;
          }
          setTestStatus(prev => ({ ...prev, [providerId]: 'success' }));
        } catch (err) {
          console.error('Test failed:', err);
          setTestStatus(prev => ({ ...prev, [providerId]: 'error' }));
        }
      };

      // CORS proxy helper - uses multiple fallback proxies
      const fetchWithCorsProxy = async (url) => {
        const CORS_PROXIES = [
          (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
          (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`
        ];

        // First try direct fetch (in case CORS is enabled)
        try {
          const directResponse = await fetch(url);
          if (directResponse.ok) return directResponse;
        } catch (e) {
          console.log('Direct fetch failed, trying CORS proxies...');
        }

        // Try each CORS proxy
        for (const proxyFn of CORS_PROXIES) {
          try {
            const proxyUrl = proxyFn(url);
            const response = await fetch(proxyUrl);
            if (response.ok) return response;
          } catch (e) {
            console.log('Proxy failed, trying next...');
          }
        }

        throw new Error('All fetch methods failed (CORS blocked)');
      };

      const refreshCardData = async () => {
        setIsRefreshingCards(true);
        try {
          // Try marvelsnap.io API first (353+ cards)
          let normalizedCards = [];
          try {
            const response = await fetchWithCorsProxy('https://marvelsnap.io/api/search.php?database&limit=500');
            if (response.ok) {
              const data = await response.json();
              normalizedCards = (data || []).filter(c => c.type === 'Character').map(card => {
                const slug = (card.slug || card.name || '').toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                return {
                  name: card.name,
                  cost: parseInt(card.cost) || 0,
                  power: parseInt(card.power) || 0,
                  ability: card.ability || '',
                  series: card.pool?.includes('Pool 1') || card.pool?.includes('Starter') ? 1 :
                          card.pool?.includes('Pool 2') ? 2 :
                          card.pool?.includes('Pool 3') ? 3 :
                          card.pool?.includes('Series 4') ? 4 : 5,
                  art: card.art || card.imageUrl || (slug ? `${CARD_ART_CDN}${slug}.webp?v=787` : '')
                };
              });
            }
          } catch (e) {
            console.log('marvelsnap.io failed, trying MarvelSnapZone...', e.message);
          }

          // Fallback to MarvelSnapZone if marvelsnap.io fails
          if (normalizedCards.length === 0) {
            const response = await fetchWithCorsProxy('https://marvelsnapzone.com/getinfo/?searchtype=cards&searchcardstype=true');
            if (!response.ok) throw new Error('Both APIs failed');
            const data = await response.json();
            normalizedCards = (data.success?.cards || []).map(card => {
              const slug = (card.slug || card.name || '').toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
              return {
                name: card.name,
                cost: parseInt(card.cost) || 0,
                power: parseInt(card.power) || 0,
                ability: card.ability || card.description || '',
                series: parseInt(card.source?.match(/Series (\d)/)?.[1]) || 3,
                art: card.art || card.imageUrl || (slug ? `${CARD_ART_CDN}${slug}.webp?v=787` : '')
              };
            });
          }

          if (normalizedCards.length > 0) {
            saveToStorage('snap_card_cache', { data: normalizedCards, timestamp: Date.now() });
            alert(`Card data refreshed! ${normalizedCards.length} cards loaded.`);
            window.location.reload(); // Reload to apply new card data
          } else {
            throw new Error('No cards returned from API');
          }
        } catch (err) {
          alert('Failed to refresh cards: ' + err.message + '. Using built-in card database.');
        } finally {
          setIsRefreshingCards(false);
        }
      };

      // Handle performance mode change
      const handlePerformanceModeChange = (mode) => {
        setPerformanceMode(mode);
        localStorage.setItem('snap_performance_mode', mode);
        applyPerformanceMode();
        showToast(`Performance mode: ${mode === 'auto' ? 'Auto-detect' : mode === 'low' ? 'Low-end' : 'Full effects'}`);
      };

      // Phase 4: Log file handlers
      const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
      };

      const handleLogDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
        const file = e.dataTransfer?.files[0];
        if (file) processLogFile(file);
      };

      const handleFileSelect = (e) => {
        const file = e.target.files?.[0];
        if (file) processLogFile(file);
      };

      const processLogFile = (file) => {
        setLogError(null);

        // Validate file
        if (!file.name.endsWith('.log') && !file.name.endsWith('.txt')) {
          setLogError('Please select a .log or .txt file');
          return;
        }

        // Size check (50MB limit)
        if (file.size > 50 * 1024 * 1024) {
          setLogError(LogErrors.FILE_TOO_LARGE);
          return;
        }

        setIsProcessingLog(true);

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const content = event.target.result;
            const parsed = LogParser.parsePlayerLog(content);

            if (parsed.matches.length === 0) {
              setLogError(LogErrors.NO_MATCHES);
              setIsProcessingLog(false);
              return;
            }

            // Check for duplicates against existing data
            const merged = LogParser.mergeWithExisting(parsed.matches, matches);

            setParsedMatches(merged.added);
            setSkippedCount(merged.skipped);
            setShowLogPreview(true);
            setIsProcessingLog(false);
          } catch (err) {
            console.error('Log parse error:', err);
            setLogError(LogErrors.PARSE_FAILED);
            setIsProcessingLog(false);
          }
        };

        reader.onerror = () => {
          setLogError(LogErrors.READ_ERROR);
          setIsProcessingLog(false);
        };

        reader.readAsText(file);
      };

      const handleLogImport = (matchesToImport) => {
        setMatches(prev => [...prev, ...matchesToImport].sort((a, b) =>
          new Date(b.timestamp) - new Date(a.timestamp)
        ));
        setShowLogPreview(false);
        setParsedMatches([]);
        alert(`Successfully imported ${matchesToImport.length} matches!`);
      };

      // Phase 5: JSON Sync Confirm Handler
      const handleJSONSyncConfirm = (data, selectedImports) => {
        const timestamp = new Date().toISOString();
        const syncLog = [];

        // Import Collection with validation
        if (selectedImports.collection && data.collection) {
          const existingCollection = JSON.parse(localStorage.getItem('snap_collection') || '{"owned":[]}');
          const mergedCards = [...new Set([...existingCollection.owned, ...data.collection.cards])];

          // Validate cards against database
          const validCardNames = new Set(uniqueCards.map(c => c.name));
          const recognizedCards = mergedCards.filter(name => validCardNames.has(name));
          const unrecognizedCards = mergedCards.filter(name => !validCardNames.has(name));

          const newCollection = {
            owned: mergedCards, // Keep all cards, even unrecognized ones
            lastUpdated: timestamp,
            source: 'JSONImport'
          };
          localStorage.setItem('snap_collection', JSON.stringify(newCollection));
          setCollection(newCollection);

          // Store unrecognized cards for debugging/display
          if (unrecognizedCards.length > 0) {
            localStorage.setItem('snap_unrecognized_cards', JSON.stringify({
              cards: unrecognizedCards,
              importedAt: timestamp
            }));
          }

          syncLog.push(`Collection: ${recognizedCards.length} cards recognized`);
          if (unrecognizedCards.length > 0) {
            syncLog.push(`Unrecognized: ${unrecognizedCards.length} cards (may be new releases)`);
          }
        }

        // Import Profile Stats
        if (selectedImports.stats && data.profile) {
          localStorage.setItem('snap_profile_stats', JSON.stringify({
            ...data.profile.stats,
            snapId: data.profile.player.snapId,
            currencies: data.profile.currencies,
            importedAt: timestamp,
            source: 'ProfileState.json'
          }));

          syncLog.push(`Stats: ${data.profile.stats.totalGames.toLocaleString()} games`);
        }

        // Import Card Performance
        if (selectedImports.cardPerformance && data.profile?.cardPerformance) {
          const performanceMap = {};
          data.profile.cardPerformance.all.forEach(({ card, netCubes }) => {
            performanceMap[card] = { netCubes };
          });

          localStorage.setItem('snap_card_performance', JSON.stringify({
            cards: performanceMap,
            importedAt: timestamp,
            source: 'ProfileState.json'
          }));

          syncLog.push(`Card Performance: ${data.profile.cardPerformance.all.length} cards tracked`);
        }

        // Import Mastery
        if (selectedImports.mastery && data.mastery) {
          localStorage.setItem('snap_mastery', JSON.stringify({
            cards: data.mastery.cards,
            importedAt: timestamp,
            source: 'CharacterMasteryState.json'
          }));

          syncLog.push(`Mastery: ${data.mastery.totalCards} cards`);
        }

        // Update sync history
        const syncHistory = JSON.parse(localStorage.getItem('snap_sync_history') || '[]');
        syncHistory.unshift({
          date: timestamp,
          imported: syncLog
        });
        localStorage.setItem('snap_sync_history', JSON.stringify(syncHistory.slice(0, 10)));

        setShowJSONSyncPreview(false);
        setJSONSyncData(null);

        showToast(`Sync Complete!\n${syncLog.map(r => ' ' + r).join('\n')}`);
        window.dispatchEvent(new Event('snap-data-updated'));
      };

      // Phase 4: QR Code generation with optimized v2 compression and multi-QR fallback
      const generateSyncQR = async () => {
        setQrError(null);
        setQrDataUrl(null);
        setQrCodeParts([]);
        setQrPartIndex(0);

        try {
          // Optimize: Only sync cards that exist in our database
          const validCardNames = new Set(uniqueCards.map(c => c.name));
          const optimizedOwned = (collection.owned || []).filter(name => validCardNames.has(name));

          // Build card name to index mapping for v2 compression
          const cardIndex = {};
          uniqueCards.forEach((card, idx) => {
            cardIndex[card.name] = idx;
          });

          const stats = {
            wins: matches.filter(m => m.result === 'WIN').length,
            losses: matches.filter(m => m.result === 'LOSS').length,
            cubes: matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0)
          };

          // Try v2 compression first (index-based, much smaller)
          let compressed = VaultManager.compressForQRv2(optimizedOwned, stats, cardIndex);
          let useV2 = true;

          // Fallback to v1 if v2 fails
          if (!compressed) {
            useV2 = false;
            const syncData = { v: 1, c: optimizedOwned, s: stats };
            compressed = VaultManager.compressForQR(syncData);
          }

          if (!compressed) {
            setQrError('Failed to compress data');
            return;
          }

          // QR capacity: ~2953 chars for version 40 with L error correction
          // Use conservative limit for reliable mobile scanning
          const QR_CAPACITY = 2200;
          const BASE_URL = 'https://platano78.github.io/Marvel-Snap-Tactics-/';
          const SINGLE_URL_OVERHEAD = BASE_URL.length + (useV2 ? '?sync2='.length : '?sync='.length);
          const MULTI_URL_OVERHEAD = BASE_URL.length + '?sync_part2='.length + 20;

          if (compressed.length + SINGLE_URL_OVERHEAD <= QR_CAPACITY) {
            // Single QR code fits
            const syncParam = useV2 ? 'sync2' : 'sync';
            const syncUrl = `${BASE_URL}?${syncParam}=${compressed}`;
            const dataUrl = await QRCode.toDataURL(syncUrl, {
              width: 200,
              margin: 2,
              errorCorrectionLevel: 'M',
              color: { dark: '#1A1A1A', light: '#FFFFFF' }
            });
            setQrDataUrl(dataUrl);
          } else {
            // Calculate optimal chunk size based on QR capacity
            const availablePerChunk = QR_CAPACITY - MULTI_URL_OVERHEAD;
            const numChunks = Math.ceil(compressed.length / availablePerChunk);
            const chunkSize = Math.ceil(compressed.length / numChunks);

            const chunks = [];
            for (let i = 0; i < compressed.length; i += chunkSize) {
              chunks.push(compressed.slice(i, i + chunkSize));
            }

            const qrUrls = [];
            for (let i = 0; i < chunks.length; i++) {
              // Create payload with checksum for integrity
              const partPayload = VaultManager.createMultiPartPayload(chunks[i], i + 1, chunks.length);
              const encodedPayload = LZString.compressToEncodedURIComponent(JSON.stringify(partPayload));

              const partUrl = `${BASE_URL}?sync_part2=${encodedPayload}`;
              const dataUrl = await QRCode.toDataURL(partUrl, {
                width: 200,
                margin: 2,
                errorCorrectionLevel: 'M',
                color: { dark: '#1A1A1A', light: '#FFFFFF' }
              });
              qrUrls.push(dataUrl);
            }

            setQrCodeParts(qrUrls);
            setQrPartIndex(0);
            setQrDataUrl(qrUrls[0]);
            setQrError(`Large collection: ${qrUrls.length} QR codes needed. Scan each in order.`);
          }
        } catch (err) {
          console.error('QR generation error:', err);
          setQrError('Failed to generate QR code');
        }
      };

      // Phase 4: Vault export
      const exportVault = () => {
        const vault = VaultManager.exportFullVault(collection, matches, settings);
        const blob = new Blob([JSON.stringify(vault, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `snapapoulous-vault-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      };

      const handleExport = (type) => {
        let data, filename;
        if (type === 'all') {
          data = { collection, matches, decks, settings, aiConfig: { ...aiConfig, apiKeys: {}, googleToken: null } };
          filename = `snapapoulous-backup-${new Date().toISOString().split('T')[0]}.json`;
        } else if (type === 'collection') {
          data = collection;
          filename = `snap-collection-${new Date().toISOString().split('T')[0]}.json`;
        } else if (type === 'decks') {
          data = decks;
          filename = `snap-decks-${new Date().toISOString().split('T')[0]}.json`;
        } else {
          data = matches;
          filename = `snap-matches-${new Date().toISOString().split('T')[0]}.json`;
        }
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
      };

      const handleImport = () => {
        try {
          const data = JSON.parse(importData);
          if (data.collection && data.matches) {
            setCollection(data.collection);
            setMatches(data.matches);
            if (data.decks) setDecks(data.decks);
            if (data.settings) setSettings(data.settings);
            alert('Data imported successfully!');
          } else if (data.owned) {
            setCollection(data);
            alert('Collection imported!');
          } else if (Array.isArray(data) && data[0]?.cards) {
            setDecks(data);
            alert('Decks imported!');
          } else if (Array.isArray(data)) {
            setMatches(data);
            alert('Matches imported!');
          } else {
            alert('Unrecognized format');
          }
          setShowImport(false);
          setImportData('');
        } catch { alert('Invalid JSON'); }
      };

      const StatusBadge = ({ status }) => {
        if (!status) return null;
        if (status === 'testing') return <span className="text-yellow-400 text-xs">Testing...</span>;
        if (status === 'success') return <span className="text-green-400 text-xs">Connected</span>;
        return <span className="text-red-400 text-xs">Failed</span>;
      };

      const mainProviders = Object.values(AIProviders).filter(p => !p.advanced);
      const advancedProviders = Object.values(AIProviders).filter(p => p.advanced);

      return (
        <div className="px-4 pb-20">
          <Header title="SETTINGS" />

          {/* App Info */}
          <div className="stitch-card p-5 mb-4">
            <div className="flex items-center gap-3">
              <div className="w-12 h-12 bg-mcu-blue rounded-lg flex items-center justify-center">
                <span className="text-2xl font-display font-bold text-white">S</span>
              </div>
              <div>
                <div className="text-white font-bold">Snapapoulous Prime</div>
                <div className="text-stitch-muted text-sm">v3.0.0 - Stitch Design Rebuild</div>
              </div>
            </div>
          </div>

          {/* Quick Navigation - More Features */}
          <div className="stitch-card p-5 mb-4">
            <div className="stitch-section-header">
              <span className="material-symbols-outlined" aria-hidden="true">apps</span>
              More Features
            </div>
            <div className="grid grid-cols-3 gap-2">
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'profile' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">person</span>
                <span className="text-white text-sm">Profile</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'meta' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">leaderboard</span>
                <span className="text-white text-sm">Meta Tiers</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'ai' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">smart_toy</span>
                <span className="text-white text-sm">AI Advisor</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'missions' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">assignment</span>
                <span className="text-white text-sm">Missions</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'battlepass' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">confirmation_number</span>
                <span className="text-white text-sm">Battle Pass</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'armor' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">military_tech</span>
                <span className="text-white text-sm">Hall of Armor</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'calculator' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">calculate</span>
                <span className="text-white text-sm">Calculator</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'decks' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">style</span>
                <span className="text-white text-sm">Decks</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'simulator' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">sports_esports</span>
                <span className="text-white text-sm">Simulator</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'economy' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">account_balance</span>
                <span className="text-white text-sm">Economy HQ</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'board' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">target</span>
                <span className="text-white text-sm">Board Snap</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'oracle' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">auto_awesome</span>
                <span className="text-white text-sm">Oracle</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'history' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">history</span>
                <span className="text-white text-sm">Match History</span>
              </button>
              <button
                onClick={() => window.dispatchEvent(new CustomEvent('setActiveTab', { detail: 'planner' }))}
                className="stitch-list-item p-3 flex flex-col items-center"
              >
                <span className="material-symbols-outlined text-2xl mb-1 text-cosmic-purple-text" aria-hidden="true">upgrade</span>
                <span className="text-white text-sm">Upgrade Plan</span>
              </button>
            </div>
          </div>

          {/* PC Game Data Sync - Phase 5 */}
          <div className="stitch-card p-5 mb-4 pc-sync-section">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">PC Game Data Sync</h3>
            <p className="text-stitch-muted text-sm mb-4">
              Import your collection, stats, and card performance directly from game files.
            </p>

            {/* Method 1: Linked Folder (Chrome/Edge) */}
            <LinkedFolderSync onSyncComplete={() => {
              setCollection(loadFromStorage('snap_collection', { owned: [], lastUpdated: new Date().toISOString() }));
            }} />

            <div className="sync-divider">
              <span>or</span>
            </div>

            {/* Method 2: Drag & Drop JSON (All Browsers) */}
            <DragDropJSONSync onDataParsed={(data) => {
              setJSONSyncData(data);
              setShowJSONSyncPreview(true);
            }} />
          </div>

          {/* QR Sync - Phase 4 */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Cross-Device Sync</h3>
            <p className="text-stitch-muted text-sm mb-4">
              Generate a QR code to quickly sync your collection to another device.
            </p>

            <button
              onClick={generateSyncQR}
              className="w-full bg-mcu-blue text-white py-3 rounded-lg font-medium hover:bg-blue-600 mb-3"
            >
               Generate Sync QR Code
            </button>

            {qrError && (
              <div className={`border rounded-lg p-3 mb-3 ${qrCodeParts.length > 0 ? 'bg-yellow-900/50 border-yellow-500' : 'bg-red-900/50 border-red-500'}`}>
                <p className={`text-sm ${qrCodeParts.length > 0 ? 'text-yellow-300' : 'text-red-300'}`}>{qrError}</p>
              </div>
            )}

            {qrDataUrl && (
              <div className="text-center">
                <div className="qr-container inline-block mb-2">
                  <img src={qrDataUrl} alt="Sync QR Code" width="200" height="200" loading="lazy" />
                </div>
                {qrCodeParts.length > 1 ? (
                  <div className="flex items-center justify-center gap-2 mb-2">
                    <button
                      onClick={() => {
                        const newIndex = Math.max(0, qrPartIndex - 1);
                        setQrPartIndex(newIndex);
                        setQrDataUrl(qrCodeParts[newIndex]);
                      }}
                      disabled={qrPartIndex === 0}
                      className="px-3 py-1 bg-[#1a1320] text-white rounded disabled:opacity-50"
                    >
                       Prev
                    </button>
                    <span className="text-stitch-muted text-sm">
                      QR {qrPartIndex + 1} of {qrCodeParts.length}
                    </span>
                    <button
                      onClick={() => {
                        const newIndex = Math.min(qrCodeParts.length - 1, qrPartIndex + 1);
                        setQrPartIndex(newIndex);
                        setQrDataUrl(qrCodeParts[newIndex]);
                      }}
                      disabled={qrPartIndex === qrCodeParts.length - 1}
                      className="px-3 py-1 bg-[#1a1320] text-white rounded disabled:opacity-50"
                    >
                      Next 
                    </button>
                  </div>
                ) : null}
                <p className="text-stitch-muted text-xs">Scan with your phone camera to sync collection</p>
              </div>
            )}

            {/* Multi-part QR scanning progress (shown on receiving device) */}
            {showMultiPartProgress && qrScanProgress && (
              <div className="mt-4 bg-blue-900/30 border border-blue-500 rounded-lg p-4">
                <h4 className="text-blue-300 font-medium mb-2">Multi-Part Sync Progress</h4>
                <div className="flex items-center gap-2 mb-2">
                  <div className="flex-1 bg-[#1a1320] rounded-full h-3">
                    <div
                      className="bg-mcu-blue h-3 rounded-full transition-all"
                      style={{ width: `${(qrScanProgress.scanned.length / qrScanProgress.total) * 100}%` }}
                    />
                  </div>
                  <span className="text-sm text-gray-300">
                    {qrScanProgress.scanned.length}/{qrScanProgress.total}
                  </span>
                </div>

                <div className="flex flex-wrap gap-1 mb-3">
                  {Array.from({ length: qrScanProgress.total }, (_, i) => i + 1).map(partNum => (
                    <span
                      key={partNum}
                      className={`px-2 py-1 text-xs rounded ${
                        qrScanProgress.scanned.includes(partNum)
                          ? 'bg-green-600 text-white'
                          : 'bg-[#2b1933] text-gray-300'
                      }`}
                    >
                      {partNum}
                    </span>
                  ))}
                </div>

                {qrScanProgress.missing.length > 0 && (
                  <p className="text-sm text-yellow-300 mb-2">
                    Missing: QR {qrScanProgress.missing.join(', ')}
                  </p>
                )}

                <div className="flex gap-2">
                  <button
                    onClick={() => {
                      localStorage.removeItem('snap_qr_scan_progress');
                      setQrScanProgress(null);
                      setShowMultiPartProgress(false);
                    }}
                    className="flex-1 px-3 py-2 bg-red-700 text-white rounded text-sm hover:bg-red-600"
                  >
                    Cancel Sync
                  </button>
                  <button
                    onClick={() => {
                      setShowMultiPartProgress(false);
                    }}
                    className="flex-1 px-3 py-2 bg-[#2b1933] text-white rounded text-sm hover:bg-[#3c2348]"
                  >
                    Hide Progress
                  </button>
                </div>
              </div>
            )}
          </div>

          {/* AI Provider Configuration */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-4">AI Provider</h3>

            {/* Google OAuth - Primary */}
            <div className="mb-4 p-4 bg-[#1a1320] rounded-lg border-2 border-mcu-blue">
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2">
                  <span className="text-white font-medium">Google (Gemini)</span>
                  <span className="bg-mcu-blue text-white text-xs px-2 py-0.5 rounded">Recommended</span>
                </div>
                <StatusBadge status={testStatus['gemini-oauth']} />
              </div>
              <p className="text-stitch-muted text-sm mb-3">One-click sign in, no API key needed</p>

              {googleSignedIn ? (
                <div className="space-y-2">
                  <div className="flex gap-2">
                    <button onClick={() => selectProvider('gemini-oauth')}
                      className={`flex-1 py-2 rounded font-medium ${aiConfig.provider === 'gemini-oauth' ? 'bg-mcu-blue text-white' : 'bg-[#2b1933] text-gray-300'}`}>
                      {aiConfig.provider === 'gemini-oauth' ? 'Selected' : 'Use This'}
                    </button>
                    <button onClick={() => testConnection('gemini-oauth')}
                      className="bg-[#2b1933] text-white px-4 py-2 rounded hover:bg-[#3c2348]">Test</button>
                    <button onClick={handleGoogleSignOut}
                      className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-500">Sign Out</button>
                  </div>
                  {/* Model selector for Gemini OAuth */}
                  {aiConfig.provider === 'gemini-oauth' && (
                    <div className="mt-2">
                      <label className="text-stitch-muted text-xs mb-1 block">Select Model:</label>
                      <select
                        value={aiConfig.model || AIProviders['gemini-oauth'].defaultModel}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                        className="w-full bg-[#2b1933] text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-mcu-blue focus:outline-none">
                        {AIProviders['gemini-oauth'].models.map(m => (
                          <option key={m} value={m}>{m}</option>
                        ))}
                      </select>
                      <p className="text-gray-500 text-xs mt-1">Gemini 3 models are preview versions with latest capabilities</p>
                    </div>
                  )}
                </div>
              ) : (
                <div>
                  <button onClick={handleGoogleSignIn}
                    className="w-full bg-white text-gray-800 py-3 rounded-lg font-medium flex items-center justify-center gap-2 hover:bg-gray-100">
                    <svg className="w-5 h-5" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Continue with Google
                  </button>
                </div>
              )}
            </div>

            {/* API Key Providers */}
            {mainProviders.filter(p => p.id !== 'gemini-oauth').map(provider => (
              <div key={provider.id} className="mb-3 p-3 bg-[#1a1320] rounded-lg">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-white font-medium">{provider.name}</span>
                  <StatusBadge status={testStatus[provider.id]} />
                </div>
                <p className="text-stitch-muted text-xs mb-2">{provider.description}</p>
                <div className="flex gap-2">
                  <input type="password" placeholder="API Key..."
                    value={aiConfig.apiKeys?.[provider.id] || ''}
                    onChange={(e) => setApiKey(provider.id, e.target.value)}
                    aria-label={provider.name + ' API Key'}
                    className="flex-1 bg-[#2b1933] text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20" />
                  <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                    disabled={!aiConfig.apiKeys?.[provider.id]}
                    className="bg-mcu-blue text-white px-3 py-2 rounded text-sm hover:bg-blue-600 disabled:opacity-50">
                    Test
                  </button>
                </div>
                {aiConfig.provider === provider.id && (
                  <div className="mt-2">
                    <select value={aiConfig.model || provider.defaultModel}
                      onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                      className="w-full bg-[#2b1933] text-white rounded px-2 py-1 text-sm border border-gray-500">
                      {provider.models.map(m => <option key={m} value={m}>{m}</option>)}
                    </select>
                  </div>
                )}
              </div>
            ))}

            {/* Advanced Section */}
            <button onClick={() => setShowAdvanced(!showAdvanced)}
              className="w-full flex items-center justify-between py-2 text-stitch-muted hover:text-white">
              <span className="text-sm">Advanced Options</span>
              <span>{showAdvanced ? '' : ''}</span>
            </button>

            {showAdvanced && (
              <div className="mt-3 space-y-3">
                {advancedProviders.map(provider => (
                  <div key={provider.id} className="p-3 bg-[#1a1320] rounded-lg">
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-white font-medium">{provider.name}</span>
                      <StatusBadge status={testStatus[provider.id]} />
                    </div>
                    <p className="text-stitch-muted text-xs mb-2">{provider.description}</p>
                    <div className="flex gap-2">
                      <input type="text"
                        placeholder="http://localhost:11434"
                        value={aiConfig.localEndpoint || ''}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, localEndpoint: e.target.value }))}
                        className="flex-1 bg-[#2b1933] text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20" />
                      <button onClick={() => { selectProvider(provider.id); testConnection(provider.id); }}
                        className="bg-[#2b1933] text-white px-3 py-2 rounded text-sm hover:bg-[#3c2348]">Test</button>
                    </div>
                    <p className="text-gray-500 text-xs mt-1">Common ports: Ollama (11434), LM Studio (1234), vLLM (8000)</p>
                    {aiConfig.provider === provider.id && (
                      <input type="text" placeholder="Model name..."
                        value={aiConfig.model || ''}
                        onChange={(e) => setAiConfig(prev => ({ ...prev, model: e.target.value }))}
                        className="w-full mt-2 bg-[#2b1933] text-white rounded px-3 py-2 text-sm border border-gray-500 focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20" />
                    )}
                  </div>
                ))}
              </div>
            )}

            {/* Current Selection */}
            {aiConfig.provider && (
              <div className="mt-4 p-3 bg-green-900/30 border border-green-600 rounded-lg">
                <div className="text-green-400 text-sm">
                  Active: <strong>{AIProviders[aiConfig.provider]?.name}</strong>
                  {aiConfig.model && <span className="text-green-300"> ({aiConfig.model})</span>}
                </div>
              </div>
            )}
          </div>

          {/* AI Context Settings - Phase 4 */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">AI Context</h3>
            <p className="text-stitch-muted text-sm mb-3">
              Configure how much context Snapapoulous has access to for personalized advice.
            </p>

            {/* Enhanced Persona Toggle */}
            <div className="flex items-center justify-between py-2 border-b border-[rgba(173,43,238,0.2)]">
              <div>
                <span className="text-white font-medium">Enhanced AI Context</span>
                <p className="text-gray-500 text-xs mt-1">
                  Includes rich match analysis, collection gaps, meta context, and persona from persona.json
                </p>
              </div>
              <button
                onClick={() => setSettings(prev => ({ ...prev, useSimplePersona: !prev.useSimplePersona }))}
                className={`relative w-12 h-6 rounded-full transition-colors ${
                  !settings.useSimplePersona ? 'bg-series-2' : 'bg-[#2b1933]'
                }`}
              >
                <span className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${
                  !settings.useSimplePersona ? 'left-7' : 'left-1'
                }`} />
              </button>
            </div>

            {/* Context Preview */}
            {!settings.useSimplePersona && (
              <div className="mt-3 p-3 bg-[#1a1320] rounded-lg text-xs text-gray-300">
                <p className="font-medium text-mcu-gold mb-2">Context includes:</p>
                <ul className="space-y-1 list-disc list-inside">
                  <li>Current date & season (Dragons Season)</li>
                  <li>Your match history analysis (trends, streaks, deck performance)</li>
                  <li>Collection gaps & playable archetypes</li>
                  <li>Recent OTA balance changes</li>
                  <li>Current meta tier list</li>
                  <li>Full persona from persona.json</li>
                </ul>
              </div>
            )}

            {settings.useSimplePersona && (
              <div className="mt-3 p-3 bg-[#1a1320] rounded-lg text-xs text-gray-300">
                <p className="font-medium text-stitch-muted mb-2">Simplified mode active:</p>
                <p>Basic stats only. Faster responses but less personalized advice.</p>
              </div>
            )}
          </div>

          {/* Card Database */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Card Database</h3>
            <p className="text-stitch-muted text-sm mb-3">Fetch latest card data from MarvelSnapZone. No API key required.</p>
            <button onClick={refreshCardData} disabled={isRefreshingCards}
              className="w-full bg-series-3 text-white py-2 rounded hover:opacity-80 disabled:opacity-50">
              {isRefreshingCards ? 'Refreshing...' : 'Refresh Card Data'}
            </button>
            <p className="text-gray-500 text-xs mt-2">
              Data source: <a href="https://marvelsnapzone.com" target="_blank" className="text-mcu-blue hover:underline">MarvelSnapZone</a>
            </p>
          </div>

          {/* Performance Mode */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Performance Mode</h3>
            <p className="text-stitch-muted text-sm mb-3">
              Reduce animations and effects to improve performance on older devices or save battery.
            </p>
            <div className="grid grid-cols-3 gap-2">
              <button
                onClick={() => handlePerformanceModeChange('auto')}
                className={`py-3 rounded-lg font-medium text-sm transition-colors ${
                  performanceMode === 'auto'
                    ? 'bg-mcu-blue text-white'
                    : 'bg-[#1a1320] text-gray-300 hover:bg-[#2b1933]'
                }`}
              >
                Auto
              </button>
              <button
                onClick={() => handlePerformanceModeChange('high')}
                className={`py-3 rounded-lg font-medium text-sm transition-colors ${
                  performanceMode === 'high'
                    ? 'bg-series-2 text-white'
                    : 'bg-[#1a1320] text-gray-300 hover:bg-[#2b1933]'
                }`}
              >
                Full Effects
              </button>
              <button
                onClick={() => handlePerformanceModeChange('low')}
                className={`py-3 rounded-lg font-medium text-sm transition-colors ${
                  performanceMode === 'low'
                    ? 'bg-series-4 text-black'
                    : 'bg-[#1a1320] text-gray-300 hover:bg-[#2b1933]'
                }`}
              >
                Low-End
              </button>
            </div>
            <p className="text-gray-500 text-xs mt-2">
              {performanceMode === 'auto' && 'Automatically detects device capabilities, battery level, and connection speed.'}
              {performanceMode === 'high' && 'All animations and effects enabled for the best visual experience.'}
              {performanceMode === 'low' && 'Minimal animations for smoother performance on any device.'}
            </p>
            {document.body.classList.contains('low-end-mode') && (
              <div className="mt-2 text-xs text-mcu-gold flex items-center gap-1">
                <span>Currently running in low-end mode</span>
              </div>
            )}
          </div>

          {/* Reduced Motion */}
          <div className="stitch-card p-5 mb-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-lg font-display font-semibold text-[#c75fff]">Reduce Motion</h3>
                <p className="text-stitch-muted text-sm mt-1">
                  Disable animations for accessibility or to reduce visual distractions.
                </p>
              </div>
              <button
                onClick={() => {
                  const newValue = !settings.reducedMotion;
                  setSettings(s => ({ ...s, reducedMotion: newValue }));
                  setReducedMotion(newValue);
                  showToast(newValue ? 'Motion reduced' : 'Motion enabled');
                }}
                className={`relative w-14 h-8 rounded-full transition-colors ${
                  settings.reducedMotion ? 'bg-mcu-blue' : 'bg-[#2b1933]'
                }`}
                aria-label={settings.reducedMotion ? 'Disable reduced motion' : 'Enable reduced motion'}
                role="switch"
                aria-checked={settings.reducedMotion}
              >
                <span className={`absolute top-1 left-1 w-6 h-6 rounded-full bg-white shadow-md transform transition-transform ${
                  settings.reducedMotion ? 'translate-x-6' : 'translate-x-0'
                }`} />
              </button>
            </div>
            {window.matchMedia('(prefers-reduced-motion: reduce)').matches && !settings.reducedMotion && (
              <p className="text-mcu-gold text-xs mt-3 flex items-center gap-1">
                <span>Your system prefers reduced motion. Consider enabling this setting.</span>
              </p>
            )}
          </div>

          {/* Export/Import */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Export Data</h3>
            <div className="space-y-2 mb-4">
              <button onClick={exportVault} className="w-full bg-mcu-gold text-black py-3 rounded-lg font-medium hover:bg-yellow-400 flex items-center justify-center gap-2">
                <span></span> Export Full Vault (Recommended)
              </button>
              <div className="grid grid-cols-4 gap-2">
                <button onClick={() => handleExport('all')} className="bg-mcu-blue text-white py-2 rounded text-sm hover:bg-blue-600">Backup</button>
                <button onClick={() => handleExport('collection')} className="bg-series-3 text-white py-2 rounded text-sm hover:opacity-80">Collection</button>
                <button onClick={() => handleExport('matches')} className="bg-series-2 text-white py-2 rounded text-sm hover:opacity-80">Matches</button>
                <button onClick={() => handleExport('decks')} className="bg-series-4 text-black py-2 rounded text-sm hover:opacity-80">Decks</button>
              </div>
            </div>

            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Import Data</h3>
            {!showImport ? (
              <button onClick={() => setShowImport(true)} className="w-full bg-[#1a1320] text-white py-2 rounded hover:bg-[#2b1933]">
                Import from JSON
              </button>
            ) : (
              <div className="space-y-2">
                <textarea value={importData} onChange={(e) => setImportData(e.target.value)}
                  placeholder="Paste JSON data here..."
                  className="w-full h-24 bg-[#1a1320] text-white rounded px-3 py-2 border-2 border-[rgba(173,43,238,0.3)] focus:border-mcu-blue focus:outline-none focus:ring-2 focus:ring-mcu-blue/20 text-sm" />
                <div className="flex gap-2">
                  <button onClick={handleImport} className="flex-1 bg-mcu-blue text-white py-2 rounded hover:bg-blue-600">Import</button>
                  <button onClick={() => { setShowImport(false); setImportData(''); }} className="flex-1 bg-[#2b1933] text-white py-2 rounded hover:bg-[#3c2348]">Cancel</button>
                </div>
              </div>
            )}
          </div>

          {/* Danger Zone */}
          <div className="stitch-card p-5 border-red-500/50">
            <h3 className="text-lg font-display font-semibold text-mcu-red mb-3">Danger Zone</h3>
            <button onClick={() => {
              if (confirm('Clear ALL data including AI settings?')) {
                localStorage.clear();
                setCollection({ owned: [], lastUpdated: new Date().toISOString() });
                setMatches([]);
                setDecks([]);
                setSettings({ theme: 'dark' });
                setAiConfig({ provider: '', model: '', apiKeys: {}, googleToken: null, localEndpoint: 'http://localhost:11434' });
                alert('All data cleared');
              }
            }} className="w-full bg-red-600 text-white py-2 rounded hover:bg-red-500">Clear All Data</button>
          </div>

          {/* Log Preview Modal */}
          {showLogPreview && (
            <LogPreviewModal
              matches={parsedMatches}
              skippedCount={skippedCount}
              onConfirm={handleLogImport}
              onCancel={() => { setShowLogPreview(false); setParsedMatches([]); }}
            />
          )}

          {/* JSON Sync Preview Modal - Phase 5 */}
          {showJSONSyncPreview && jsonSyncData && (
            <JSONSyncPreviewModal
              data={jsonSyncData}
              onConfirm={handleJSONSyncConfirm}
              onCancel={() => { setShowJSONSyncPreview(false); setJSONSyncData(null); }}
            />
          )}
        </div>
      );
    };

    // ==================== MISSION TRACKER ====================
    const MissionTracker = () => {
      const [missions, setMissions] = useState(() =>
        loadFromStorage('snap_missions', {
          daily: [],
          weekly: [],
          dailyCompleted: 0,
          weeklyCompleted: 0
        })
      );

      // Calculate completion percentages
      const dailyProgress = missions.daily.length > 0
        ? Math.round((missions.dailyCompleted / missions.daily.length) * 100)
        : 0;
      const weeklyProgress = missions.weekly.length > 0
        ? Math.round((missions.weeklyCompleted / missions.weekly.length) * 100)
        : 0;

      // Mission progress bar component
      const MissionProgressBar = ({ progress, target, completed }) => {
        const percentage = target > 0 ? Math.min((progress / target) * 100, 100) : 0;
        const barColor = completed ? 'bg-series-2' : 'bg-mcu-blue';

        return (
          <div className="w-full bg-[#1a1320] rounded-full h-3 overflow-hidden">
            <div
              className={`h-full rounded-full transition-all duration-300 ${barColor}`}
              style={{ width: `${percentage}%` }}
            />
          </div>
        );
      };

      // Single mission item component
      const MissionItem = ({ mission }) => {
        const borderColor = mission.completed ? 'border-series-2' : 'border-mcu-blue';
        const textColor = mission.completed ? 'text-series-2' : 'text-white';

        return (
          <div className={`stitch-card p-5 border-l-4 ${borderColor} mb-3 ${mission.completed ? 'opacity-75' : ''}`}>
            <div className="flex justify-between items-start mb-2">
              <p className={`font-medium ${textColor} flex-1`}>
                {mission.description}
                {mission.completed && <span className="ml-2 text-series-2">&#10003;</span>}
              </p>
              <span className="text-mcu-gold text-sm font-bold ml-2 whitespace-nowrap">
                {mission.reward}
              </span>
            </div>
            <div className="flex items-center gap-3">
              <MissionProgressBar
                progress={mission.progress}
                target={mission.target}
                completed={mission.completed}
              />
              <span className={`text-sm ${mission.completed ? 'text-series-2' : 'text-stitch-muted'} whitespace-nowrap min-w-[60px] text-right`}>
                {mission.progress}/{mission.target}
              </span>
            </div>
          </div>
        );
      };

      // Empty state message
      const EmptyMissions = ({ type }) => (
        <div className="stitch-card p-6 text-center">
          <p className="text-stitch-muted">No {type} missions tracked yet.</p>
          <p className="text-gray-500 text-sm mt-2">
            Import your game data to see missions here.
          </p>
        </div>
      );

      return (
        <div className="px-4 pb-20">
          <Header title="MISSIONS" />

          {/* Overall Progress Summary */}
          <div className="grid grid-cols-2 gap-3 mb-6">
            <div className="stitch-card p-5 text-center">
              <div className="text-3xl font-display font-bold text-mcu-gold">{dailyProgress}%</div>
              <div className="text-stitch-muted text-sm">Daily Progress</div>
            </div>
            <div className="stitch-card p-5 text-center">
              <div className="text-3xl font-display font-bold text-mcu-gold">{weeklyProgress}%</div>
              <div className="text-stitch-muted text-sm">Weekly Progress</div>
            </div>
          </div>

          {/* Daily Missions Section */}
          <div className="mb-6">
            <div className="flex items-center justify-between mb-3">
              <h2 className="text-xl font-display font-semibold text-[#c75fff]">Daily Missions</h2>
              <span className="text-stitch-muted text-sm">
                {missions.dailyCompleted}/{missions.daily.length} Complete
              </span>
            </div>
            {missions.daily.length > 0 ? (
              missions.daily.map((mission) => (
                <MissionItem key={mission.id} mission={mission} />
              ))
            ) : (
              <EmptyMissions type="daily" />
            )}
          </div>

          {/* Weekly Missions Section */}
          <div className="mb-6">
            <div className="flex items-center justify-between mb-3">
              <h2 className="text-xl font-display font-semibold text-[#c75fff]">Weekly Missions</h2>
              <span className="text-stitch-muted text-sm">
                {missions.weeklyCompleted}/{missions.weekly.length} Complete
              </span>
            </div>
            {missions.weekly.length > 0 ? (
              missions.weekly.map((mission) => (
                <MissionItem key={mission.id} mission={mission} />
              ))
            ) : (
              <EmptyMissions type="weekly" />
            )}
          </div>

          {/* Info Note */}
          <div className="bg-[#120818]/50 rounded-lg p-4 border border-[rgba(173,43,238,0.2)]">
            <p className="text-stitch-muted text-sm">
              <span className="text-mcu-gold font-medium">Tip:</span> Mission progress is tracked automatically when you import your game data from Settings.
            </p>
          </div>
        </div>
      );
    };

    // ==================== ERROR BOUNDARY ====================
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('App Error:', error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="p-4 bg-red-900/50 rounded-lg text-center m-4">
              <h2 className="text-xl font-display font-semibold text-mcu-red mb-2">Something went wrong</h2>
              <p className="text-gray-300 mb-4">{this.state.error?.message || 'An unexpected error occurred'}</p>
              <button
                onClick={() => this.setState({ hasError: false, error: null })}
                className="bg-mcu-blue px-4 py-2 rounded font-medium hover:bg-blue-600"
              >
                Try Again
              </button>
            </div>
          );
        }
        return this.props.children;
      }
    }

    // ==================== CONFIRMATION DIALOG ====================
    const ConfirmDialog = ({
      isOpen,
      title,
      message,
      confirmText = "Confirm",
      cancelText = "Cancel",
      danger = false,
      onConfirm,
      onCancel
    }) => {
      // Handle escape key
      useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape' && isOpen) {
            onCancel();
          }
        };
        window.addEventListener('keydown', handleEscape);
        return () => window.removeEventListener('keydown', handleEscape);
      }, [isOpen, onCancel]);

      if (!isOpen) return null;

      return (
        <div
          className="modal-overlay"
          role="dialog"
          aria-modal="true"
          aria-labelledby="confirm-dialog-title"
          onClick={onCancel}
        >
          <div
            className="modal p-6 max-w-sm"
            onClick={e => e.stopPropagation()}
          >
            <h3
              id="confirm-dialog-title"
              className="text-xl font-display font-semibold text-[#c75fff] mb-3"
            >
              {title}
            </h3>
            <p className="text-gray-300 mb-6">{message}</p>
            <div className="flex gap-3">
              <button
                onClick={onCancel}
                className="flex-1 bg-[#2b1933] text-white py-3 rounded-lg font-medium hover:bg-[#3c2348] touch-target"
                autoFocus
              >
                {cancelText}
              </button>
              <button
                onClick={onConfirm}
                className={`flex-1 py-3 rounded-lg font-medium touch-target ${
                  danger
                    ? 'bg-red-600 text-white hover:bg-red-500'
                    : 'bg-mcu-blue text-white hover:bg-blue-600'
                }`}
              >
                {confirmText}
              </button>
            </div>
          </div>
        </div>
      );
    };

    // ==================== BATTLE PASS TRACKER ====================
    const BattlePassTracker = () => {
      const [battlePass, setBattlePass] = useState(() => loadFromStorage('snap_battlepass', null));
      const [timeModel, setTimeModel] = useState(() => loadFromStorage('snap_timemodel', null));

      // Reload data when snap-data-updated event fires
      useEffect(() => {
        const loadData = () => {
          setBattlePass(loadFromStorage('snap_battlepass', null));
          setTimeModel(loadFromStorage('snap_timemodel', null));
        };
        window.addEventListener('snap-data-updated', loadData);
        return () => window.removeEventListener('snap-data-updated', loadData);
      }, []);

      // XP required per level (simplified - actual game uses variable amounts)
      const XP_PER_LEVEL = 200;
      const MAX_LEVEL = 50;
      const TOTAL_SEASON_DAYS = 28;

      // Calculate XP progress
      const currentLevel = battlePass?.level || 0;
      const currentXp = battlePass?.xp || 0;
      const xpToNextLevel = XP_PER_LEVEL;
      const xpProgress = Math.min(100, (currentXp / xpToNextLevel) * 100);

      // Calculate days remaining in season
      const calculateDaysRemaining = () => {
        if (!timeModel?.seasonReset) return null;
        const now = new Date();
        const seasonEnd = new Date(timeModel.seasonReset);
        const diffMs = seasonEnd - now;
        if (diffMs <= 0) return 0;
        return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      };

      const daysRemaining = calculateDaysRemaining();

      // Calculate pacing status
      const calculatePacing = () => {
        if (daysRemaining === null || daysRemaining === 0) return { status: 'unknown', message: 'Season data unavailable', color: 'text-stitch-muted' };

        const daysPassed = TOTAL_SEASON_DAYS - daysRemaining;
        const expectedLevel = Math.floor((daysPassed / TOTAL_SEASON_DAYS) * MAX_LEVEL);
        const levelDiff = currentLevel - expectedLevel;

        if (levelDiff >= 5) return { status: 'ahead', message: `${levelDiff} levels ahead`, color: 'text-green-400' };
        if (levelDiff >= 0) return { status: 'ontrack', message: 'On track', color: 'text-mcu-gold' };
        if (levelDiff >= -5) return { status: 'behind', message: `${Math.abs(levelDiff)} levels behind`, color: 'text-yellow-400' };
        return { status: 'critical', message: `${Math.abs(levelDiff)} levels behind!`, color: 'text-red-400' };
      };

      const pacing = calculatePacing();

      // Placeholder tier rewards (actual rewards vary by season)
      const tierRewards = [
        { level: currentLevel, reward: 'Credits', amount: '200', claimed: true },
        { level: currentLevel + 1, reward: 'Boosters', amount: '50', claimed: false },
        { level: currentLevel + 2, reward: 'Gold', amount: '50', claimed: false },
        { level: currentLevel + 3, reward: 'Avatar', amount: '1', claimed: false },
        { level: currentLevel + 4, reward: 'Variant', amount: '1', claimed: false },
      ].filter(t => t.level <= MAX_LEVEL);

      // Format countdown
      const formatCountdown = () => {
        if (daysRemaining === null) return 'Unknown';
        if (daysRemaining === 0) return 'Season ending!';
        if (daysRemaining === 1) return '1 day left';
        return `${daysRemaining} days left`;
      };

      return (
        <div className="px-4 pb-20">
          <Header title="BATTLE PASS" />

          {/* Season Info Card */}
          <div className="stitch-card bg-gradient-to-r from-mcu-red/30 to-series-3/30 p-4 mb-4">
            <div className="flex justify-between items-center mb-2">
              <h2 className="text-lg font-display font-semibold text-white">
                {battlePass?.season || 'Current Season'}
              </h2>
              <span className="text-sm bg-black/30 px-2 py-1 rounded text-white">
                {formatCountdown()}
              </span>
            </div>
            {battlePass?.importedAt && (
              <div className="text-xs text-white/60">
                Last synced: {new Date(battlePass.importedAt).toLocaleDateString()}
              </div>
            )}
          </div>

          {/* Large Level Display */}
          <div className="stitch-card p-6 mb-4 text-center">
            <div className="text-stitch-muted text-sm mb-1">Current Level</div>
            <div className="text-6xl font-hero text-mcu-gold mcu-text-glow mb-2">
              {currentLevel}
            </div>
            <div className="text-stitch-muted text-sm">of {MAX_LEVEL}</div>

            {/* XP Progress Bar */}
            <div className="mt-4">
              <div className="flex justify-between text-sm text-stitch-muted mb-1">
                <span>XP Progress</span>
                <span>{currentXp} / {xpToNextLevel}</span>
              </div>
              <div className="h-4 bg-[#1a1320] rounded-full overflow-hidden">
                <div
                  className="h-full bg-gradient-to-r from-mcu-blue to-series-3 transition-all duration-500"
                  style={{ width: `${xpProgress}%` }}
                />
              </div>
            </div>

            {/* Pacing Status */}
            <div className={`mt-4 text-lg font-medium ${pacing.color}`}>
              {pacing.message}
            </div>
          </div>

          {/* Tier Rewards Preview */}
          <div className="stitch-card p-5 mb-4">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Upcoming Rewards</h3>
            <div className="space-y-2">
              {tierRewards.map((tier, index) => (
                <div
                  key={tier.level}
                  className={`flex items-center justify-between p-3 rounded-lg ${
                    tier.claimed
                      ? 'bg-green-900/30 border border-green-600/50'
                      : index === 1
                        ? 'bg-mcu-blue/20 border border-mcu-blue/50'
                        : 'bg-[#1a1320]/50'
                  }`}
                >
                  <div className="flex items-center gap-3">
                    <div className={`w-10 h-10 rounded-lg flex items-center justify-center font-bold ${
                      tier.claimed ? 'bg-green-600 text-white' : 'bg-[#2b1933] text-gray-300'
                    }`}>
                      {tier.level}
                    </div>
                    <div>
                      <div className="text-white font-medium">{tier.reward}</div>
                      <div className="text-xs text-stitch-muted">x{tier.amount}</div>
                    </div>
                  </div>
                  {tier.claimed ? (
                    <span className="text-green-400 text-sm">Claimed</span>
                  ) : index === 1 ? (
                    <span className="text-mcu-blue text-sm font-medium">Next</span>
                  ) : (
                    <span className="text-gray-500 text-sm">Locked</span>
                  )}
                </div>
              ))}
            </div>
          </div>

          {/* Season Progress Stats */}
          <div className="stitch-card p-5">
            <h3 className="text-lg font-display font-semibold text-[#c75fff] mb-3">Season Stats</h3>
            <div className="grid grid-cols-2 gap-4">
              <div className="bg-[#1a1320]/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">{currentLevel}</div>
                <div className="text-xs text-stitch-muted">Levels Earned</div>
              </div>
              <div className="bg-[#1a1320]/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">
                  {battlePass?.claimedLevels?.length || 0}
                </div>
                <div className="text-xs text-stitch-muted">Rewards Claimed</div>
              </div>
              <div className="bg-[#1a1320]/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">
                  {MAX_LEVEL - currentLevel}
                </div>
                <div className="text-xs text-stitch-muted">Levels Remaining</div>
              </div>
              <div className="bg-[#1a1320]/50 rounded-lg p-3 text-center">
                <div className="text-2xl font-bold text-white">
                  {daysRemaining !== null ? Math.ceil((MAX_LEVEL - currentLevel) / Math.max(1, daysRemaining)) : '?'}
                </div>
                <div className="text-xs text-stitch-muted">Levels/Day Needed</div>
              </div>
            </div>
          </div>

          {/* No Data State */}
          {!battlePass && (
            <div className="stitch-card p-6 text-center mt-4">
              <div className="text-4xl mb-3"></div>
              <h3 className="text-lg font-display font-semibold text-gray-300 mb-2">No Battle Pass Data</h3>
              <p className="text-sm text-gray-500 mb-4">
                Link your Marvel Snap folder in Settings to import your Battle Pass progress.
              </p>
            </div>
          )}
        </div>
      );
    };

    // ==================== OFFLINE INDICATOR ====================
    const OfflineIndicator = () => {
      const [isOnline, setIsOnline] = useState(navigator.onLine);

      useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);

        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      if (isOnline) return null;

      return (
        <div
          className="fixed top-0 left-0 right-0 bg-yellow-600 text-black text-center py-2 text-sm font-medium z-50"
          role="alert"
          aria-live="polite"
          style={{ paddingTop: 'calc(0.5rem + env(safe-area-inset-top))' }}
        >
          You're offline - AI features unavailable
        </div>
      );
    };

    // ==================== PWA INSTALL BANNER ====================
    const InstallBanner = () => {
      const [deferredPrompt, setDeferredPrompt] = useState(null);
      const [showBanner, setShowBanner] = useState(false);
      const [dismissed, setDismissed] = useState(() => {
        return localStorage.getItem('snap_install_dismissed') === 'true';
      });

      useEffect(() => {
        // Check if already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
          return;
        }

        const handler = (e) => {
          e.preventDefault();
          setDeferredPrompt(e);
          if (!dismissed) {
            setShowBanner(true);
          }
        };

        window.addEventListener('beforeinstallprompt', handler);

        // Track successful installs
        window.addEventListener('appinstalled', () => {
          setShowBanner(false);
          setDeferredPrompt(null);
          console.log('App installed successfully');
        });

        return () => {
          window.removeEventListener('beforeinstallprompt', handler);
        };
      }, [dismissed]);

      const handleInstall = async () => {
        if (!deferredPrompt) return;

        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;

        if (outcome === 'accepted') {
          console.log('User accepted install');
        }
        setDeferredPrompt(null);
        setShowBanner(false);
      };

      const handleDismiss = () => {
        setShowBanner(false);
        setDismissed(true);
        localStorage.setItem('snap_install_dismissed', 'true');
      };

      if (!showBanner || !deferredPrompt) return null;

      return (
        <div
          className="fixed bottom-20 left-4 right-4 stitch-card bg-cosmic-purple/20 p-4 shadow-lg z-40 install-banner-enter"
          role="complementary"
          aria-label="Install app prompt"
          style={{ marginBottom: 'env(safe-area-inset-bottom)' }}
        >
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 bg-mcu-blue rounded-lg flex items-center justify-center flex-shrink-0">
              <span className="text-2xl"></span>
            </div>
            <div className="flex-1 min-w-0">
              <h4 className="font-bold text-white text-sm">Install SnapPrime</h4>
              <p className="text-xs text-white/80 truncate">Add to home screen for quick access</p>
            </div>
            <button
              onClick={handleInstall}
              className="bg-mcu-gold text-black px-3 py-2 rounded font-bold text-sm hover:bg-yellow-400 flex-shrink-0"
            >
              Install
            </button>
            <button
              onClick={handleDismiss}
              className="text-white/60 p-2 hover:text-white flex-shrink-0"
              aria-label="Dismiss install prompt"
            >
              
            </button>
          </div>
        </div>
      );
    };

    // ==================== MAIN APP ====================
    // Performance mode detection - runs once at app init
    const detectPerformanceMode = () => {
      const savedMode = localStorage.getItem('snap_perf_mode');
      if (savedMode) {
        document.documentElement.setAttribute('data-perf', savedMode);
        return;
      }
      // Auto-detect low-power devices
      const isLowPower =
        window.matchMedia('(prefers-reduced-motion: reduce)').matches ||
        (navigator.deviceMemory && navigator.deviceMemory <= 4);
      if (isLowPower) {
        document.documentElement.setAttribute('data-perf', 'low');
      }
    };
    detectPerformanceMode();

    // Reduced motion preference toggle
    const setReducedMotion = (enabled) => {
      if (enabled) {
        document.documentElement.setAttribute('data-motion', 'reduced');
        localStorage.setItem('snap_motion_reduced', 'true');
      } else {
        document.documentElement.removeAttribute('data-motion');
        localStorage.removeItem('snap_motion_reduced');
      }
    };

    // Check saved motion preference
    if (localStorage.getItem('snap_motion_reduced') === 'true') {
      document.documentElement.setAttribute('data-motion', 'reduced');
    }

    // Victory/Defeat Splash Overlay - Spider-Verse Style
    const VictorySplash = ({ show, result, cubes, onClose }) => {
      const isWin = result === 'WIN';
      const isHighStakes = cubes >= 4;
      const isMaxStakes = cubes === 8;

      useEffect(() => {
        if (show) {
          const duration = isMaxStakes ? 2500 : isHighStakes ? 2000 : 1500;
          const timer = setTimeout(onClose, duration);
          return () => clearTimeout(timer);
        }
      }, [show, isHighStakes, isMaxStakes, onClose]);

      if (!show) return null;

      // Only show full splash for 4+ cubes
      if (cubes < 4) {
        return (
          <div className="fixed bottom-24 left-4 right-4 z-50 animate-bounce">
            <div className={`stitch-card p-4 ${isWin ? 'border-l-4 border-green-500' : 'border-l-4 border-mcu-red'} sketch-border`}>
              <div className="flex items-center justify-between">
                <span className="font-display font-bold text-lg">{isWin ? 'Victory!' : 'Defeat'}</span>
                <span className={`font-hero text-2xl ${isWin ? 'text-green-400' : 'text-mcu-red'}`}>
                  {isWin ? '+' : '-'}{cubes}
                </span>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm" onClick={onClose}>
          <div className="text-center">
            {/* Main Title with Spider-Verse Chromatic Effect */}
            <h1 className={`font-hero text-6xl md:text-8xl mb-4 ${isMaxStakes ? 'chromatic-glitch' : 'glitch-text'}`}
                style={{ color: isWin ? '#22C55E' : '#ff4444' }}>
              {isWin ? 'VICTORY' : 'DEFEAT'}
            </h1>

            {/* Cube Count Badge with Sketch Border */}
            <div className={`inline-block px-6 py-3 sketch-border transform rotate-2 ${isWin ? 'bg-spider-yellow' : 'bg-mcu-red'}`}>
              <span className="font-hero text-3xl text-black">
                {isWin ? '+' : ''}{cubes} CUBES
              </span>
            </div>

            {/* Starburst Effect for 8-cube matches */}
            {isMaxStakes && (
              <div className="mt-6 animate-pulse">
                <span className="text-4xl"> INCREDIBLE! </span>
              </div>
            )}

            <p className="mt-6 text-stitch-muted text-sm">Tap anywhere to continue</p>
          </div>
        </div>
      );
    };

    // ==================== USER PROFILE COMPONENT ====================
    const UserProfile = ({ collection, matches }) => {
      const totalCards = uniqueCards.length;
      const ownedCount = collection.owned.filter(name => uniqueCards.some(c => c.name === name)).length;
      const completionPercent = totalCards > 0 ? Math.round((ownedCount / totalCards) * 100) : 0;
      const totalWins = matches.filter(m => m.result === 'WIN').length;
      const totalGames = matches.length;
      const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const netCubes = matches.reduce((sum, m) => sum + (m.result === 'WIN' ? m.cubes : -m.cubes), 0);
      const rank = loadFromStorage('snap_rank', null);
      const importedStats = loadFromStorage('snap_profile_stats', null);
      const decks = loadFromStorage('snap_decks', []);

      const achievements = useMemo(() => {
        const list = [];
        if (ownedCount >= 50) list.push({ icon: 'style', name: 'Card Collector', desc: 'Own 50+ cards', progress: 100 });
        else list.push({ icon: 'style', name: 'Card Collector', desc: 'Own 50+ cards', progress: Math.round((ownedCount / 50) * 100) });
        if (totalGames >= 100) list.push({ icon: 'military_tech', name: 'Battle Hardened', desc: 'Play 100 matches', progress: 100 });
        else list.push({ icon: 'military_tech', name: 'Battle Hardened', desc: 'Play 100 matches', progress: Math.min(100, Math.round((totalGames / 100) * 100)) });
        if (winRate >= 60) list.push({ icon: 'emoji_events', name: 'Sharp Snapper', desc: '60%+ win rate', progress: 100 });
        else list.push({ icon: 'emoji_events', name: 'Sharp Snapper', desc: '60%+ win rate', progress: Math.round((winRate / 60) * 100) });
        if (netCubes >= 100) list.push({ icon: 'diamond', name: 'Cube Master', desc: 'Earn 100+ net cubes', progress: 100 });
        else list.push({ icon: 'diamond', name: 'Cube Master', desc: 'Earn 100+ net cubes', progress: Math.min(100, Math.max(0, Math.round((netCubes / 100) * 100))) });
        return list;
      }, [ownedCount, totalGames, winRate, netCubes]);

      return (
        <div className="px-4 pb-20">
          <Header title="PROFILE" />

          {/* Profile Header */}
          <div className="flex flex-col items-center mb-6">
            <div className="w-24 h-24 rounded-full bg-gradient-to-br from-cosmic-purple to-cosmic-cyan p-1 mb-3">
              <div className="w-full h-full rounded-full bg-stitch-card flex items-center justify-center">
                <span className="material-symbols-outlined text-4xl text-cosmic-purple-text">person</span>
              </div>
            </div>
            {rank && (
              <div className="text-center">
                <div className="text-2xl font-display font-bold text-white rank-glow">{rank.tier || 'UNRANKED'}</div>
                {rank.currentRank && <div className="text-sm text-stitch-muted">Level {rank.currentRank}</div>}
              </div>
            )}
            {importedStats?.snapId && (
              <div className="text-xs text-stitch-muted mt-1">{importedStats.snapId}</div>
            )}
          </div>

          {/* Stats Grid */}
          <div className="grid grid-cols-2 gap-3 mb-4">
            <div className="stitch-stat p-4 text-center">
              <div className="stitch-label mb-1">Collection</div>
              <div className="text-3xl font-display font-bold text-white">{completionPercent}%</div>
              <div className="text-xs text-stitch-muted">{ownedCount} / {totalCards} cards</div>
            </div>
            <div className="stitch-stat p-4 text-center">
              <div className="stitch-label mb-1">Win Rate</div>
              <div className="text-3xl font-display font-bold text-cosmic-purple-text">{winRate}%</div>
              <div className="text-xs text-stitch-muted">{totalWins}W / {totalGames - totalWins}L</div>
            </div>
            <div className="stitch-stat p-4 text-center">
              <div className="stitch-label mb-1">Total Cubes</div>
              <div className={`text-3xl font-display font-bold ${netCubes >= 0 ? 'text-stitch-green' : 'text-red-500'}`}>
                {netCubes >= 0 ? '+' : ''}{netCubes}
              </div>
              <div className="text-xs text-stitch-muted">{totalGames} matches</div>
            </div>
            <div className="stitch-stat p-4 text-center">
              <div className="stitch-label mb-1">Highest Rank</div>
              <div className="text-3xl font-display font-bold text-mcu-gold">
                {rank?.tier || '--'}
              </div>
              <div className="text-xs text-stitch-muted">This season</div>
            </div>
          </div>

          {/* Favorite Decks */}
          {decks.length > 0 && (
            <div className="mb-4">
              <div className="stitch-section-header">
                <span className="material-symbols-outlined" aria-hidden="true">auto_fix_high</span>
                Favorite Decks
              </div>
              <div className="flex gap-3 overflow-x-auto pb-2 scrollbar-hide">
                {decks.slice(0, 5).map(deck => (
                  <div key={deck.id} className="stitch-card p-4 min-w-[200px] border-l-4 border-cosmic-purple">
                    <div className="text-sm font-bold text-white mb-1">{deck.name}</div>
                    <div className="text-xs text-stitch-muted">{deck.cards?.length || 0} cards</div>
                    <div className="flex -space-x-2 mt-2">
                      {(deck.cards || []).slice(0, 4).map((cardName, i) => {
                        const card = uniqueCards.find(c => c.name === cardName);
                        return (
                          <div key={i} className="w-8 h-10 rounded-lg overflow-hidden border border-stitch-border card-art"
                            style={{ backgroundImage: `url(${getCardArtUrl(card || { name: cardName })})`, zIndex: 4 - i }} />
                        );
                      })}
                      {(deck.cards || []).length > 4 && (
                        <div className="w-8 h-10 rounded-lg bg-stitch-accent flex items-center justify-center text-xs text-stitch-muted border border-stitch-border">
                          +{deck.cards.length - 4}
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Achievements */}
          <div className="stitch-section-header">
            <span className="material-symbols-outlined" aria-hidden="true">workspace_premium</span>
            Achievements
          </div>
          <div className="space-y-2">
            {achievements.map((ach, i) => (
              <div key={i} className="stitch-list-item flex items-center gap-3 p-3">
                <div className={`w-10 h-10 rounded-full flex items-center justify-center ${ach.progress >= 100 ? 'bg-stitch-green/20' : 'bg-stitch-accent'}`}>
                  <span className={`material-symbols-outlined ${ach.progress >= 100 ? 'text-stitch-green' : 'text-stitch-muted'}`} style={{fontSize: '20px'}}>{ach.icon}</span>
                </div>
                <div className="flex-1">
                  <div className="text-sm font-bold text-white">{ach.name}</div>
                  <div className="text-xs text-stitch-muted">{ach.desc}</div>
                  <div className="stitch-progress mt-1">
                    <div className={`stitch-progress-fill ${ach.progress >= 100 ? 'bg-stitch-green' : 'bg-cosmic-purple'}`}
                      style={{ width: `${Math.min(100, ach.progress)}%` }} />
                  </div>
                </div>
                <span className="text-xs font-bold text-stitch-muted">{Math.min(100, ach.progress)}%</span>
              </div>
            ))}
          </div>
        </div>
      );
    };

    // ==================== META TIER LIST COMPONENT ====================
    const MetaTierList = () => {
      const [timeRange, setTimeRange] = useState('week');

      const tierData = useMemo(() => ({
        S: [
          { name: 'Destroy', winRate: 58, playRate: 12, cards: ['Death', 'Knull', 'Carnage', 'Deathlok'] },
          { name: 'Bounce', winRate: 56, playRate: 9, cards: ['Beast', 'Falcon', 'Angela', 'Kitty Pryde'] },
        ],
        A: [
          { name: 'Discard', winRate: 54, playRate: 8, cards: ['Blade', 'Lady Sif', 'Wolverine', 'Apocalypse'] },
          { name: 'Move', winRate: 53, playRate: 7, cards: ['Human Torch', 'Multiple Man', 'Iron Fist', 'Heimdall'] },
          { name: 'High Evo', winRate: 53, playRate: 6, cards: ['Hulk', 'Cyclops', 'Abomination', 'The Thing'] },
        ],
        B: [
          { name: 'Ongoing', winRate: 51, playRate: 5, cards: ['Iron Man', 'Spectrum', 'Onslaught', 'Namor'] },
          { name: 'Zoo', winRate: 50, playRate: 5, cards: ['Ant-Man', 'Squirrel Girl', 'Blue Marvel', 'Kazar'] },
        ],
        C: [
          { name: 'Control', winRate: 49, playRate: 4, cards: ['Cosmo', 'Enchantress', 'Armor', 'Spider-Woman'] },
        ]
      }), []);

      const tierColors = { S: 'bg-cosmic-purple', A: 'bg-blue-600', B: 'bg-yellow-600', C: 'bg-gray-600' };

      return (
        <div className="px-4 pb-20">
          <Header title="META TIER LIST" subtitle="Community Rankings" />

          {/* Time Range Filter */}
          <div className="flex gap-2 mb-4">
            {['week', 'month', 'season'].map(range => (
              <button key={range} className={`stitch-pill ${timeRange === range ? 'active' : ''}`}
                onClick={() => setTimeRange(range)}>
                {range === 'week' ? '7 Days' : range === 'month' ? '30 Days' : 'Season'}
              </button>
            ))}
          </div>

          {/* Tier Sections */}
          {Object.entries(tierData).map(([tier, decks]) => (
            <div key={tier} className="mb-4">
              <div className="flex items-center gap-2 mb-2">
                <span className={`w-8 h-8 rounded-lg ${tierColors[tier]} flex items-center justify-center text-white font-bold text-sm`}>{tier}</span>
                <span className="stitch-label">{tier === 'S' ? 'Top Tier' : tier === 'A' ? 'Strong' : tier === 'B' ? 'Viable' : 'Niche'}</span>
              </div>
              <div className="space-y-2">
                {decks.map((deck, i) => {
                  const heroCard = uniqueCards.find(c => c.name === deck.cards[0]);
                  return (
                    <div key={i} className={`stitch-list-item p-0 overflow-hidden ${tier === 'S' ? '' : ''}`}>
                      {tier === 'S' ? (
                        /* S-Tier: Full hero art banner */
                        <div className="relative h-32 overflow-hidden">
                          <div className="absolute inset-0 card-art" style={{ backgroundImage: `url(${getCardArtUrl(heroCard || { name: deck.cards[0] })})` }} />
                          <div className="absolute inset-0 bg-gradient-to-r from-black/80 via-black/40 to-transparent" />
                          <div className="relative z-10 p-4 h-full flex flex-col justify-between">
                            <div>
                              <div className="text-lg font-display font-bold text-white">{deck.name}</div>
                              <div className="flex gap-2 mt-1">
                                <span className="stitch-badge bg-stitch-green/20 text-stitch-green">{deck.winRate}% WR</span>
                                <span className="stitch-badge">{deck.playRate}% Play</span>
                              </div>
                            </div>
                            <div className="flex -space-x-1">
                              {deck.cards.slice(0, 4).map((cardName, j) => {
                                const c = uniqueCards.find(cc => cc.name === cardName);
                                return (
                                  <div key={j} className="w-8 h-10 rounded-lg overflow-hidden border border-white/20 card-art"
                                    style={{ backgroundImage: `url(${getCardArtUrl(c || { name: cardName })})` }} />
                                );
                              })}
                            </div>
                          </div>
                        </div>
                      ) : (
                        /* A/B/C-Tier: Compact list items */
                        <div className="flex items-center gap-3 p-3">
                          <div className="w-14 h-16 rounded-lg overflow-hidden flex-shrink-0 card-art"
                            style={{ backgroundImage: `url(${getCardArtUrl(heroCard || { name: deck.cards[0] })})` }} />
                          <div className="flex-1 min-w-0">
                            <div className="text-sm font-bold text-white">{deck.name}</div>
                            <div className="flex gap-2 mt-1">
                              <span className="text-xs text-stitch-green">{deck.winRate}% WR</span>
                              <span className="text-xs text-stitch-muted">{deck.playRate}% Play</span>
                            </div>
                          </div>
                          <span className="material-symbols-outlined text-stitch-muted" style={{fontSize: '18px'}}>chevron_right</span>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          ))}
        </div>
      );
    };

    const App = () => {
      const [activeTab, setActiveTab] = useState('dashboard');
      const [collection, setCollection] = useState(() => loadFromStorage('snap_collection', { owned: [], lastUpdated: new Date().toISOString() }));
      const [matches, setMatches] = useState(() => loadFromStorage('snap_matches', []));
      const [decks, setDecks] = useState(() => loadFromStorage('snap_decks', []));
      const [settings, setSettings] = useState(() => loadFromStorage('snap_settings', { theme: 'dark', perfMode: 'auto', reducedMotion: false }));
      const [aiConfig, setAiConfig] = useState(() => loadFromStorage('snap_ai_config', {
        provider: '',
        model: '',
        apiKeys: {},
        googleToken: null,
        localEndpoint: 'http://localhost:11434'
      }));

      // Card data version - triggers re-render when uniqueCards updates
      const [cardDataVersion, setCardDataVersion] = useState(0);

      // Victory/Defeat splash state
      const [victorySplash, setVictorySplash] = useState({ show: false, result: null, cubes: 0 });

      // Subscribe to uniqueCards updates to trigger re-renders
      useEffect(() => {
        const unsubscribe = onUniqueCardsUpdate((cards) => {
          setCardDataVersion(v => v + 1);
          console.log(`[App] Card data updated: ${cards.length} cards available`);
        });
        return unsubscribe;
      }, []);

      // Phase 4: URL Sync state
      const [syncImportData, setSyncImportData] = useState(null);
      const [showSyncConfirm, setShowSyncConfirm] = useState(false);

      useEffect(() => { saveToStorage('snap_collection', collection); }, [collection]);
      useEffect(() => { saveToStorage('snap_matches', matches); }, [matches]);
      useEffect(() => { saveToStorage('snap_decks', decks); }, [decks]);
      useEffect(() => { saveToStorage('snap_settings', settings); }, [settings]);
      useEffect(() => { saveToStorage('snap_ai_config', aiConfig); }, [aiConfig]);

      // Dynamic document title
      useEffect(() => {
        const titles = {
          dashboard: 'Home',
          collection: 'Collection',
          decks: 'Decks',
          ai: 'AI Advisor',
          settings: 'Settings',
          history: 'Match History',
          calculator: 'Calculator',
          planner: 'Upgrade Planner',
          oracle: 'Oracle',
          armor: 'Hall of Armor',
          missions: 'Missions',
          battlepass: 'Battle Pass',
          economy: 'Economy',
          board: 'Board Snapshot',
          simulator: 'Simulator',
          profile: 'Profile',
          meta: 'Meta Tier List'
        };
        document.title = (titles[activeTab] || 'Home') + ' - Snapapoulous Prime';
      }, [activeTab]);

      // Sync reduced motion setting on load and when settings change
      useEffect(() => {
        if (settings.reducedMotion) {
          document.documentElement.setAttribute('data-motion', 'reduced');
        } else {
          document.documentElement.removeAttribute('data-motion');
        }
      }, [settings.reducedMotion]);

      // Phase 4: Check for sync parameter in URL on load (supports v1, v2, and multi-part)
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const syncV1 = params.get('sync');
        const syncV2 = params.get('sync2');
        const syncPart2 = params.get('sync_part2');

        // Handle single-QR v1 format (backward compatible)
        if (syncV1) {
          try {
            const data = VaultManager.decompressFromQR(syncV1);
            if (data && data.v === 1 && data.c) {
              setSyncImportData(data);
              setShowSyncConfirm(true);
              window.history.replaceState({}, '', window.location.pathname);
            }
          } catch (e) {
            console.error('Invalid v1 sync data:', e);
          }
        }

        // Handle single-QR v2 format (index-based compression)
        if (syncV2) {
          try {
            const data = VaultManager.decompressFromQRv2(syncV2, uniqueCards);
            if (data && data.c) {
              setSyncImportData(data);
              setShowSyncConfirm(true);
              window.history.replaceState({}, '', window.location.pathname);
            }
          } catch (e) {
            console.error('Invalid v2 sync data:', e);
          }
        }

        // Handle multi-part v2 format with checksum validation
        if (syncPart2) {
          try {
            const decompressed = LZString.decompressFromEncodedURIComponent(syncPart2);
            const partPayload = JSON.parse(decompressed);

            if (partPayload && partPayload.p && partPayload.t && partPayload.d) {
              // Get existing progress from localStorage (persists across page loads)
              const progressKey = 'snap_qr_scan_progress';
              let progress = JSON.parse(localStorage.getItem(progressKey) || 'null');

              // Initialize or validate progress
              if (!progress || progress.total !== partPayload.t) {
                progress = {
                  scanned: [],
                  total: partPayload.t,
                  parts: {}
                };
              }

              // Add this part (avoid duplicates)
              if (!progress.parts[partPayload.p]) {
                progress.parts[partPayload.p] = partPayload;
                progress.scanned = Object.keys(progress.parts).map(Number).sort((a, b) => a - b);
              }

              // Calculate missing parts
              const missing = VaultManager.findMissingParts(Object.values(progress.parts), progress.total);

              // Save progress
              localStorage.setItem(progressKey, JSON.stringify(progress));

              if (missing.length === 0) {
                // All parts received - merge and validate
                const mergeResult = VaultManager.mergeMultiPartPayloads(Object.values(progress.parts));

                if (mergeResult.error) {
                  setQrError(`Sync error: ${mergeResult.error}${mergeResult.part ? ` (part ${mergeResult.part})` : ''}`);
                } else {
                  // Decompress merged data
                  const data = VaultManager.decompressFromQRv2(mergeResult.data, uniqueCards);
                  if (data && data.c) {
                    setSyncImportData(data);
                    setShowSyncConfirm(true);
                    localStorage.removeItem(progressKey); // Clear progress
                  }
                }
              } else {
                // Show progress UI
                setQrScanProgress({
                  scanned: progress.scanned,
                  total: progress.total,
                  missing: missing
                });
                setShowMultiPartProgress(true);
              }

              window.history.replaceState({}, '', window.location.pathname);
            }
          } catch (e) {
            console.error('Invalid multi-part sync data:', e);
          }
        }
      }, []);

      // Handle URL parameters for shortcuts and deep links
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const tab = params.get('tab');
        const action = params.get('action');

        if (tab && ['dashboard', 'ai', 'collection', 'decks', 'simulator', 'calculator', 'settings', 'oracle', 'armor', 'missions', 'battlepass', 'economy', 'board', 'history', 'planner', 'profile', 'meta'].includes(tab)) {
          setActiveTab(tab);
        }

        if (action === 'quick-match') {
          // Could trigger quick match modal in the future
          setActiveTab('dashboard');
        }

        // Clean URL after handling (keep source param for analytics)
        if (tab || action) {
          const newUrl = window.location.pathname + (params.get('source') ? `?source=${params.get('source')}` : '');
          window.history.replaceState({}, '', newUrl);
        }
      }, []);

      const handleSyncImport = () => {
        if (syncImportData && syncImportData.c) {
          // Merge collections - add new cards without removing existing
          const existingOwned = new Set(collection.owned || []);
          syncImportData.c.forEach(card => existingOwned.add(card));

          setCollection({
            owned: Array.from(existingOwned),
            lastUpdated: new Date().toISOString()
          });

          setShowSyncConfirm(false);
          setSyncImportData(null);
          alert(`Synced ${syncImportData.c.length} cards to your collection!`);
        }
      };

      const handleQuickMatch = (result, cubes) => {
        setMatches(prev => [...prev, {
          id: generateId(),
          timestamp: new Date().toISOString(),
          result, cubes,
          opponent: '', deck: '', notes: '', snapped: 'NONE'
        }]);
        // Trigger victory/defeat splash
        setVictorySplash({ show: true, result, cubes });
      };

      useEffect(() => {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js')
            .then(reg => {
              console.log('SW registered:', reg.scope);

              // Check for updates immediately and periodically
              reg.update();

              // Listen for new service worker installing
              reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                console.log('[SW] New version found, installing...');

                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    // New SW installed and there's an existing one - new version available
                    console.log('[SW] New version installed, will reload...');
                    // Tell the new SW to take over immediately
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                  }
                });
              });
            })
            .catch(err => console.error('SW error:', err));

          // Reload page when new service worker takes control
          let refreshing = false;
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!refreshing) {
              refreshing = true;
              console.log('[SW] New version activated, reloading...');
              window.location.reload();
            }
          });
        }
      }, []);

      // Battery optimization - reduce animations when battery is low
      useEffect(() => {
        const checkBattery = async () => {
          if ('getBattery' in navigator) {
            try {
              const battery = await navigator.getBattery();

              const updatePowerMode = () => {
                const isLowPower = battery.level < 0.2 && !battery.charging;
                document.body.classList.toggle('low-power-mode', isLowPower);
              };

              updatePowerMode();
              battery.addEventListener('levelchange', updatePowerMode);
              battery.addEventListener('chargingchange', updatePowerMode);

              return () => {
                battery.removeEventListener('levelchange', updatePowerMode);
                battery.removeEventListener('chargingchange', updatePowerMode);
              };
            } catch (e) {
              console.log('Battery API not available');
            }
          }
        };

        // Low-end device detection
        const isLowEndDevice = () => {
          if (navigator.deviceMemory && navigator.deviceMemory < 4) return true;
          if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) return true;
          if (navigator.connection) {
            const { effectiveType, saveData } = navigator.connection;
            if (saveData || effectiveType === '2g' || effectiveType === 'slow-2g') return true;
          }
          return false;
        };

        if (isLowEndDevice()) {
          document.body.classList.add('low-end-mode');
        }

        checkBattery();
      }, []);

      // Android back button handling
      useEffect(() => {
        // Push initial state
        if (!window.history.state?.tab) {
          window.history.replaceState({ tab: activeTab }, '');
        }

        const handlePopState = (event) => {
          if (event.state?.tab) {
            setActiveTab(event.state.tab);
          } else if (activeTab !== 'dashboard') {
            // Navigate back to dashboard instead of closing app
            setActiveTab('dashboard');
            window.history.pushState({ tab: 'dashboard' }, '');
          }
        };

        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      // Push state when tab changes
      useEffect(() => {
        if (window.history.state?.tab !== activeTab) {
          window.history.pushState({ tab: activeTab }, '');
        }
      }, [activeTab]);

      // Listen for custom tab navigation events (from Settings quick links)
      useEffect(() => {
        const handleSetTab = (e) => setActiveTab(e.detail);
        window.addEventListener('setActiveTab', handleSetTab);
        return () => window.removeEventListener('setActiveTab', handleSetTab);
      }, []);

      return (
        <div className="min-h-screen bg-stark-dark mcu-hud-grid">
          {/* Skip link for keyboard accessibility */}
          <a href="#main-content" className="sr-only focus:not-sr-only focus:absolute focus:top-0 focus:left-0 focus:z-50 focus:bg-mcu-blue focus:text-white focus:px-4 focus:py-2 focus:font-medium">
            Skip to main content
          </a>
          <OfflineIndicator />
          <InstallBanner />
          {/* Victory/Defeat Splash Overlay */}
          <VictorySplash
            show={victorySplash.show}
            result={victorySplash.result}
            cubes={victorySplash.cubes}
            onClose={() => setVictorySplash({ show: false, result: null, cubes: 0 })}
          />
          <main id="main-content" tabIndex="-1" role="main" aria-label="App content">
            {activeTab === 'dashboard' && (
              <ErrorBoundary>
                <Dashboard collection={collection} matches={matches} onQuickMatch={handleQuickMatch} />
              </ErrorBoundary>
            )}
            {activeTab === 'oracle' && (
              <ErrorBoundary>
                <SpotlightOracle collection={collection} />
              </ErrorBoundary>
            )}
            {activeTab === 'ai' && (
              <ErrorBoundary>
                <AIChat collection={collection} matches={matches} aiConfig={aiConfig} setActiveTab={setActiveTab} />
              </ErrorBoundary>
            )}
            {activeTab === 'collection' && (
              <ErrorBoundary>
                <Collection collection={collection} setCollection={setCollection} />
              </ErrorBoundary>
            )}
            {activeTab === 'armor' && (
              <ErrorBoundary>
                <HallOfArmor />
              </ErrorBoundary>
            )}
            {activeTab === 'planner' && (
              <ErrorBoundary>
                <UpgradePlanner />
              </ErrorBoundary>
            )}
            {activeTab === 'missions' && (
              <ErrorBoundary>
                <MissionTracker />
              </ErrorBoundary>
            )}
            {activeTab === 'battlepass' && (
              <ErrorBoundary>
                <BattlePassTracker />
              </ErrorBoundary>
            )}
            {activeTab === 'economy' && (
              <ErrorBoundary>
                <EconomyIntelligence />
              </ErrorBoundary>
            )}
            {activeTab === 'board' && (
              <ErrorBoundary>
                <BoardSnapshot />
              </ErrorBoundary>
            )}
            {activeTab === 'decks' && (
              <ErrorBoundary>
                <Decks decks={decks} setDecks={setDecks} collection={collection} />
              </ErrorBoundary>
            )}
            {activeTab === 'simulator' && (
              <ErrorBoundary>
                <Simulator decks={decks} collection={collection} />
              </ErrorBoundary>
            )}
            {activeTab === 'calculator' && (
              <ErrorBoundary>
                <Calculator />
              </ErrorBoundary>
            )}
            {activeTab === 'history' && (
              <ErrorBoundary>
                <MatchHistory matches={matches} />
              </ErrorBoundary>
            )}
            {activeTab === 'profile' && (
              <ErrorBoundary>
                <UserProfile collection={collection} matches={matches} />
              </ErrorBoundary>
            )}
            {activeTab === 'meta' && (
              <ErrorBoundary>
                <MetaTierList />
              </ErrorBoundary>
            )}
            {activeTab === 'settings' && (
              <ErrorBoundary>
                <Settings settings={settings} setSettings={setSettings} collection={collection} matches={matches} setCollection={setCollection} setMatches={setMatches} aiConfig={aiConfig} setAiConfig={setAiConfig} decks={decks} setDecks={setDecks} />
              </ErrorBoundary>
            )}
          </main>
          <NavBar activeTab={activeTab} setActiveTab={setActiveTab} />

          {/* Phase 4: Sync Confirm Modal */}
          {showSyncConfirm && syncImportData && (
            <SyncConfirmModal
              syncData={syncImportData}
              onConfirm={handleSyncImport}
              onCancel={() => { setShowSyncConfirm(false); setSyncImportData(null); }}
            />
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
